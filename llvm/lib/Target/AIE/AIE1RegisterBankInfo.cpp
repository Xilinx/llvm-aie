//===- AIE1RegisterBankInfo.cpp -------------------------------------------===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the RegisterBankInfo class for AIE1.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "AIE1RegisterBankInfo.h"
#include "AIEInstrInfo.h"
#include "AIERegisterInfo.h"
#include "MCTargetDesc/AIEMCTargetDesc.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/Support/Debug.h"

#define GET_TARGET_REGBANK_IMPL

#include "AIEGenRegisterBank.inc"

using namespace llvm;

RegisterBankInfo::PartialMapping AIEGenRegisterBankInfo::PartMappings[]{
    // StartIdx, Length, RegBank
    // 0: GPR 32-bit value
    {0, 32, AIE::GPRRegBank},
    // 1: PTR 20-bit value
    {0, 20, AIE::PTRRegBank},
    // 2: MOD 20-bit value
    {0, 20, AIE::MODRegBank},
    // 3: CB 20-bit value
    {0, 20, AIE::CBRegBank},
};

// ValueMappings.
RegisterBankInfo::ValueMapping AIEGenRegisterBankInfo::ValMappings[]{
    /* BreakDown, NumBreakDowns */
    // 0: invalid
    {nullptr, 0},
    // 3-operands instructions
    // 1: GPR 32-bit value. <-- This must match First3OpsIdx.
    {&AIEGenRegisterBankInfo::PartMappings[PMI_GPR - PMI_Min], 1},
    {&AIEGenRegisterBankInfo::PartMappings[PMI_GPR - PMI_Min], 1},
    {&AIEGenRegisterBankInfo::PartMappings[PMI_GPR - PMI_Min], 1},
    // 4: PTR 20-bit value.
    {&AIEGenRegisterBankInfo::PartMappings[PMI_PTR - PMI_Min], 1},
    {&AIEGenRegisterBankInfo::PartMappings[PMI_PTR - PMI_Min], 1},
    {&AIEGenRegisterBankInfo::PartMappings[PMI_PTR - PMI_Min], 1},
    // 7: MOD 20-bit value.
    {&AIEGenRegisterBankInfo::PartMappings[PMI_MOD - PMI_Min], 1},
    {&AIEGenRegisterBankInfo::PartMappings[PMI_MOD - PMI_Min], 1},
    {&AIEGenRegisterBankInfo::PartMappings[PMI_MOD - PMI_Min], 1},
    // 10: CB 20-bit value. <-- This must match Last3OpsIdx.
    {&AIEGenRegisterBankInfo::PartMappings[PMI_CB - PMI_Min], 1},
    {&AIEGenRegisterBankInfo::PartMappings[PMI_CB - PMI_Min], 1},
    {&AIEGenRegisterBankInfo::PartMappings[PMI_CB - PMI_Min], 1},
};

const RegisterBankInfo::ValueMapping *
AIEGenRegisterBankInfo::getValueMapping(PartialMappingIdx RBIdx,
                                        unsigned Size) const {
  assert(RBIdx != PartialMappingIdx::PMI_None && "No mapping needed for that");
  unsigned BaseIdxOffset = getRegBankBaseIdxOffset(RBIdx, Size);
  if (BaseIdxOffset == -1u)
    return &ValMappings[InvalidIdx];

  unsigned ValMappingIdx =
      First3OpsIdx + (RBIdx - PartialMappingIdx::PMI_Min + BaseIdxOffset) *
                         ValueMappingIdx::DistanceBetweenRegBanks;
  assert(ValMappingIdx >= First3OpsIdx && ValMappingIdx <= Last3OpsIdx &&
         "Mapping out of bound");

  return &ValMappings[ValMappingIdx];
}

AIE1RegisterBankInfo::AIE1RegisterBankInfo(const TargetRegisterInfo &TRI)
    : AIEGenRegisterBankInfo() {

  static llvm::once_flag InitializeRegisterBankFlag;

  static auto InitializeRegisterBankOnce = [&]() {
    // We have only one set of register banks, whatever the subtarget
    // is. Therefore, the initialization of the RegBanks table should be
    // done only once. Indeed the table of all register banks
    // (AIE::RegBanks) is unique in the compiler. At some point, it
    // will get tablegen'ed and the whole constructor becomes empty.

    const RegisterBank &RBGPR = getRegBank(AIE::GPRRegBankID);
    (void)RBGPR;
    assert(&AIE::GPRRegBank == &RBGPR && "The order in RegBanks is messed up");

    const RegisterBank &RBPTR = getRegBank(AIE::PTRRegBankID);
    (void)RBPTR;
    assert(&AIE::PTRRegBank == &RBPTR && "The order in RegBanks is messed up");
    assert(verify(TRI) && "Invalid register bank information");
  };

  llvm::call_once(InitializeRegisterBankFlag, InitializeRegisterBankOnce);
}

RegisterBankInfo::InstructionMappings
AIE1RegisterBankInfo::getInstrAlternativeMappings(
    const MachineInstr &MI) const {

  switch (MI.getOpcode()) {
  case TargetOpcode::G_ZEXT: {
    InstructionMappings AltMappings;
    const InstructionMapping &GPRMapping = getInstructionMapping(
        /*ID*/ 1, /*Cost*/ 1,
        getOperandsMapping(
            {getValueMapping(PMI_GPR, 32), getValueMapping(PMI_GPR, 20)}),
        /*NumOperands*/ 2);
    const InstructionMapping &PTRGPRMapping = getInstructionMapping(
        /*ID*/ 2, /*Cost*/ 1,
        getOperandsMapping(
            {getValueMapping(PMI_GPR, 32), getValueMapping(PMI_PTR, 20)}),
        /*NumOperands*/ 2);

    AltMappings.push_back(&GPRMapping);
    AltMappings.push_back(&PTRGPRMapping);
    return AltMappings;
  }
  default:
    break;
  }
  return AIEBaseRegisterBankInfo::getInstrAlternativeMappings(MI);
}

void AIE1RegisterBankInfo::applyMappingImpl(
    MachineIRBuilder &Builder, const OperandsMapper &OpdMapper) const {
  switch (OpdMapper.getMI().getOpcode()) {
  case TargetOpcode::G_ZEXT:
    // Those ID must match getInstrAlternativeMappings.
    assert((OpdMapper.getInstrMapping().getID() >= 1 &&
            OpdMapper.getInstrMapping().getID() <= 2) &&
           "Don't know how to handle that ID");
    return applyDefaultMapping(OpdMapper);
  default:
    break;
  }
  AIEBaseRegisterBankInfo::applyMappingImpl(Builder, OpdMapper);
}

const RegisterBankInfo::InstructionMapping &
AIE1RegisterBankInfo::getInstrMapping(const MachineInstr &MI) const {
  const unsigned Opc = MI.getOpcode();

  const MachineFunction &MF = *MI.getParent()->getParent();
  const MachineRegisterInfo &MRI = MF.getRegInfo();

  switch (Opc) {
  case TargetOpcode::G_ZEXT: {
    assert(MRI.getType(MI.getOperand(0).getReg()) == LLT::scalar(32) &&
           MRI.getType(MI.getOperand(1).getReg()) == LLT::scalar(20) &&
           "Expected to see only 20-to-32 bit extensions");
    return getInstructionMapping(DefaultMappingID, 1,
                                 getValueMapping(PMI_GPR, 32), 2);
  }
  case TargetOpcode::G_PTR_ADD: {
    // We cannot move immediates in pointer registers, so we use GPRs for
    // pointer arithmetics in AIE1.
    return getInstructionMapping(1, 1, getValueMapping(PMI_GPR, 32), 3);
  }
  case TargetOpcode::G_CONSTANT: {
    LLT Ty = MRI.getType(MI.getOperand(0).getReg());
    if (Ty.isPointer())
      return getInstructionMapping(
          DefaultMappingID, 1,
          getOperandsMapping({getValueMapping(PMI_PTR, 20), nullptr}), 2);
    else
      return getInstructionMapping(
          DefaultMappingID, 1,
          getOperandsMapping(
              {getValueMapping(PMI_GPR, Ty.getScalarSizeInBits()), nullptr}),
          2);
  }
  case TargetOpcode::G_TRUNC: {
    assert(MRI.getType(MI.getOperand(0).getReg()) == LLT::scalar(20) &&
           MRI.getType(MI.getOperand(1).getReg()) == LLT::scalar(32) &&
           "Expected to see only 32 to 20 bit truncations");
    [[fallthrough]];
  }
  default:
    break;
  }

  return AIEBaseRegisterBankInfo::getInstrMapping(MI);
}

void AIE1RegisterBankInfo::setAIEGenericInstrMapping(
    const MachineInstr &MI, SmallVector<unsigned, 4> &OpSize,
    SmallVector<PartialMappingIdx, 4> &OpRegBankIdx) const {
  switch (MI.getOpcode()) {
  case AIE::G_AIE_OFFSET_STORE:
  case AIE::G_AIE_OFFSET_LOAD:
  case AIE::G_AIE_OFFSET_ZEXTLOAD:
  case AIE::G_AIE_OFFSET_SEXTLOAD:
  case AIE::G_AIE_POSTINC_STORE:
  case AIE::G_AIE_POSTINC_LOAD:
  case AIE::G_AIE_POSTINC_ZEXTLOAD:
  case AIE::G_AIE_POSTINC_SEXTLOAD:
    llvm_unreachable("AIE1 does not combine Loads and store (yet?)");
  }
}

const RegisterBank &
AIE1RegisterBankInfo::getRegBankFromRegClass(const TargetRegisterClass &RC,
                                             LLT) const {
  switch (RC.getID()) {
  case AIE::GPRRegClassID:
  case AIE::GPR0_7RegClassID:
  case AIE::GPR0RegClassID:
  case AIE::GPR1RegClassID:
  case AIE::mRCmRegClassID:
  case AIE::mMv0Cg20RegClassID:
  case AIE::mMvSclRegClassID:
  case AIE::mAluCg12RegClassID:
  case AIE::mLdbSclRegClassID:
  // SPR_and_SP_onlyRegClass is mapped to GPR and not PTR because the ISA does
  // not allow copying special registers like $sp to PTR directly.
  case AIE::SPR_and_SP_onlyRegClassID:
    return getRegBank(AIE::GPRRegBankID);
  case AIE::mSclSt_PTRRegClassID:
  case AIE::PTRMODCSCBRegClassID:
  case AIE::PTRRegClassID:
  case AIE::GPRPTRMOD_and_PTRRegClassID:
    return getRegBank(AIE::PTRRegBankID);
  case AIE::MODRegClassID:
  case AIE::GPRPTRMOD_and_MODRegClassID:
    return getRegBank(AIE::MODRegBankID);
  case AIE::mCBRegClassID:
  case AIE::mAluCg12_and_mCSRegClassID:
    return getRegBank(AIE::CBRegBankID);
  default:
    dbgs() << "ID: " << RC.getID() << "\n";
    llvm_unreachable("Register class not supported");
  }
}
