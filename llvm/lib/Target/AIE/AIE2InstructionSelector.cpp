//===- AIE2InstructionSelector.cpp ---------------------------------------===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// AIEngine V2.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "AIE2RegisterBankInfo.h"
#include "AIE2RegisterInfo.h"
#include "AIE2TargetMachine.h"
#include "AIECombinerHelper.h"
#include "AIEMachineFunctionInfo.h"
#include "InstPrinter/AIE2InstPrinter.h"
#include "MCTargetDesc/AIE2MCTargetDesc.h"
#include "llvm/ADT/APInt.h"
#include "llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h"
#include "llvm/CodeGen/GlobalISel/GenericMachineInstrs.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/MIPatternMatch.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"
#include "llvm/CodeGen/GlobalISel/Utils.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstr.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineJumpTableInfo.h"
#include "llvm/CodeGen/MachineMemOperand.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/Register.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/CodeGen/TargetRegisterInfo.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/IntrinsicsAIE.h"
#include "llvm/IR/IntrinsicsAIE2.h"
#include "llvm/MC/MCContext.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/TypeSize.h"
#include <optional>
#include <utility>

#define DEBUG_TYPE "aie2-isel"

using namespace llvm;
using namespace MIPatternMatch;

namespace {

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "AIE2GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

/// Hold the information needed to instruction select memory operations.
struct AddressingModeInfo {
  MachineInstr &MemI;
  MachineOperand &SrcDstOp;
  MachineOperand &PtrOp;
  std::optional<Register> OffsetReg;
  std::optional<APInt> ImmediateOffset;
};

/// Hold the information needed to select instructions that deal with multiple
/// addressing modes and might need to be split
struct LoadStoreOpcodes {
  // The main Opcode with the correct addressing mode
  unsigned ISelOpcode;
  // Indicates whether the provided immediate offset fits in the immedate range
  // of the selected instruction
  bool FitsImmediateRange;
  // Opcode with an immediate indexed addressing mode to split larger loads and
  // stores into smaller ones
  // E.g. Instruction selection for $x0, $p0 = G_AIE_POSTINC_LOAD $p0, #128:
  // $wh0 = VLDA_dmw_lda_w_ag_idx_imm $p0, #32
  // $wl0, $p0 = VLDA_dmw_lda_w_ag_pstm_nrm_imm $p0, #128
  std::optional<unsigned> OffsetOpcode;
};

/// Create a memory operand representing Tile Memory
/// \param I Instruction to build it for
/// \param Mode Store or Load
/// \return The machine memory operand
MachineMemOperand *getTileMemOperand(MachineInstr &I,
                                     MachineMemOperand::Flags Mode) {
  MachineFunction *MF = I.getMF();
  const auto *MFI = MF->getInfo<AIEMachineFunctionInfo>();
  MachinePointerInfo PtrInfo = MachinePointerInfo(MFI->getTileMemory());
  return MF->getMachineMemOperand(PtrInfo, Mode, 4, Align(4));
}

class AIE2InstructionSelector : public InstructionSelector {
public:
  AIE2InstructionSelector(const AIE2TargetMachine &TM, const AIE2Subtarget &STI,
                          const AIE2RegisterBankInfo &RBI);
  /// Split the memory operand from I by the factor defined in SplitFactor, add
  /// the Offset and add the new memory operands to Higher and Lower.
  void addSplitMemOperands(MachineInstr &I, MachineInstrBuilder &Higher,
                           MachineInstrBuilder &Lower, unsigned Offset,
                           unsigned SplitFactor);
  /// Given the AddressingModeInfo, FitsImmediateRange and whether the
  /// instruction supports frame index rendering add the correct operands to MIB
  void addAddressingMode(MachineInstrBuilder &MIB, AddressingModeInfo &AMI,
                         bool FitsImmediateRange, bool RenderFrameIndex,
                         MachineRegisterInfo &MRI);

  Register createDRegSequence(Register ModifierReg, Register IncrReg,
                              Register SizeReg, Register CountReg,
                              MachineRegisterInfo &MRI);
  Register createDSRegSequence(Register ModifierReg, Register Incr1Reg,
                               Register Incr2Reg, Register Size1Reg,
                               Register Count1Reg, Register Size2Reg,
                               Register Count2Reg, MachineRegisterInfo &MRI);
  Register createSparseRegSequence(Register Vec, Register Mask,
                                   MachineRegisterInfo &MRI);
  void insertPtrAddForOffset(MachineRegisterInfo &MRI, MachineInstr &MemI);
  bool selectCopy(MachineInstr &I, MachineRegisterInfo &MRI);
  /// set \a CRReg based on \a ValueReg before \a I and set \a CRReg based on \a
  /// DefaultCRVal after \a I.
  void setUnsetCtrlRegister(MachineInstr &I, MachineRegisterInfo &MRI,
                            Register CRReg, Register ValueReg,
                            unsigned DefaultCRVal = 0);
  void setUnsetCtrlRegister(MachineInstr &I, MachineInstr &EndI,
                            MachineRegisterInfo &MRI, Register CRReg,
                            Register ValueReg, unsigned DefaultCRVal = 0);
  void setCtrlRegister(MachineInstr &I, MachineRegisterInfo &MRI,
                       Register CRReg, Register ValueReg);
  /// \return AIE2 OpCode based on \a IntrinsicID
  unsigned getOpCode(Intrinsic::ID IntrinsicID);

  /// Select into a REG_SEQUENCE instruction of two 32-bit R registers to
  /// one 64-bit L register.
  bool selectLRegSequence(MachineInstr &I, MachineRegisterInfo &MRI);

  bool select(MachineInstr &I) override;
  bool selectAddrInsn(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectCascadeStreamInsn(MachineInstr &I, MachineRegisterInfo &MRI,
                               bool isWrite);
  bool selectG_AIE_ADD_VECTOR_ELT_HI(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_BRCOND(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_BRINDIRECT(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_JUMP_TABLE(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_CONSTANT(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_GLOBAL_VALUE(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_IMPLICIT_DEF(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_LOAD(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_PHI(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_PTR_ADD(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_SEXT_INREG(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_STORE(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_UNMERGE_VALUES(MachineInstr &MI, MachineRegisterInfo &MRI);
  bool selectGetControlRegister(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectGetCoreID(MachineInstr &MI, MachineRegisterInfo &MRI);
  bool selectReadTM(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectSetControlRegister(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVMAXDIFF_LT(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVABS_GTZ(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVSUB_LTGE(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVEXTRACT(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVCompare(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVSRS(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVSUB_MIN_MAX(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVUNPACK(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVPACK(MachineInstr &I, MachineRegisterInfo &MRI);
  std::optional<AddressingModeInfo>
  getOrDefineAddressingRegister(MachineInstr &MemI, MachineRegisterInfo &MRI);
  bool selectG_AIE_LOAD_UNPACK(MachineInstr &StoreI, MachineRegisterInfo &MRI);
  bool selectG_AIE_LOAD_UPS(MachineInstr &StoreI, MachineRegisterInfo &MRI);
  bool select512BitG_AIE_LOAD_UPS(MachineInstr &UPSI, LoadStoreOpcodes &LSO,
                                  AddressingModeInfo &AMI, Register DstReg,
                                  Register ShftReg, Register SignReg,
                                  bool ConstantSign, MachineRegisterInfo &MRI);
  bool selectVUPS(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVCONV(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectWriteTM(MachineInstr &I, MachineRegisterInfo &MRI);
  LoadStoreOpcodes getLoadStoreOpcode(const MachineInstr &I,
                                      const MachineRegisterInfo &MRI,
                                      const RegisterBankInfo &RBI,
                                      std::optional<APInt> Offset);
  bool selectG_AIE_LOAD_STORE(MachineInstr &I, MachineRegisterInfo &MRI);
  bool select512BitG_AIE_LOAD_STORE(MachineInstr &I, LoadStoreOpcodes &LSO,
                                    AddressingModeInfo &AMI,
                                    MachineRegisterInfo &MRI);
  bool selectG_AIE_STORE_SRS(MachineInstr &StoreI, MachineRegisterInfo &MRI);
  bool select512BitG_AIE_STORE_SRS(LoadStoreOpcodes &LSO,
                                   AddressingModeInfo &AMI, Register SrcReg,
                                   Register ShftReg, Register SignReg,
                                   bool ConstantSign, MachineRegisterInfo &MRI);
  bool selectG_AIE_STORE_CONV(MachineInstr &StoreI, MachineRegisterInfo &MRI);
  bool selectG_AIE_LOAD_CONV(MachineInstr &StoreI, MachineRegisterInfo &MRI);
  bool selectG_AIE_STORE_PACK(MachineInstr &StoreI, MachineRegisterInfo &MRI);
  bool selectStartLoop(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_AIE_EXTRACT_VECTOR_ELT(MachineInstr &I,
                                      MachineRegisterInfo &MRI);
  bool selectG_AIE_INSERT_VECTOR_ELT(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectSetI128(MachineInstr &I, MachineOperand &DstReg,
                     MachineOperand &SrcReg, MachineRegisterInfo &MRI);
  bool selectExtractI128(MachineInstr &I, Register DstReg, Register SrcReg,
                         MachineRegisterInfo &MRI);
  bool selectGetSS(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectPutMSB(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectPutMSNB(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVLDSparseOP_Pseudo(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectVLDSparseINIT_Pseudo(MachineInstr &I, MachineRegisterInfo &MRI);
  // Select a packet header stream write instruction from the corresponding
  // intrinsic.
  bool selectPutMS_PH(MachineInstr &I, MachineRegisterInfo &MRI);
  // Select a control packet header stream write instruction from the
  // corresponding intrinsic.
  bool selectPutMS_CPH(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectBrCondLoopDecrement(MachineInstr &BrCond,
                                 MachineRegisterInfo &MRI);

  static const char *getName() { return DEBUG_TYPE; }

  void setupMF(MachineFunction &MF, GISelKnownBits *KB,
               CodeGenCoverage *CoverageInfo, ProfileSummaryInfo *PSI,
               BlockFrequencyInfo *BFI) override {
    InstructionSelector::setupMF(MF, KB, CoverageInfo, PSI, BFI);
    MIB.setMF(MF);
  }

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
  void makeDeadMI(MachineInstr &MI, MachineRegisterInfo &MRI);
  void renderFrameIndex(MachineInstrBuilder &MIB, const MachineInstr &MI,
                        int OpIdx) const;
  void renderNegateImm(MachineInstrBuilder &MIB, const MachineInstr &MI,
                       int OpIdx) const;

  // const AIE2TargetMachine &TM;
  const AIE2InstrInfo &TII;
  const AIE2RegisterInfo &TRI;
  const AIE2RegisterBankInfo &RBI;

  MachineIRBuilder MIB;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "AIE2GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "AIE2GenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "AIE2GenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

AIE2InstructionSelector::AIE2InstructionSelector(
    const AIE2TargetMachine &TM, const AIE2Subtarget &STI,
    const AIE2RegisterBankInfo &RBI)
    : InstructionSelector(), /*TM(TM),*/ TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "AIE2GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "AIE2GenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

void AIE2InstructionSelector::renderFrameIndex(MachineInstrBuilder &MIB,
                                               const MachineInstr &MI,
                                               int OpIdx) const {
  MIB.addFrameIndex((MI.getOperand(1).getIndex()));
}

void AIE2InstructionSelector::renderNegateImm(MachineInstrBuilder &MIB,
                                              const MachineInstr &MI,
                                              int OpIdx) const {
  assert(MI.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  MIB.addImm(-MI.getOperand(1).getCImm()->getSExtValue());
}

void AIE2InstructionSelector::addSplitMemOperands(MachineInstr &I,
                                                  MachineInstrBuilder &Higher,
                                                  MachineInstrBuilder &Lower,
                                                  unsigned Offset,
                                                  unsigned SplitFactor) {
  const MachineMemOperand *MMO =
      I.memoperands().size() == 1 ? *(I.memoperands().begin()) : nullptr;
  if (MMO) {
    llvm::LLT OrgType = MMO->getType();
    unsigned SplitElemCount = OrgType.getNumElements() / SplitFactor;
    unsigned ScalarSize = OrgType.getScalarType().getScalarSizeInBits();
    LLT PartType = LLT::fixed_vector(SplitElemCount, ScalarSize);
    Higher.addMemOperand(MF->getMachineMemOperand(
        MMO, Offset + ((SplitElemCount * ScalarSize) / 8), PartType));
    Lower.addMemOperand(MF->getMachineMemOperand(MMO, Offset + 0, PartType));
  }
}

bool AIE2InstructionSelector::selectCopy(MachineInstr &I,
                                         MachineRegisterInfo &MRI) {

  Register DstReg = I.getOperand(0).getReg();
  if (DstReg.isPhysical())
    return true;

  const TargetRegisterClass *RC = nullptr;
  const RegClassOrRegBank &RCB = MRI.getRegClassOrRegBank(DstReg);
  if (const RegisterBank *RB = RCB.dyn_cast<const RegisterBank *>())
    RC = &TRI.getMinClassForRegBank(*RB, MRI.getType(DstReg));
  if (auto *TRC = RCB.dyn_cast<const TargetRegisterClass *>())
    RC = TRC;
  assert(RC != nullptr && "RC cannot be null");

  // No need to constrain SrcReg. It will get constrained when
  // we hit another of its uses or its defs.
  // Copies do not have constraints.
  if (!RBI.constrainGenericRegister(DstReg, *RC, MRI)) {
    LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                      << " operand\n");
    return false;
  }

  return true;
}

void AIE2InstructionSelector::setUnsetCtrlRegister(
    MachineInstr &I, MachineInstr &EndI, MachineRegisterInfo &MRI,
    Register CRReg, Register ValueReg, unsigned DefaultCRVal) {
  // Set the crReg based on ValueReg parameter before I
  MIB.setInstr(I);
  if (auto Val = getIConstantVRegValWithLookThrough(ValueReg, MRI)) {
    unsigned ConstCRVal = Val->Value.getZExtValue();
    if (ConstCRVal == DefaultCRVal)
      return;
    MIB.buildInstr(AIE2::MOV_scalar_imm10_pseudo, {CRReg}, {})
        .addImm(ConstCRVal);
  } else {
    auto CopyInstr =
        MIB.buildInstr(TargetOpcode::COPY, {CRReg}, {}).addReg(ValueReg);
    if (!selectCopy(*CopyInstr, MRI)) {
      dbgs() << "Failed to set and unset control register for: " << I << "\n";
      llvm_unreachable("Failed to set and unset control register");
    }
  }
  // Set the crReg based on DefaultCRVal after I
  MIB.setInstr(*EndI.getNextNode());
  MIB.buildInstr(AIE2::MOV_scalar_imm10_pseudo, {CRReg}, {})
      .addImm(DefaultCRVal);
}

void AIE2InstructionSelector::setUnsetCtrlRegister(MachineInstr &I,
                                                   MachineRegisterInfo &MRI,
                                                   Register CRReg,
                                                   Register ValueReg,
                                                   unsigned DefaultCRVal) {
  setUnsetCtrlRegister(I, I, MRI, CRReg, ValueReg, DefaultCRVal);
}

unsigned AIE2InstructionSelector::getOpCode(Intrinsic::ID IntrinsicID) {
  switch (IntrinsicID) {
  /* To derive instruction from UPS intrinsic follow
   the e.g. Intrinsic : aie2_acc32_v16_I256_ups
    1. I256_v16 : Using following two things
    -> a. Element size (256/16) = 16 = D16
    -> b. Move src type { I256 = _w2*, I512 = _x2* }
    2. acc32 / acc64 : maps to S32 or S64
   Instruction : VUPS_S32_D16_mv_ups_w2b
  */
  case Intrinsic::aie2_acc32_v16_I256_ups:
    return AIE2::VUPS_S32_D16_mv_ups_w2b;
  case Intrinsic::aie2_acc32_v32_I256_ups:
    return AIE2::VUPS_S32_D8_mv_ups_w2c;
  case Intrinsic::aie2_acc32_v32_I512_ups:
    return AIE2::VUPS_S32_D16_mv_ups_x2c;
  case Intrinsic::aie2_acc64_v16_I256_ups:
    return AIE2::VUPS_S64_D16_mv_ups_w2c;
  case Intrinsic::aie2_acc64_v16_I512_ups:
    return AIE2::VUPS_S64_D32_mv_ups_x2c;
  case Intrinsic::aie2_acc64_v8_I256_ups:
    return AIE2::VUPS_S64_D32_mv_ups_w2b;
  /* To derive instruction from SRS intrinsic follow
   the e.g. Intrinsic : aie2_I256_v16_acc32_srs
    1. I256_v16 : Using following two things
    -> a. Element size (256/16) = 16 = D16
    -> b. Move Instr type { I256 = mv_w , I512 = mv_x }
    2. acc32 / acc64 : maps to S32 or S64
   Instruction : VSRS_D16_S32_mv_w_srs
  */
  case Intrinsic::aie2_I256_v16_acc32_srs:
    return AIE2::VSRS_D16_S32_mv_w_srs;
  case Intrinsic::aie2_I256_v16_acc64_srs:
    return AIE2::VSRS_D16_S64_mv_w_srs;
  case Intrinsic::aie2_I256_v32_acc32_srs:
    return AIE2::VSRS_D8_S32_mv_w_srs;
  case Intrinsic::aie2_I256_v8_acc64_srs:
    return AIE2::VSRS_D32_S64_mv_w_srs;
  case Intrinsic::aie2_I512_v16_acc64_srs:
    return AIE2::VSRS_D32_S64_mv_x_srs;
  case Intrinsic::aie2_I512_v32_acc32_srs:
    return AIE2::VSRS_D16_S32_mv_x_srs;
  // Extract Intrinsic
  case Intrinsic::aie2_vextract_elem8_I512:
    return AIE2::VEXTRACT_D8;
  case Intrinsic::aie2_vextract_elem16_I512:
    return AIE2::VEXTRACT_D16;
  case Intrinsic::aie2_vextract_elem32_I512:
    return AIE2::VEXTRACT_D32;
  case Intrinsic::aie2_vextract_elem64_I512:
    return AIE2::VEXTRACT_D64;
  // Vmax Intrinsic
  case Intrinsic::aie2_vmax_lt8:
    return AIE2::VMAX_LT_D8;
  case Intrinsic::aie2_vmax_lt16:
    return AIE2::VMAX_LT_D16;
  case Intrinsic::aie2_vmax_lt32:
    return AIE2::VMAX_LT_D32;
  // Vmin Intrinsic
  case Intrinsic::aie2_vmin_ge8:
    return AIE2::VMIN_GE_D8;
  case Intrinsic::aie2_vmin_ge16:
    return AIE2::VMIN_GE_D16;
  case Intrinsic::aie2_vmin_ge32:
    return AIE2::VMIN_GE_D32;
  // VGE / VLT
  case Intrinsic::aie2_vlt8:
    return AIE2::VLT_D8;
  case Intrinsic::aie2_vlt16:
    return AIE2::VLT_D16;
  case Intrinsic::aie2_vlt32:
    return AIE2::VLT_D32;
  case Intrinsic::aie2_vge8:
    return AIE2::VGE_D8;
  case Intrinsic::aie2_vge16:
    return AIE2::VGE_D16;
  case Intrinsic::aie2_vge32:
    return AIE2::VGE_D32;
  // VMOV - Cascade stream read access
  case Intrinsic::aie2_scd_read_vec:
  case Intrinsic::aie2_scd_read_acc32:
    return AIE2::VMOV_mv_scd;
  case Intrinsic::aie2_scd_expand_lo:
    return AIE2::VMOV_LO;
  case Intrinsic::aie2_scd_expand_hi:
    return AIE2::VMOV_HI;
  // VMOV - Cascade stream write access
  case Intrinsic::aie2_mcd_write_vec:
  case Intrinsic::aie2_mcd_write_acc32:
    return AIE2::VMOV_mv_mcd;
  // VMAXDIFF_LT
  case Intrinsic::aie2_vmaxdiff_lt8:
    return AIE2::VMAXDIFF_LT_D8;
  case Intrinsic::aie2_vmaxdiff_lt16:
    return AIE2::VMAXDIFF_LT_D16;
  case Intrinsic::aie2_vmaxdiff_lt32:
    return AIE2::VMAXDIFF_LT_D32;
  // VABS_GTZ
  case Intrinsic::aie2_vabs_gtz8:
    return AIE2::VABS_GTZ_D8;
  case Intrinsic::aie2_vabs_gtz16:
    return AIE2::VABS_GTZ_D16;
  case Intrinsic::aie2_vabs_gtz32:
    return AIE2::VABS_GTZ_D32;
  // VSUB_LT/VSUB_GE
  case Intrinsic::aie2_vsub_lt8:
    return AIE2::VSUB_LT_D8;
  case Intrinsic::aie2_vsub_lt16:
    return AIE2::VSUB_LT_D16;
  case Intrinsic::aie2_vsub_lt32:
    return AIE2::VSUB_LT_D32;
  case Intrinsic::aie2_vsub_ge8:
    return AIE2::VSUB_GE_D8;
  case Intrinsic::aie2_vsub_ge16:
    return AIE2::VSUB_GE_D16;
  case Intrinsic::aie2_vsub_ge32:
    return AIE2::VSUB_GE_D32;
  // Streams
  case Intrinsic::aie2_get_ss:
    return AIE2::MOV_mv_ss2scl;
  case Intrinsic::aie2_get_ss_nb:
    return AIE2::MOV_NB_mv_ss2scl;
  default:
    llvm_unreachable("Unexpected Intrinsic ID");
  }
}

bool AIE2InstructionSelector::select(MachineInstr &I) {

  MachineFunction &MF = *I.getParent()->getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  if (!I.isPreISelOpcode()) {

    if (I.isCopy())
      return selectCopy(I, MRI);
    return true;
  }
  MIB.setInstrAndDebugLoc(I);
  using namespace TargetOpcode;

  switch (I.getOpcode()) {
  case G_FREEZE:
  case G_PTRTOINT:
  case G_INTTOPTR:
  case G_ZEXT:
  case G_ANYEXT:
  case G_BITCAST:
    I.setDesc(TII.get(COPY));
    return selectCopy(I, MRI);
  case G_TRUNC: {
    Register SrcReg = I.getOperand(1).getReg();
    LLT SrcTy = MRI.getType(SrcReg);
    unsigned Size = SrcTy.getSizeInBits();
    // G_TRUNC S32 <- S64
    if (Size == 64) {
      Register DstReg = I.getOperand(0).getReg();
      MachineInstrBuilder MI = MIB.buildInstr(TargetOpcode::COPY, {DstReg}, {})
                                   .addReg(SrcReg, 0, AIE2::sub_l_even);
      I.eraseFromParent();
      return selectCopy(*MI.getInstr(), MRI);
    } else {
      I.setDesc(TII.get(COPY));
      return selectCopy(I, MRI);
    }
  }
  case G_SEXT_INREG:
    return selectG_SEXT_INREG(I, MRI);
  case G_BRCOND:
    return selectG_BRCOND(I, MRI);
  case G_BRINDIRECT:
    return selectG_BRINDIRECT(I, MRI);
  case G_JUMP_TABLE:
    return selectG_JUMP_TABLE(I, MRI);
  case G_CONSTANT:
    return selectG_CONSTANT(I, MRI);
  case G_GLOBAL_VALUE:
    return selectG_GLOBAL_VALUE(I, MRI);
  case G_IMPLICIT_DEF:
    return selectG_IMPLICIT_DEF(I, MRI);
  case G_INTRINSIC:
    switch (cast<GIntrinsic>(I).getIntrinsicID()) {
    case Intrinsic::aie2_v16int8:
    case Intrinsic::aie2_v32int8:
    case Intrinsic::aie2_v64int8:
    case Intrinsic::aie2_v128int8:
    case Intrinsic::aie2_v8int16:
    case Intrinsic::aie2_v16int16:
    case Intrinsic::aie2_v32int16:
    case Intrinsic::aie2_v64int16:
    case Intrinsic::aie2_v4int32:
    case Intrinsic::aie2_v8int32:
    case Intrinsic::aie2_v16int32:
    case Intrinsic::aie2_v32int32:
    case Intrinsic::aie2_v4acc64:
    case Intrinsic::aie2_v8acc64:
    case Intrinsic::aie2_v16acc64:
    case Intrinsic::aie2_v8acc32:
    case Intrinsic::aie2_v16acc32:
    case Intrinsic::aie2_v32acc32:
    case Intrinsic::aie2_v8bfloat16:
    case Intrinsic::aie2_v16bfloat16:
    case Intrinsic::aie2_v32bfloat16:
    case Intrinsic::aie2_v64bfloat16:
    case Intrinsic::aie2_v8accfloat:
    case Intrinsic::aie2_v16accfloat:
    case Intrinsic::aie2_v32accfloat:
    case Intrinsic::aie2_v8float:
    case Intrinsic::aie2_v16float:
    case Intrinsic::aie2_v32float:
      return selectG_IMPLICIT_DEF(I, MRI);
    case Intrinsic::aie2_vmaxdiff_lt8:
    case Intrinsic::aie2_vmaxdiff_lt16:
    case Intrinsic::aie2_vmaxdiff_lt32:
      return selectVMAXDIFF_LT(I, MRI);
    case Intrinsic::aie2_vabs_gtz8:
    case Intrinsic::aie2_vabs_gtz16:
    case Intrinsic::aie2_vabs_gtz32:
      return selectVABS_GTZ(I, MRI);
    case Intrinsic::aie2_vsub_lt8:
    case Intrinsic::aie2_vsub_lt16:
    case Intrinsic::aie2_vsub_lt32:
    case Intrinsic::aie2_vsub_ge8:
    case Intrinsic::aie2_vsub_ge16:
    case Intrinsic::aie2_vsub_ge32:
      return selectVSUB_LTGE(I, MRI);
    case Intrinsic::aie2_unpack_I8_I4:
    case Intrinsic::aie2_unpack_I16_I8:
      return selectVUNPACK(I, MRI);
    case Intrinsic::aie2_v16bf16_to_v16accfloat:
      return selectVCONV(I, MRI);
    case Intrinsic::aie2_vextract_elem8_I512:
    case Intrinsic::aie2_vextract_elem16_I512:
    case Intrinsic::aie2_vextract_elem32_I512:
    case Intrinsic::aie2_vextract_elem64_I512:
      return selectVEXTRACT(I, MRI);
    case Intrinsic::aie2_vge8:
    case Intrinsic::aie2_vge16:
    case Intrinsic::aie2_vge32:
    case Intrinsic::aie2_vlt8:
    case Intrinsic::aie2_vlt16:
    case Intrinsic::aie2_vlt32:
      return selectVCompare(I, MRI);
    case Intrinsic::aie2_vmax_lt8:
    case Intrinsic::aie2_vmax_lt16:
    case Intrinsic::aie2_vmax_lt32:
    case Intrinsic::aie2_vmin_ge8:
    case Intrinsic::aie2_vmin_ge16:
    case Intrinsic::aie2_vmin_ge32:
      return selectVSUB_MIN_MAX(I, MRI);
    case Intrinsic::aie2_add_2d:
    case Intrinsic::aie2_add_3d:
      return selectAddrInsn(I, MRI);
    case Intrinsic::aie2_get_coreid:
      return selectGetCoreID(I, MRI);

    case Intrinsic::aie2_extract_I128_I512:
      return selectExtractI128(I, I.getOperand(0).getReg(),
                               I.getOperand(2).getReg(), MRI);
    case Intrinsic::aie2_get_I256_I128:
    case Intrinsic::aie2_set_I512_I128:
      return selectSetI128(I, I.getOperand(0), I.getOperand(2), MRI);
    default:
      return selectImpl(I, *CoverageInfo);
    }
  case G_INTRINSIC_W_SIDE_EFFECTS:
    switch (cast<GIntrinsic>(I).getIntrinsicID()) {
    case Intrinsic::aie2_set_ctrl_reg:
      return selectSetControlRegister(I, MRI);
    case Intrinsic::aie2_get_ctrl_reg:
      return selectGetControlRegister(I, MRI);
    case Intrinsic::aie2_pack_I4_I8:
    case Intrinsic::aie2_pack_I8_I16:
      return selectVPACK(I, MRI);
    case Intrinsic::aie2_I256_v16_acc32_srs:
    case Intrinsic::aie2_I256_v16_acc64_srs:
    case Intrinsic::aie2_I256_v32_acc32_srs:
    case Intrinsic::aie2_I256_v8_acc64_srs:
    case Intrinsic::aie2_I512_v16_acc64_srs:
    case Intrinsic::aie2_I512_v32_acc32_srs:
      return selectVSRS(I, MRI);
    case Intrinsic::aie2_acc32_v16_I256_ups:
    case Intrinsic::aie2_acc32_v32_I256_ups:
    case Intrinsic::aie2_acc32_v32_I512_ups:
    case Intrinsic::aie2_acc64_v16_I256_ups:
    case Intrinsic::aie2_acc64_v16_I512_ups:
    case Intrinsic::aie2_acc64_v8_I256_ups:
      return selectVUPS(I, MRI);
    case Intrinsic::start_loop_iterations:
      return selectStartLoop(I, MRI);
    case Intrinsic::set_loop_iterations: {
      auto LS =
          MIB.buildInstr(AIE2::LoopStart, {}, {I.getOperand(1)}).addImm(0);
      I.eraseFromParent();
      return constrainSelectedInstRegOperands(*LS, TII, TRI, RBI);
    }
    case Intrinsic::aie2_scd_read_vec:
    case Intrinsic::aie2_scd_read_acc32:
    case Intrinsic::aie2_scd_expand_lo:
    case Intrinsic::aie2_scd_expand_hi:
      return selectCascadeStreamInsn(I, MRI, 0);
    case Intrinsic::aie2_mcd_write_vec:
    case Intrinsic::aie2_mcd_write_acc32:
      return selectCascadeStreamInsn(I, MRI, 1);
    case Intrinsic::aie2_write_tm:
      return selectWriteTM(I, MRI);
    case Intrinsic::aie2_read_tm:
      return selectReadTM(I, MRI);
    case Intrinsic::aie2_get_ss:
    case Intrinsic::aie2_get_ss_nb:
      return selectGetSS(I, MRI);
    case Intrinsic::aie2_put_ms:
      return selectPutMSB(I, MRI);
    case Intrinsic::aie2_put_ms_nb:
      return selectPutMSNB(I, MRI);
    case Intrinsic::aie2_sparse_pop_16_and_get_pointer:
    case Intrinsic::aie2_sparse_pop_16_set_lo:
    case Intrinsic::aie2_sparse_pop_16_insert_hi:
    case Intrinsic::aie2_sparse_peek_16_and_get_pointer:
    case Intrinsic::aie2_sparse_peek_16_set_lo:
    case Intrinsic::aie2_sparse_peek_16_insert_hi:
    case Intrinsic::aie2_sparse_pop_16_bfloat_and_get_pointer:
    case Intrinsic::aie2_sparse_pop_16_bfloat_set_lo:
    case Intrinsic::aie2_sparse_pop_16_bfloat_insert_hi:
    case Intrinsic::aie2_sparse_peek_16_bfloat_and_get_pointer:
    case Intrinsic::aie2_sparse_peek_16_bfloat_set_lo:
    case Intrinsic::aie2_sparse_peek_16_bfloat_insert_hi:
    case Intrinsic::aie2_sparse_pop_8_and_get_pointer:
    case Intrinsic::aie2_sparse_pop_8_set_lo:
    case Intrinsic::aie2_sparse_pop_8_insert_hi:
    case Intrinsic::aie2_sparse_peek_8_and_get_pointer:
    case Intrinsic::aie2_sparse_peek_8_set_lo:
    case Intrinsic::aie2_sparse_peek_8_insert_hi:
    case Intrinsic::aie2_sparse_pop_4_and_get_pointer:
    case Intrinsic::aie2_sparse_pop_4_set_lo:
    case Intrinsic::aie2_sparse_pop_4_insert_hi:
    case Intrinsic::aie2_sparse_peek_4_and_get_pointer:
    case Intrinsic::aie2_sparse_peek_4_set_lo:
    case Intrinsic::aie2_sparse_peek_4_insert_hi:
      return selectVLDSparseOP_Pseudo(I, MRI);
    case Intrinsic::aie2_sparse_reset_16_and_get_pointer:
    case Intrinsic::aie2_sparse_reset_16:
    case Intrinsic::aie2_sparse_fill_16_and_get_pointer:
    case Intrinsic::aie2_sparse_fill_16:
    case Intrinsic::aie2_sparse_reset_8_and_get_pointer:
    case Intrinsic::aie2_sparse_reset_8:
    case Intrinsic::aie2_sparse_fill_8_and_get_pointer:
    case Intrinsic::aie2_sparse_fill_8:
    case Intrinsic::aie2_sparse_reset_4_and_get_pointer:
    case Intrinsic::aie2_sparse_reset_4:
    case Intrinsic::aie2_sparse_fill_4_and_get_pointer:
    case Intrinsic::aie2_sparse_fill_4:
      return selectVLDSparseINIT_Pseudo(I, MRI);
    case Intrinsic::aie2_put_ms_packet_header:
    case Intrinsic::aie2_put_ms_nb_packet_header:
      return selectPutMS_PH(I, MRI);
    case Intrinsic::aie2_put_ms_ctrl_packet_header:
    case Intrinsic::aie2_put_ms_nb_ctrl_packet_header:
      return selectPutMS_CPH(I, MRI);
    default:
      return selectImpl(I, *CoverageInfo);
    }
  case G_LOAD:
    return selectG_LOAD(I, MRI);
  case G_MERGE_VALUES:
  case G_BUILD_VECTOR:
    return selectLRegSequence(I, MRI);
  case G_PHI:
    return selectG_PHI(I, MRI);
  case G_PTR_ADD:
    return selectG_PTR_ADD(I, MRI);
  case G_STORE:
    return selectG_STORE(I, MRI);
  case G_UNMERGE_VALUES:
    return selectG_UNMERGE_VALUES(I, MRI);
  case AIE2::G_AIE_ADD_VECTOR_ELT_HI:
    return selectG_AIE_ADD_VECTOR_ELT_HI(I, MRI);
  case AIE2::G_AIE_OFFSET_STORE:
  case AIE2::G_AIE_POSTINC_STORE:
  case AIE2::G_AIE_POSTINC_2D_STORE:
  case AIE2::G_AIE_POSTINC_3D_STORE:
  case AIE2::G_AIE_OFFSET_LOAD:
  case AIE2::G_AIE_POSTINC_LOAD:
  case AIE2::G_AIE_POSTINC_2D_LOAD:
  case AIE2::G_AIE_POSTINC_3D_LOAD:
  case AIE2::G_AIE_OFFSET_SEXTLOAD:
  case AIE2::G_AIE_POSTINC_SEXTLOAD:
  case AIE2::G_AIE_OFFSET_ZEXTLOAD:
  case AIE2::G_AIE_POSTINC_ZEXTLOAD:
  case AIE2::G_AIE_POSTINC_2D_SEXTLOAD:
  case AIE2::G_AIE_POSTINC_2D_ZEXTLOAD:
  case AIE2::G_AIE_POSTINC_3D_SEXTLOAD:
  case AIE2::G_AIE_POSTINC_3D_ZEXTLOAD:
    return selectG_AIE_LOAD_STORE(I, MRI);
  case AIE2::G_AIE_ZEXT_EXTRACT_VECTOR_ELT:
  case AIE2::G_AIE_SEXT_EXTRACT_VECTOR_ELT:
    return selectG_AIE_EXTRACT_VECTOR_ELT(I, MRI);
  case AIE2::G_AIE_INSERT_VECTOR_ELT:
    return selectG_AIE_INSERT_VECTOR_ELT(I, MRI);
  case AIE2::G_AIE_PAD_VECTOR_UNDEF:
    return selectSetI128(I, I.getOperand(0), I.getOperand(1), MRI);
  case AIE2::G_AIE_UNPAD_VECTOR:
    return selectExtractI128(I, I.getOperand(0).getReg(),
                             I.getOperand(1).getReg(), MRI);
  default:
    return selectImpl(I, *CoverageInfo);
  }

  return false;
}

bool AIE2InstructionSelector::selectStartLoop(MachineInstr &I,
                                              MachineRegisterInfo &MRI) {

  assert(I.getOpcode() == TargetOpcode::G_INTRINSIC_W_SIDE_EFFECTS);

  const Register DstReg = I.getOperand(0).getReg();
  // The first argument to start_loop_iterations is the loop trip count.
  // We need to pre-adjust that number to receive the proper backedge-taken
  // count
  if (auto Const =
          getIConstantVRegValWithLookThrough(I.getOperand(2).getReg(), MRI)) {
    auto OpCode = TII.getConstantMovOpcode(MRI, DstReg, Const->Value);
    auto Mov = MIB.buildInstr(OpCode, {DstReg}, {})
                   .addImm(Const->Value.getSExtValue() - 1);
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*Mov, TII, TRI, RBI);
  }

  // Not a constant trip count, decrement at runtime
  auto ADDI = MIB.buildInstr(AIE2::ADD_NC, {I.getOperand(0)}, {I.getOperand(2)})
                  .addImm(-1);
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*ADDI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectG_AIE_ADD_VECTOR_ELT_HI(
    MachineInstr &I, MachineRegisterInfo &MRI) {
  const Register Dst = I.getOperand(0).getReg();
  const Register Src = I.getOperand(1).getReg();
  const Register Value = I.getOperand(2).getReg();
  const LLT VecEltDstTy = MRI.getType(Dst).getElementType();
  const TypeSize VecEltDstTySize = VecEltDstTy.getSizeInBits();

  // We assume that we always receive a vector operand and that the vector types
  // are always true. As of 03/24, this may not be true due to vint64s being
  // used for accumulators instead.
  unsigned Opcode;
  switch (VecEltDstTySize) {
  case 8:
    Opcode = AIE2::VPUSH_LO_8;
    break;
  case 16:
    Opcode = AIE2::VPUSH_LO_16;
    break;
  case 32:
    Opcode = AIE2::VPUSH_LO_32;
    break;
  case 64:
    llvm_unreachable("Unexpected accumulator vector in selection of "
                     "G_AIE_ADD_VECTOR_ELT_HI");
  default:
    llvm_unreachable(
        "Unexpected vector size in selection of G_AIE_ADD_VECTOR_ELT_HI");
  }

  // This is the opposite order from the ISA which expects vector, value. This
  // is choice made in TD which takes it in this opposite order.
  MachineInstr &MI = *MIB.buildInstr(Opcode, {Dst}, {Value, Src});
  I.eraseFromParent();

  return constrainSelectedInstRegOperands(MI, TII, TRI, RBI);
}

// Try to match BRCOND(Intrinsic::loop_decrement)
bool AIE2InstructionSelector::selectBrCondLoopDecrement(
    MachineInstr &BrCond, MachineRegisterInfo &MRI) {

  assert(BrCond.getOpcode() == TargetOpcode::G_BRCOND);
  MachineOperand &MO = BrCond.getOperand(0);
  Register CondReg = MO.getReg();

  // Check if the condition is a LoopDecrement
  auto *LoopDec = getDefIgnoringCopies(CondReg, MRI);
  if (!LoopDec ||
      LoopDec->getOpcode() != TargetOpcode::G_INTRINSIC_W_SIDE_EFFECTS) {
    return false;
  }
  auto *LoopDecIntrinsic = cast<GIntrinsic>(LoopDec);
  if (LoopDecIntrinsic->getIntrinsicID() == Intrinsic::loop_decrement) {
    MachineBasicBlock *DestMBB = BrCond.getOperand(1).getMBB();
    MCContext &Context = BrCond.getParent()->getParent()->getContext();
    MCSymbol *EndLabel = Context.createNamedTempSymbol("_LEnd");
    MIB.buildInstr(AIE2::PseudoLoopEnd).addSym(EndLabel).addMBB(DestMBB);
    makeDeadMI(*LoopDec, MRI);
    BrCond.eraseFromParent();
    return true;
  }
  return false;
}

bool AIE2InstructionSelector::selectG_BRCOND(MachineInstr &I,
                                             MachineRegisterInfo &MRI) {
  Register CondReg = I.getOperand(0).getReg();
  MachineBasicBlock *DestMBB = I.getOperand(1).getMBB();

  const unsigned CondRB = RBI.getRegBank(CondReg, MRI, TRI)->getID();

  // The condition needs to reside in GPRs
  if (CondRB != AIE2::GPRRegBankID)
    return false;

  auto *Cond = getDefIgnoringCopies(CondReg, MRI);

  assert(Cond && "Conditional branch without a condition!?");

  struct JNZDArgs {
    Register NewLC;
    Register PrevLC;
    MachineInstr *IntrinInst;
  };
  // This checks for the following pattern:
  // bb.loop.body:
  //  %newLC:gprregbank(s32) = llvm.loop.decrement.reg, %prevLC(s32), 1
  //  %cond:gprregbank(s32) = G_ICMP intpred(ne), %newLC(s32), 0
  //  G_BRCOND %4(s32), %bb.loop.body
  auto IsJNZDPattern =
      [](const MachineInstr &MI,
         const MachineRegisterInfo &MRI) -> std::optional<JNZDArgs> {
    if (MI.getOpcode() != TargetOpcode::G_ICMP)
      return {};

    const auto &PredOp = MI.getOperand(1);
    const auto Pred = static_cast<CmpInst::Predicate>(PredOp.getPredicate());

    if (Pred != CmpInst::ICMP_NE)
      return {};

    auto CmpRHS =
        getIConstantVRegValWithLookThrough(MI.getOperand(3).getReg(), MRI);
    if (!CmpRHS || CmpRHS->Value != 0)
      return {};

    auto *CmpLHS = MRI.getVRegDef(MI.getOperand(2).getReg());
    if (CmpLHS->getOpcode() != TargetOpcode::G_INTRINSIC_W_SIDE_EFFECTS)
      return {};

    unsigned IntrinID = cast<GIntrinsic>(*CmpLHS).getIntrinsicID();
    if (IntrinID != Intrinsic::loop_decrement_reg)
      return {};

    JNZDArgs Args;
    Args.NewLC = CmpLHS->getOperand(0).getReg();
    Args.PrevLC = CmpLHS->getOperand(2).getReg();
    Args.IntrinInst = CmpLHS;
    return Args;
  };

  if (auto Args = IsJNZDPattern(*Cond, MRI)) {
    Register BlockAddrReg =
        MRI.createVirtualRegister(&AIE2::eP_as_32BitRegClass);
    MIB.buildInstr(AIE2::MOVXM_lng_cg, {BlockAddrReg}, {}).addMBB(DestMBB);
    auto LoopDec = MIB.buildInstr(AIE2::LoopDec, {Args->NewLC}, {Args->PrevLC});
    MIB.buildInstr(AIE2::LoopJNZ, {},
                   {LoopDec->getOperand(0).getReg(), BlockAddrReg});
    // Explicitly remove intrinsic as it isn't caught in the isTriviallyDead
    // check
    I.eraseFromParent();
    Args->IntrinInst->eraseFromParent();
    return constrainSelectedInstRegOperands(*LoopDec, TII, TRI, RBI);
  }
  // Try matching ZOL loop end
  if (selectBrCondLoopDecrement(I, MRI)) {
    return true;
  }

  // resort to TableGen'ed selection patterns
  return selectImpl(I, *CoverageInfo);
}

bool AIE2InstructionSelector::selectG_BRINDIRECT(MachineInstr &I,
                                                 MachineRegisterInfo &MRI) {
  I.setDesc(TII.get(AIE2::PseudoJ_jump_ind));
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectG_JUMP_TABLE(MachineInstr &I,
                                                 MachineRegisterInfo &MRI) {
  I.setDesc(TII.get(AIE2::MOVXM_lng_cg));
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectG_CONSTANT(MachineInstr &I,
                                               MachineRegisterInfo &MRI) {
  // TODO: it isn't easy to rely on TableGen patterns, as there's poor support
  // for pointer types. If GlobalISel ever get its own pattern language with
  // pointer types properly supported, we should use it.
  const Register DstReg = I.getOperand(0).getReg();
  const LLT Ty = MRI.getType(DstReg);
  assert((Ty == LLT::pointer(0, 20) || Ty == LLT::scalar(20) ||
          Ty == LLT::scalar(32)) &&
         "Only support 20, 32-bit integer and 20-bit pointer constants");
  const RegisterBank &DstRB = *RBI.getRegBank(DstReg, MRI, TRI);
  assert((DstRB.getID() == AIE2::PTRRegBankID ||
          DstRB.getID() == AIE2::MODRegBankID ||
          DstRB.getID() == AIE2::GPRRegBankID) &&
         "Expected constants only on GPR, MOD and PTR register banks");

  APInt Imm = I.getOperand(1).getCImm()->getValue();
  auto OpCode = TII.getConstantMovOpcode(MRI, DstReg, Imm);
  MachineInstr &MI = *MIB.buildInstr(OpCode, {DstReg}, {})
                          .addImm(Imm.getSExtValue())
                          .getInstr();

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectG_GLOBAL_VALUE(MachineInstr &I,
                                                   MachineRegisterInfo &) {
  I.setDesc(TII.get(AIE2::MOVXM_lng_cg));
  I.getOperand(1).setTargetFlags(AIEII::MO_GLOBAL);
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectG_IMPLICIT_DEF(MachineInstr &I,
                                                   MachineRegisterInfo &MRI) {
  I.setDesc(TII.get(TargetOpcode::IMPLICIT_DEF));
  // Make sure no input operands are passed to IMPLICIT_DEF
  while (I.getNumOperands() > 1)
    I.removeOperand(1);
  const MachineOperand &DstOp = I.getOperand(0);
  const RegisterBank &RB = *RBI.getRegBank(DstOp.getReg(), MRI, TRI);
  const TargetRegisterClass &RC =
      TRI.getMinClassForRegBank(RB, MRI.getType(DstOp.getReg()));
  return RBI.constrainGenericRegister(DstOp.getReg(), RC, MRI);
}

bool AIE2InstructionSelector::selectG_LOAD(MachineInstr &I,
                                           MachineRegisterInfo &MRI) {
  // TODO: this is awfully close to AIE1, code should probably be shared.
  Register DstReg = I.getOperand(0).getReg();
  Register PtrReg = I.getOperand(1).getReg();

  const unsigned DstRB = RBI.getRegBank(DstReg, MRI, TRI)->getID();
  const unsigned PtrRB = RBI.getRegBank(PtrReg, MRI, TRI)->getID();

  // The pointer needs to reside in PTRs
  if (PtrRB != AIE2::PTRRegBankID)
    return false;

  LLT DstTy = MRI.getType(DstReg);
  unsigned LoadSize = DstTy.getSizeInBits();

  // Vector Loads <= 512 bits are handled in selectG_AIE_LOAD_STORE
  if (DstTy.isVector() && LoadSize <= 512)
    return selectG_AIE_LOAD_STORE(I, MRI);

  if (LoadSize == 128) {
    // Try selecting mask loads for SP-relative
    if (selectImpl(I, *CoverageInfo))
      return true;

    // Handle Direct pointer load here,other loads are selected through
    // AIE Specfic GMIR for LOADS such as G_AIE_OFFSET_LOAD
    // G_AIE_POSTINC_LOAD, G_AIE_POSTINC_2D_LOAD,G_AIE_POSTINC_3D_LOAD
    I.setDesc(TII.get(AIE2::VLDA_128));
    return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
  }

  if (DstRB == AIE2::GPRRegBankID) {
    if (MRI.getType(DstReg).getScalarSizeInBits() == 20) {
      // We map to a *(ptr + imm) addrmode with imm = 0
      I.setDesc(TII.get(AIE2::LDA_dms_lda_idx_imm));
      I.addOperand(*MF, MachineOperand::CreateImm(0));
      return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
    }
  }

  return selectImpl(I, *CoverageInfo);
}

/// Create a REG_SEQUENCE instruction using the registers in \p Regs.
static MachineInstr &createTuple(Register DstReg, ArrayRef<Register> SrcRegs,
                                 ArrayRef<unsigned> SubRegs,
                                 MachineIRBuilder &MIB) {
  assert(SrcRegs.size() == SubRegs.size());
  auto RegSequence = MIB.buildInstr(TargetOpcode::REG_SEQUENCE, {DstReg}, {});
  for (unsigned I = 0, E = SrcRegs.size(); I < E; ++I) {
    RegSequence.addUse(SrcRegs[I]);
    RegSequence.addImm(SubRegs[I]);
  }
  return *RegSequence;
}

bool AIE2InstructionSelector::selectLRegSequence(MachineInstr &I,
                                                 MachineRegisterInfo &MRI) {
  assert(I.getNumOperands() == 3);
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg1 = I.getOperand(1).getReg();
  Register SrcReg2 = I.getOperand(2).getReg();
  const RegisterBank &DstRB = *RBI.getRegBank(DstReg, MRI, TRI);
  const RegisterBank &Src1RB = *RBI.getRegBank(SrcReg1, MRI, TRI);
  const RegisterBank &Src2RB = *RBI.getRegBank(SrcReg2, MRI, TRI);

  if (DstRB.getID() != AIE2::GPRRegBankID ||
      Src1RB.getID() != AIE2::GPRRegBankID ||
      Src2RB.getID() != AIE2::GPRRegBankID)
    return false;

  createTuple(DstReg, {SrcReg1, SrcReg2}, {AIE2::sub_l_even, AIE2::sub_l_odd},
              MIB);

  const RegisterBank &GPRBank = RBI.getRegBank(AIE2::GPRRegBankID);
  for (MachineOperand &Op : I.operands()) {
    LLT Type = MRI.getType(Op.getReg());
    const TargetRegisterClass &RC = TRI.getMinClassForRegBank(GPRBank, Type);
    if (!RBI.constrainGenericRegister(Op.getReg(), RC, MRI))
      return false;
  }
  I.eraseFromParent();
  return true;
}

bool AIE2InstructionSelector::selectG_PHI(MachineInstr &I,
                                          MachineRegisterInfo &MRI) {
  const Register DstReg = I.getOperand(0).getReg();
  const RegClassOrRegBank &RegClassOrBank = MRI.getRegClassOrRegBank(DstReg);
  const TargetRegisterClass *DstRC =
      RegClassOrBank.dyn_cast<const TargetRegisterClass *>();
  if (!DstRC) {
    const RegisterBank &RB = *RegClassOrBank.get<const RegisterBank *>();
    DstRC = &TRI.getMinClassForRegBank(RB, MRI.getType(DstReg));
  }
  I.setDesc(TII.get(TargetOpcode::PHI));
  return RBI.constrainGenericRegister(DstReg, *DstRC, MRI);
}

bool AIE2InstructionSelector::selectG_PTR_ADD(MachineInstr &I,
                                              MachineRegisterInfo &MRI) {
  // TODO: this is awfully close to AIE1, code should probably be shared.
  Register DstReg = I.getOperand(0).getReg();
  Register Src1Reg = I.getOperand(1).getReg();
  Register Src2Reg = I.getOperand(2).getReg();

  const RegisterBank *DstRB = RBI.getRegBank(DstReg, MRI, TRI);
  const RegisterBank *Src1RB = RBI.getRegBank(Src1Reg, MRI, TRI);
  const RegisterBank *Src2RB = RBI.getRegBank(Src2Reg, MRI, TRI);

  // Pointer addition on GPRs is a simple ADD, and requires all operands in GPRs
  if (DstRB->getID() == AIE2::GPRRegBankID) {
    if (Src1RB->getID() != AIE2::GPRRegBankID ||
        Src1RB->getID() != Src2RB->getID())
      return false;

    // FIXME: Constants on the RHS could be folded into the ADD instruction by
    // relying on the TableGen patterns for G_ADD on GPRRegbank
    MachineInstr &MI = *MIB.buildInstr(AIE2::ADD, {DstReg}, {Src1Reg, Src2Reg});
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(MI, TII, TRI, RBI);
  }

  // Standard PTR bank case handled through patterns.
  return selectImpl(I, *CoverageInfo);
}

bool AIE2InstructionSelector::selectG_SEXT_INREG(MachineInstr &I,
                                                 MachineRegisterInfo &MRI) {
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();

  const RegisterBank *DstRB = RBI.getRegBank(DstReg, MRI, TRI);
  const RegisterBank *SrcRB = RBI.getRegBank(SrcReg, MRI, TRI);

  // We only support sign-extension on GPRs
  if (DstRB->getID() != SrcRB->getID() || DstRB->getID() != AIE2::GPRRegBankID)
    return false;

  int64_t Imm = I.getOperand(2).getImm();
  MachineInstrBuilder MI;
  if (Imm == 8) {
    MI = MIB.buildInstr(AIE2::EXTENDs8, {DstReg}, {SrcReg});
  } else if (Imm == 16) {
    MI = MIB.buildInstr(AIE2::EXTENDs16, {DstReg}, {SrcReg});
  } else {
    llvm_unreachable("Cannot handle type in selectG_SEXT_INREG");
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectG_STORE(MachineInstr &I,
                                            MachineRegisterInfo &MRI) {
  Register SrcReg = I.getOperand(0).getReg();
  Register PtrReg = I.getOperand(1).getReg();

  const RegisterBank *PtrRB = RBI.getRegBank(PtrReg, MRI, TRI);

  // The pointer needs to reside in PTRs
  if (PtrRB->getID() != AIE2::PTRRegBankID)
    return false;

  LLT SrcTy = MRI.getType(SrcReg);
  unsigned StoreSize = SrcTy.getSizeInBits();

  // Non-vector Stores are handled in TableGen
  if (!SrcTy.isVector())
    return selectImpl(I, *CoverageInfo);

  // Vector Stores <= 256 bits are handled in selectG_AIE_LOAD_STORE
  if (StoreSize <= 512)
    return selectG_AIE_LOAD_STORE(I, MRI);

  bool IsAccumulator = SrcTy.getElementType().getSizeInBits() == 64;
  const unsigned StoreOpc = IsAccumulator ? AIE2::VST_dmw_sts_am_ag_idx_imm
                                          : AIE2::VST_dmw_sts_w_ag_idx_imm;

  auto SplitVectorStore512Bits = [=](Register StoreReg, unsigned Offset,
                                     MachineRegisterInfo &MRI, MachineInstr &I,
                                     int Factor) -> void {
    const TargetRegisterClass *RC =
        IsAccumulator ? &AIE2::ACC256RegClass : &AIE2::VEC256RegClass;
    Register Low256 = MRI.createVirtualRegister(RC);
    Register High256 = MRI.createVirtualRegister(RC);
    auto LowerBits = MIB.buildInstr(TargetOpcode::COPY, {Low256}, {})
                         .addReg(StoreReg, 0, AIE2::sub_256_lo);
    auto HigherBits = MIB.buildInstr(TargetOpcode::COPY, {High256}, {})
                          .addReg(StoreReg, 0, AIE2::sub_256_hi);
    auto StoreHigher =
        MIB.buildInstr(StoreOpc, {}, {HigherBits.getReg(0), PtrReg})
            .addImm(32 + Offset);
    auto StoreLower =
        MIB.buildInstr(StoreOpc, {}, {LowerBits.getReg(0), PtrReg})
            .addImm(0 + Offset);

    addSplitMemOperands(I, StoreHigher, StoreLower, Offset, Factor);

    constrainSelectedInstRegOperands(*StoreLower, TII, TRI, RBI);
    constrainSelectedInstRegOperands(*StoreHigher, TII, TRI, RBI);
  };

  if (StoreSize == 1024) {
    const TargetRegisterClass *RC =
        IsAccumulator ? &AIE2::ACC512RegClass : &AIE2::VEC512RegClass;
    Register Low512 = MRI.createVirtualRegister(RC);
    Register High512 = MRI.createVirtualRegister(RC);
    auto Lower512Bits = MIB.buildInstr(TargetOpcode::COPY, {Low512}, {})
                            .addReg(SrcReg, 0, AIE2::sub_512_lo);
    auto Higher512Bits = MIB.buildInstr(TargetOpcode::COPY, {High512}, {})
                             .addReg(SrcReg, 0, AIE2::sub_512_hi);
    constrainSelectedInstRegOperands(*Lower512Bits, TII, TRI, RBI);
    constrainSelectedInstRegOperands(*Higher512Bits, TII, TRI, RBI);

    SplitVectorStore512Bits(Higher512Bits.getReg(0), 64, MRI, I, 4);
    SplitVectorStore512Bits(Lower512Bits.getReg(0), 0, MRI, I, 4);
  } else {
    return false;
  }

  I.eraseFromParent();
  return true;
}

static void createSubRegCopies(ArrayRef<Register> DstRegs, Register SrcReg,
                               ArrayRef<unsigned> SubRegs,
                               MachineIRBuilder &MIB) {
  assert(DstRegs.size() == SubRegs.size());
  for (size_t Idx = 0; Idx != DstRegs.size(); ++Idx) {
    Register DstReg = DstRegs[Idx];
    unsigned SubReg = SubRegs[Idx];
    MIB.buildInstr(TargetOpcode::COPY, {DstReg}, {})
        .addReg(SrcReg, /*flags=*/0, SubReg);
  }
}

bool AIE2InstructionSelector::selectG_UNMERGE_VALUES(MachineInstr &I,
                                                     MachineRegisterInfo &MRI) {
  assert(I.getNumOperands() == 3);
  const Register DstReg1 = I.getOperand(0).getReg();
  const Register DstReg2 = I.getOperand(1).getReg();
  const Register SrcReg = I.getOperand(2).getReg();

  const LLT Dst1VecTy = MRI.getType(DstReg1);
  const LLT SrcVecTy = MRI.getType(SrcReg);

  const RegisterBank &Dst1RB = *RBI.getRegBank(DstReg1, MRI, TRI);
  const RegisterBank &Dst2RB = *RBI.getRegBank(DstReg2, MRI, TRI);
  const RegisterBank &SrcRB = *RBI.getRegBank(SrcReg, MRI, TRI);

  // Copy the subregisters from the larger register, this only makes sense
  // whenever both sides are vectors.
  unsigned RegBankID;
  std::pair<unsigned, unsigned> TargetSubRegs;

  if (Dst1VecTy.isVector() && SrcVecTy.isVector()) {
    assert(SrcVecTy.getSizeInBits() == 2 * Dst1VecTy.getSizeInBits() &&
           "target register must be exactly half the size of source register");
    assert(Dst1VecTy == MRI.getType(DstReg2) &&
           "destination types must be the same");
    RegBankID = AIE2::VRegBankID;

    if (Dst1VecTy.getSizeInBits() == 256) {
      TargetSubRegs.first = AIE2::sub_256_lo;
      TargetSubRegs.second = AIE2::sub_256_hi;
    } else if (Dst1VecTy.getSizeInBits() == 512) {
      TargetSubRegs.first = AIE2::sub_512_lo;
      TargetSubRegs.second = AIE2::sub_512_hi;
    }
  } else if (Dst1VecTy.isScalar()) {
    RegBankID = AIE2::GPRRegBankID;
    TargetSubRegs.first = AIE2::sub_l_even;
    TargetSubRegs.second = AIE2::sub_l_odd;
  } else {
    llvm_unreachable(
        "trying to unmerge a value into a non-vector or scalar value");
  }

  if (Dst1RB.getID() != RegBankID || Dst2RB.getID() != RegBankID ||
      SrcRB.getID() != RegBankID)
    return false;

  createSubRegCopies({DstReg1, DstReg2}, SrcReg,
                     {TargetSubRegs.first, TargetSubRegs.second}, MIB);

  const RegisterBank &RegBank = RBI.getRegBank(RegBankID);
  for (MachineOperand &Op : I.operands()) {
    LLT Type = MRI.getType(Op.getReg());
    const TargetRegisterClass &RC = TRI.getMinClassForRegBank(RegBank, Type);
    if (!RBI.constrainGenericRegister(Op.getReg(), RC, MRI))
      return false;
  }

  I.eraseFromParent();
  return true;
}

bool AIE2InstructionSelector::selectGetCoreID(MachineInstr &I,
                                              MachineRegisterInfo &MRI) {

  Register DstReg = I.getOperand(0).getReg();

  auto CopyInstr =
      MIB.buildInstr(TargetOpcode::COPY, {DstReg}, {}).addReg(AIE2::CORE_ID);
  if (!selectCopy(*CopyInstr, MRI)) {
    return false;
  }

  I.eraseFromParent();
  return true;
}

bool AIE2InstructionSelector::selectVMAXDIFF_LT(MachineInstr &I,
                                                MachineRegisterInfo &MRI) {

  Register DstReg = I.getOperand(0).getReg();
  Register CmpReg = I.getOperand(1).getReg();
  // In this case of G_INTRINSIC operand 2 is target intrinsic
  Register Src1Reg = I.getOperand(3).getReg();
  Register Src2Reg = I.getOperand(4).getReg();
  Register SignReg = I.getOperand(5).getReg();

  if (auto SignVal = getIConstantVRegSExtVal(SignReg, MRI)) {
    // Handle constant sign through instruction patterns
    return selectImpl(I, *CoverageInfo);
  }

  unsigned OpCode = getOpCode(cast<GIntrinsic>(I).getIntrinsicID());
  MachineInstrBuilder MI = MIB.buildInstr(OpCode, {DstReg, CmpReg}, {})
                               .addReg(Src1Reg)
                               .addReg(Src2Reg);

  setUnsetCtrlRegister(*MI, MRI, AIE2::crVaddSign, SignReg);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectVABS_GTZ(MachineInstr &I,
                                             MachineRegisterInfo &MRI) {

  Register DstReg = I.getOperand(0).getReg();
  Register CmpReg = I.getOperand(1).getReg();
  // In this case of G_INTRINSIC operand 2 is target intrinsic
  Register SrcReg = I.getOperand(3).getReg();
  Register SignReg = I.getOperand(4).getReg();

  if (auto SignVal = getIConstantVRegSExtVal(SignReg, MRI)) {
    // Handle constant sign through instruction patterns
    return selectImpl(I, *CoverageInfo);
  }

  unsigned OpCode = getOpCode(cast<GIntrinsic>(I).getIntrinsicID());
  MachineInstrBuilder MI =
      MIB.buildInstr(OpCode, {DstReg, CmpReg}, {}).addReg(SrcReg);

  setUnsetCtrlRegister(*MI, MRI, AIE2::crVaddSign, SignReg);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectVSUB_LTGE(MachineInstr &I,
                                              MachineRegisterInfo &MRI) {

  Register DstReg = I.getOperand(0).getReg();
  Register CmpReg = I.getOperand(1).getReg();
  // In this case of G_INTRINSIC operand 2 is target intrinsic
  Register Src1Reg = I.getOperand(3).getReg();
  Register Src2Reg = I.getOperand(4).getReg();
  Register SignReg = I.getOperand(5).getReg();

  if (auto SignVal = getIConstantVRegSExtVal(SignReg, MRI)) {
    // Handle constant sign through instruction patterns
    return selectImpl(I, *CoverageInfo);
  }

  unsigned OpCode = getOpCode(cast<GIntrinsic>(I).getIntrinsicID());
  MachineInstrBuilder MI = MIB.buildInstr(OpCode, {DstReg, CmpReg}, {})
                               .addReg(Src1Reg)
                               .addReg(Src2Reg);

  setUnsetCtrlRegister(*MI, MRI, AIE2::crVaddSign, SignReg);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectVUNPACK(MachineInstr &I,
                                            MachineRegisterInfo &MRI) {
  // Try to match UNPACK combine
  if (selectG_AIE_LOAD_UNPACK(I, MRI))
    return true;

  Register DstReg = I.getOperand(0).getReg();
  // In this case of G_INTRINSIC operand 1 is target intrinsic
  Register SrcReg = I.getOperand(2).getReg();
  Register SignReg = I.getOperand(3).getReg();
  MachineInstrBuilder MI;

  if (auto Sign = getIConstantVRegValWithLookThrough(SignReg, MRI)) {
    unsigned OpCode;
    unsigned SignVal = Sign->Value.getZExtValue();
    if (SignVal)
      OpCode = (cast<GIntrinsic>(I).getIntrinsicID() == Intrinsic::aie2_unpack_I8_I4)
                   ? AIE2::VUNPACK_S8_S4
                   : AIE2::VUNPACK_S16_S8;
    else
      OpCode = (cast<GIntrinsic>(I).getIntrinsicID() == Intrinsic::aie2_unpack_I8_I4)
                   ? AIE2::VUNPACK_D8_D4
                   : AIE2::VUNPACK_D16_D8;
    MI = MIB.buildInstr(OpCode, {DstReg}, {}).addReg(SrcReg);
  } else {
    unsigned OpCode = (cast<GIntrinsic>(I).getIntrinsicID() == Intrinsic::aie2_unpack_I8_I4)
                          ? AIE2::VUNPACK_D8_D4
                          : AIE2::VUNPACK_D16_D8;
    MI = MIB.buildInstr(OpCode, {DstReg}, {}).addReg(SrcReg);
    setUnsetCtrlRegister(*MI, MRI, AIE2::crUnpackSign, SignReg);
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectVPACK(MachineInstr &I,
                                          MachineRegisterInfo &MRI) {

  Register DstReg = I.getOperand(0).getReg();
  // In this case of G_INTRINSIC_W_SIDE_EFFECTS, operand 1 is target intrinsic.
  Register SrcReg = I.getOperand(2).getReg();
  Register SignReg = I.getOperand(3).getReg();
  MachineInstrBuilder MI;

  if (auto Sign = getIConstantVRegValWithLookThrough(SignReg, MRI)) {
    unsigned OpCode;
    unsigned SignVal = Sign->Value.getZExtValue();
    if (SignVal)
      OpCode = (cast<GIntrinsic>(I).getIntrinsicID() == Intrinsic::aie2_pack_I4_I8)
                   ? AIE2::VPACK_S4_S8
                   : AIE2::VPACK_S8_S16;
    else
      OpCode = (cast<GIntrinsic>(I).getIntrinsicID() == Intrinsic::aie2_pack_I4_I8)
                   ? AIE2::VPACK_D4_D8
                   : AIE2::VPACK_D8_D16;
    MI = MIB.buildInstr(OpCode, {DstReg}, {}).addReg(SrcReg);
  } else {
    unsigned OpCode = (cast<GIntrinsic>(I).getIntrinsicID() == Intrinsic::aie2_pack_I4_I8)
                          ? AIE2::VPACK_D4_D8
                          : AIE2::VPACK_D8_D16;
    MI = MIB.buildInstr(OpCode, {DstReg}, {}).addReg(SrcReg);
    setUnsetCtrlRegister(*MI, MRI, AIE2::crPackSign, SignReg);
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

unsigned getLoadStoreSize(const MachineInstr &MI) {
  // We are guaranteed to have MMOs during Instruction Selection.
  // We need them to select the correct instruction when they depend on the
  // size in memory and not on the register size. E.g.: part word stores.
  return (*MI.memoperands_begin())->getSizeInBits().getValue();
}

template <unsigned NumEncodingBits, unsigned Step>
bool checkImmediateRange(std::optional<APInt> Immediate) {
  unsigned MaxPow2 = NumEncodingBits + llvm::Log2_64(Step);
  if (Immediate && isIntN(MaxPow2, Immediate->getSExtValue()) &&
      Immediate->getSExtValue() % Step == 0) {
    LLVM_DEBUG(dbgs() << "Immediate " << Immediate << " is valid for MaxPow2 "
                      << MaxPow2 << " and Step " << Step << ".\n");
    return true;
  }
  return false;
}

template <unsigned NumEncodingBits, unsigned Step, unsigned SplitOffset>
bool checkImmediateRangeSplitting(std::optional<APInt> Immediate) {
  return Immediate && checkImmediateRange<NumEncodingBits, Step>(Immediate) &&
         checkImmediateRange<NumEncodingBits, Step>(*Immediate + SplitOffset);
}

std::optional<LoadStoreOpcodes> getCombinedOpcodeUNPACKLoad(
    const MachineInstr &MemOp, const MachineInstr &CombOp,
    std::optional<APInt> Immediate, MachineRegisterInfo &MRI) {

  const bool NoImmediate = false;
  if (CombOp.getOpcode() != AIE2::G_INTRINSIC ||
      (cast<GIntrinsic>(CombOp).getIntrinsicID() !=
           Intrinsic::aie2_unpack_I8_I4 &&
       cast<GIntrinsic>(CombOp).getIntrinsicID() !=
           Intrinsic::aie2_unpack_I16_I8))
    return {};

  if (!MemOp.mayLoad())
    return {};

  assert(getLoadStoreSize(MemOp) == 256 && "Unexpected VLDA.UNPACK size");

  unsigned ISelOpcode;
  Register SignReg = CombOp.getOperand(3).getReg();

  auto Sign = getIConstantVRegValWithLookThrough(SignReg, MRI);
  if (Sign && Sign->Value.getZExtValue()) {
    if (cast<GIntrinsic>(CombOp).getIntrinsicID() ==
        Intrinsic::aie2_unpack_I8_I4) {
      switch (MemOp.getOpcode()) {
      case AIE2::G_AIE_OFFSET_LOAD:
        ISelOpcode = AIE2::VLDB_UNPACK_S8_S4_ag_idx;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_LOAD:
        ISelOpcode = AIE2::VLDB_UNPACK_S8_S4_ag_pstm_nrm;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_2D_LOAD:
        ISelOpcode = AIE2::VLDB_2D_UNPACK_S8_S4;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_3D_LOAD:
        ISelOpcode = AIE2::VLDB_3D_UNPACK_S8_S4;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      }
    } else { // aie2_unpack_I16_I8
      switch (MemOp.getOpcode()) {
      case AIE2::G_AIE_OFFSET_LOAD:
        ISelOpcode = AIE2::VLDB_UNPACK_S16_S8_ag_idx;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_LOAD:
        ISelOpcode = AIE2::VLDB_UNPACK_S16_S8_ag_pstm_nrm;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_2D_LOAD:
        ISelOpcode = AIE2::VLDB_2D_UNPACK_S16_S8;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_3D_LOAD:
        ISelOpcode = AIE2::VLDB_3D_UNPACK_S16_S8;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      }
    }
  } else {
    if (cast<GIntrinsic>(CombOp).getIntrinsicID() ==
        Intrinsic::aie2_unpack_I8_I4) {
      switch (MemOp.getOpcode()) {
      case AIE2::G_AIE_OFFSET_LOAD:
        ISelOpcode = AIE2::VLDB_UNPACK_D8_D4_ag_idx;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_LOAD:
        ISelOpcode = AIE2::VLDB_UNPACK_D8_D4_pstm_nrm;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_2D_LOAD:
        ISelOpcode = AIE2::VLDB_2D_UNPACK_D8_D4;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_3D_LOAD:
        ISelOpcode = AIE2::VLDB_3D_UNPACK_D8_D4;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      }
    } else { // aie2_unpack_I16_I8
      switch (MemOp.getOpcode()) {
      case AIE2::G_AIE_OFFSET_LOAD:
        ISelOpcode = AIE2::VLDB_UNPACK_D16_D8_ag_idx;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_LOAD:
        ISelOpcode = AIE2::VLDB_UNPACK_D16_D8_ag_pstm_nrm;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_2D_LOAD:
        ISelOpcode = AIE2::VLDB_2D_UNPACK_D16_D8;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      case AIE2::G_AIE_POSTINC_3D_LOAD:
        ISelOpcode = AIE2::VLDB_3D_UNPACK_D16_D8;
        return LoadStoreOpcodes{ISelOpcode, NoImmediate, {}};
      }
    }
  }
  return {};
}

bool canCombineUNPACKLoad(MachineInstr &MemOp, MachineInstr &CombOp,
                          MachineRegisterInfo &MRI) {
  const std::optional<APInt> NoImmediate = {};
  return getCombinedOpcodeUNPACKLoad(MemOp, CombOp, NoImmediate, MRI)
      .has_value();
}

// Make an instruction trivially dead by creating and distributing new virtual
// registers to its defs
void AIE2InstructionSelector::makeDeadMI(MachineInstr &MI,
                                         MachineRegisterInfo &MRI) {
  if (MI.getOpcode() == AIE2::G_INTRINSIC_W_SIDE_EFFECTS) {
    MI.setDesc(TII.get(AIE2::G_INTRINSIC));
  }

  for (auto *Def = MI.defs().begin(); Def != MI.defs().end(); ++Def) {
    Register NewReg = MRI.cloneVirtualRegister(Def->getReg());
    Def->setReg(NewReg);
  }
}

bool AIE2InstructionSelector::selectG_AIE_LOAD_UNPACK(
    MachineInstr &UNPACKI, MachineRegisterInfo &MRI) {
  Register LoadResult = (std::next(UNPACKI.uses().begin()))->getReg();
  MachineInstr *LoadOp = getDefIgnoringCopiesAndBitcasts(LoadResult, MRI);

  assert(LoadOp && "Expected SSA.");

  // Do not try to combine if one of the load's defs is used by another
  // instruction between the load and the VUNPACK or if there is a store
  // between the load and the VUNPACK.
  if (!canDelayMemOp(*LoadOp, UNPACKI, MRI))
    return false;

  if (!canCombineUNPACKLoad(*LoadOp, UNPACKI, MRI) ||
      LoadOp->getParent() != UNPACKI.getParent() || !MRI.hasOneUse(LoadResult))
    return false;

  std::optional<AddressingModeInfo> AMI =
      getOrDefineAddressingRegister(*LoadOp, MRI);
  if (!AMI)
    return false;

  std::optional<LoadStoreOpcodes> LSO = getCombinedOpcodeUNPACKLoad(
      AMI->MemI, UNPACKI, AMI->ImmediateOffset, MRI);

  Register DstReg = UNPACKI.getOperand(0).getReg();
  Register SignReg = UNPACKI.getOperand(3).getReg();

  auto NewInstr = MIB.buildInstr(LSO->ISelOpcode);

  NewInstr.addDef(DstReg);

  for (auto *Def = std::next(AMI->MemI.defs().begin());
       Def != AMI->MemI.defs().end(); ++Def) {
    NewInstr.addDef(Def->getReg());
  }

  addAddressingMode(NewInstr, *AMI, LSO->FitsImmediateRange, false, MRI);

  NewInstr.cloneMemRefs(AMI->MemI);

  auto ConstantSign = getIConstantVRegValWithLookThrough(SignReg, MRI);
  if (!ConstantSign)
    setUnsetCtrlRegister(*NewInstr, MRI, AIE2::crUnpackSign, SignReg);

  UNPACKI.eraseFromParent();

  // Erasing the load instruction breaks later on in the selection code. That is
  // because we keep an iterator on erased instructions. This breaks while
  // trying to eliminate a trivially dead instruction which requires access to
  // its memory operands which have been erased, thus leading to a seg fault. To
  // remedy this, we keep the load to be removed by the trivial dead code
  // elimination and we make sure to assign a new virtual register definition to
  // its live operands to respect SSA.
  makeDeadMI(*LoadOp, MRI);

  return constrainSelectedInstRegOperands(*NewInstr.getInstr(), TII, TRI, RBI);
}

void AIE2InstructionSelector::insertPtrAddForOffset(MachineRegisterInfo &MRI,
                                                    MachineInstr &MemI) {
  // The offset is not an immediate or the immediate does not fit the immediate
  // range. Instruction select PTR_ADD for the splitting of instruction. E.g.:
  // $x0 = G_AIE_OFFSET_LOAD %ptr, %offset has to be selected to
  // %new_ptr = PTR_ADD %ptr, %offset
  // $wh0 = VLDA_dmw_lda_w_ag_idx_imm %new_ptr, #32
  // $wl0 = VLDA_dmw_lda_w_ag_idx_imm %new_ptr, #0

  // This function only gets called for G_AIE_OFFSET_LOAD AND G_AIE_OFFSET_STORE
  // Both instruction have the pointer and the offset in the same operands
  assert((MemI.getOpcode() == AIE2::G_AIE_OFFSET_LOAD ||
          MemI.getOpcode() == AIE2::G_AIE_OFFSET_STORE) &&
         "Unexpected instruction in instrPtrAddForOffset");
  const unsigned PointerRegIndex = 1;
  const unsigned OffsetRegIndex = 2;

  Register NewPtrReg =
      MRI.cloneVirtualRegister(MemI.getOperand(PointerRegIndex).getReg());
  MachineInstrBuilder NewPtr =
      MIB.buildInstr(TargetOpcode::G_PTR_ADD)
          .addDef(NewPtrReg)
          .addReg(MemI.getOperand(PointerRegIndex).getReg())
          .addReg(MemI.getOperand(OffsetRegIndex).getReg());

  if (!selectImpl(*NewPtr.getInstr(), *CoverageInfo))
    llvm_unreachable("Unexpected failure selecting G_PTR_ADD");

  MemI.getOperand(PointerRegIndex).setReg(NewPtrReg);
}

std::optional<LoadStoreOpcodes>
getCombinedOpcodeSRSUPS(const MachineInstr &MemOp, const MachineInstr &CombOp,
                        std::optional<APInt> Immediate, bool IsSigned) {
  const bool AlwaysFitsImmediateRange = true;
  const bool NoImmediate = false;
  if (CombOp.getOpcode() != AIE2::G_INTRINSIC_W_SIDE_EFFECTS)
    return {};

  unsigned ISelOpcode;
  bool FitsImmediateRange = false;
  if (IsSigned) {
    switch (MemOp.getOpcode()) {
    case AIE2::G_STORE:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I512_v32_acc32_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_S16_S32_ag_idx_imm,
              AlwaysFitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_S16_S32_ag_idx_imm};
        case Intrinsic::aie2_I512_v16_acc64_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_S32_S64_ag_idx_imm,
              AlwaysFitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_S32_S64_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I256_v16_acc32_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_S16_S32_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v16_acc64_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_S16_S64_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v32_acc32_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_S8_S32_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v8_acc64_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_S32_S64_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_OFFSET_STORE:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I512_v32_acc32_srs:
          FitsImmediateRange =
              checkImmediateRangeSplitting<3, 32, 32>(Immediate);
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_S16_S32_ag_idx_imm,
              FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_S16_S32_ag_idx_imm};
        case Intrinsic::aie2_I512_v16_acc64_srs:
          FitsImmediateRange =
              checkImmediateRangeSplitting<3, 32, 32>(Immediate);
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_S32_S64_ag_idx_imm,
              FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_S32_S64_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I256_v16_acc32_srs:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VST_SRS_S16_S32_ag_idx_imm
                                          : AIE2::VST_SRS_S16_S32_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v16_acc64_srs:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VST_SRS_S16_S64_ag_idx_imm
                                          : AIE2::VST_SRS_S16_S64_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v32_acc32_srs:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VST_SRS_S8_S32_ag_idx_imm
                                          : AIE2::VST_SRS_S8_S32_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v8_acc64_srs:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VST_SRS_S32_S64_ag_idx_imm
                                          : AIE2::VST_SRS_S32_S64_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_STORE:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I512_v32_acc32_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VST_SRS_S16_S32_ag_pstm_nrm_imm
                           : AIE2::VST_SRS_S16_S32_ag_pstm_nrm;
          return LoadStoreOpcodes{
              ISelOpcode, FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_S16_S32_ag_idx_imm};
        case Intrinsic::aie2_I512_v16_acc64_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VST_SRS_S32_S64_ag_pstm_nrm_imm
                           : AIE2::VST_SRS_S32_S64_ag_pstm_nrm;
          return LoadStoreOpcodes{
              ISelOpcode, FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_S32_S64_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I256_v16_acc32_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VST_SRS_S16_S32_ag_pstm_nrm_imm
                           : AIE2::VST_SRS_S16_S32_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v16_acc64_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VST_SRS_S16_S64_ag_pstm_nrm_imm
                           : AIE2::VST_SRS_S16_S64_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v32_acc32_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VST_SRS_S8_S32_ag_pstm_nrm_imm
                                          : AIE2::VST_SRS_S8_S32_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v8_acc64_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VST_SRS_S32_S64_ag_pstm_nrm_imm
                           : AIE2::VST_SRS_S32_S64_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_2D_STORE:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I512_v32_acc32_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_2D_SRS_S16_S32, NoImmediate,
              /*OffsetOpcode=*/AIE2::VST_SRS_S16_S32_ag_idx_imm};
        case Intrinsic::aie2_I512_v16_acc64_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_2D_SRS_S32_S64, NoImmediate,
              /*OffsetOpcode=*/AIE2::VST_SRS_S32_S64_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I256_v16_acc32_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_SRS_S16_S32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v16_acc64_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_SRS_S16_S64,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v32_acc32_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_SRS_S8_S32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v8_acc64_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_SRS_S32_S64,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_3D_STORE:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I512_v32_acc32_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_3D_SRS_S16_S32, NoImmediate,
              /*OffsetOpcode=*/AIE2::VST_SRS_S16_S32_ag_idx_imm};
        case Intrinsic::aie2_I512_v16_acc64_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_3D_SRS_S32_S64, NoImmediate,
              /*OffsetOpcode=*/AIE2::VST_SRS_S32_S64_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I256_v16_acc32_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_SRS_S16_S32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v16_acc64_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_SRS_S16_S64,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v32_acc32_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_SRS_S8_S32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v8_acc64_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_SRS_S32_S64,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_LOAD:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc64_v16_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S64_S32_ag_idx_imm,
              AlwaysFitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S64_S32_ag_idx_imm};
        case Intrinsic::aie2_acc32_v32_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S32_S16_ag_idx_imm,
              AlwaysFitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S32_S16_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v16_I256_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S32_S16_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v16_I256_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S64_S16_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc32_v32_I256_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S32_S8_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v8_I256_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S64_S32_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_OFFSET_LOAD:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc64_v16_I512_ups:
          FitsImmediateRange =
              checkImmediateRangeSplitting<3, 32, 32>(Immediate);
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S64_S32_ag_idx_imm,
              FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S64_S32_ag_idx_imm};
        case Intrinsic::aie2_acc32_v32_I512_ups:
          FitsImmediateRange =
              checkImmediateRangeSplitting<3, 32, 32>(Immediate);
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S32_S16_ag_idx_imm,
              FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S32_S16_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v16_I256_ups:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VLDA_UPS_S32_S16_ag_idx_imm
                                          : AIE2::VLDA_UPS_S32_S16_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v16_I256_ups:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VLDA_UPS_S64_S16_ag_idx_imm
                                          : AIE2::VLDA_UPS_S64_S16_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc32_v32_I256_ups:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VLDA_UPS_S32_S8_ag_idx_imm
                                          : AIE2::VLDA_UPS_S32_S8_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v8_I256_ups:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VLDA_UPS_S64_S32_ag_idx_imm
                                          : AIE2::VLDA_UPS_S64_S32_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_LOAD:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc64_v16_I512_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S64_S32_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S64_S32_ag_pstm_nrm;
          return LoadStoreOpcodes{
              ISelOpcode, FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S64_S32_ag_idx_imm};
        case Intrinsic::aie2_acc32_v32_I512_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S32_S16_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S32_S16_ag_pstm_nrm;
          return LoadStoreOpcodes{
              ISelOpcode, FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S32_S16_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v16_I256_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S32_S16_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S32_S16_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v16_I256_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S64_S16_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S64_S16_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc32_v32_I256_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S32_S8_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S32_S8_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v8_I256_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S64_S32_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S64_S32_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_2D_LOAD:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v32_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_2D_UPS_S32_S16, NoImmediate,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S32_S16_ag_idx_imm};
        case Intrinsic::aie2_acc64_v16_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_2D_UPS_S64_S32, NoImmediate,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S64_S32_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v16_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_2D_UPS_S32_S16,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v16_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_2D_UPS_S64_S16,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc32_v32_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_2D_UPS_S32_S8,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v8_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_2D_UPS_S64_S32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_3D_LOAD:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v32_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_3D_UPS_S32_S16, NoImmediate,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S32_S16_ag_idx_imm};
        case Intrinsic::aie2_acc64_v16_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_3D_UPS_S64_S32, NoImmediate,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S64_S32_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v16_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_3D_UPS_S32_S16,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v16_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_3D_UPS_S64_S16,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc32_v32_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_3D_UPS_S32_S8,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v8_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_3D_UPS_S64_S32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    }
    // isSigned
  } else {
    switch (MemOp.getOpcode()) {
    case AIE2::G_STORE:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I512_v32_acc32_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_D16_S32_ag_idx_imm,
              AlwaysFitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_D16_S32_ag_idx_imm};
        case Intrinsic::aie2_I512_v16_acc64_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_D32_S64_ag_idx_imm,
              AlwaysFitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_D32_S64_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I256_v16_acc32_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_D16_S32_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v16_acc64_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_D16_S64_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v32_acc32_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_D8_S32_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v8_acc64_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_D32_S64_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_OFFSET_STORE:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I512_v32_acc32_srs:
          FitsImmediateRange =
              checkImmediateRangeSplitting<3, 32, 32>(Immediate);
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_D16_S32_ag_idx_imm,
              FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_D16_S32_ag_idx_imm};
        case Intrinsic::aie2_I512_v16_acc64_srs:
          FitsImmediateRange =
              checkImmediateRangeSplitting<3, 32, 32>(Immediate);
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_SRS_D32_S64_ag_idx_imm,
              FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_D32_S64_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I256_v16_acc32_srs:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VST_SRS_D16_S32_ag_idx_imm
                                          : AIE2::VST_SRS_D16_S32_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v16_acc64_srs:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VST_SRS_D16_S64_ag_idx_imm
                                          : AIE2::VST_SRS_D16_S64_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v32_acc32_srs:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VST_SRS_D8_S32_ag_idx_imm
                                          : AIE2::VST_SRS_D8_S32_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v8_acc64_srs:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VST_SRS_D32_S64_ag_idx_imm
                                          : AIE2::VST_SRS_D32_S64_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_STORE:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I512_v32_acc32_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VST_SRS_D16_S32_ag_pstm_nrm_imm
                           : AIE2::VST_SRS_D16_S32_ag_pstm_nrm;
          return LoadStoreOpcodes{
              ISelOpcode, FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_D16_S32_ag_idx_imm};
        case Intrinsic::aie2_I512_v16_acc64_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VST_SRS_D32_S64_ag_pstm_nrm_imm
                           : AIE2::VST_SRS_D32_S64_ag_pstm_nrm;
          return LoadStoreOpcodes{
              ISelOpcode, FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VST_SRS_D32_S64_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I256_v16_acc32_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VST_SRS_D16_S32_ag_pstm_nrm_imm
                           : AIE2::VST_SRS_D16_S32_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v16_acc64_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VST_SRS_D16_S64_ag_pstm_nrm_imm
                           : AIE2::VST_SRS_D16_S64_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v32_acc32_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VST_SRS_D8_S32_ag_pstm_nrm_imm
                                          : AIE2::VST_SRS_D8_S32_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v8_acc64_srs:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VST_SRS_D32_S64_ag_pstm_nrm_imm
                           : AIE2::VST_SRS_D32_S64_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_2D_STORE:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I512_v32_acc32_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_2D_SRS_D16_S32, NoImmediate,
              /*OffsetOpcode=*/AIE2::VST_SRS_D16_S32_ag_idx_imm};
        case Intrinsic::aie2_I512_v16_acc64_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_2D_SRS_D32_S64, NoImmediate,
              /*OffsetOpcode=*/AIE2::VST_SRS_D32_S64_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I256_v16_acc32_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_SRS_D16_S32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v16_acc64_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_SRS_D16_S64,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v32_acc32_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_SRS_D8_S32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v8_acc64_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_SRS_D32_S64,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_3D_STORE:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I512_v32_acc32_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_3D_SRS_D16_S32, NoImmediate,
              /*OffsetOpcode=*/AIE2::VST_SRS_D16_S32_ag_idx_imm};
        case Intrinsic::aie2_I512_v16_acc64_srs:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VST_3D_SRS_D32_S64, NoImmediate,
              /*OffsetOpcode=*/AIE2::VST_SRS_D32_S64_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_I256_v16_acc32_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_SRS_D16_S32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v16_acc64_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_SRS_D16_S64,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v32_acc32_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_SRS_D8_S32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_I256_v8_acc64_srs:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_SRS_D32_S64,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_LOAD:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc64_v16_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S64_D32_ag_idx_imm,
              AlwaysFitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S64_D32_ag_idx_imm};
        case Intrinsic::aie2_acc32_v32_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S32_D16_ag_idx_imm,
              AlwaysFitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S32_D16_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v16_I256_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S32_D16_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v16_I256_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S64_D16_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc32_v32_I256_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S32_D8_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v8_I256_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S64_D32_ag_idx_imm,
              AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_OFFSET_LOAD:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc64_v16_I512_ups:
          FitsImmediateRange =
              checkImmediateRangeSplitting<3, 32, 32>(Immediate);
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S64_D32_ag_idx_imm,
              FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S64_D32_ag_idx_imm};
        case Intrinsic::aie2_acc32_v32_I512_ups:
          FitsImmediateRange =
              checkImmediateRangeSplitting<3, 32, 32>(Immediate);
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_UPS_S32_D16_ag_idx_imm,
              FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S32_D16_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v16_I256_ups:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VLDA_UPS_S32_D16_ag_idx_imm
                                          : AIE2::VLDA_UPS_S32_D16_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v16_I256_ups:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VLDA_UPS_S64_D16_ag_idx_imm
                                          : AIE2::VLDA_UPS_S64_D16_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc32_v32_I256_ups:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VLDA_UPS_S32_D8_ag_idx_imm
                                          : AIE2::VLDA_UPS_S32_D8_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v8_I256_ups:
          FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
          ISelOpcode = FitsImmediateRange ? AIE2::VLDA_UPS_S64_D32_ag_idx_imm
                                          : AIE2::VLDA_UPS_S64_D32_ag_idx;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_LOAD:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc64_v16_I512_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S64_D32_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S64_D32_ag_pstm_nrm;
          return LoadStoreOpcodes{
              ISelOpcode, FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S64_D32_ag_idx_imm};
        case Intrinsic::aie2_acc32_v32_I512_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S32_D16_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S32_D16_ag_pstm_nrm;
          return LoadStoreOpcodes{
              ISelOpcode, FitsImmediateRange,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S32_D16_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v16_I256_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S32_D16_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S32_D16_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v16_I256_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S64_D16_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S64_D16_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc32_v32_I256_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S32_D8_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S32_D8_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v8_I256_ups:
          FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
          ISelOpcode = FitsImmediateRange
                           ? AIE2::VLDA_UPS_S64_D32_ag_pstm_nrm_imm
                           : AIE2::VLDA_UPS_S64_D32_ag_pstm_nrm;
          return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_2D_LOAD:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v32_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_2D_UPS_S32_D16, NoImmediate,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S32_D16_ag_idx_imm};
        case Intrinsic::aie2_acc64_v16_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_2D_UPS_S64_D32, NoImmediate,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S64_D32_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v16_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_2D_UPS_S32_D16,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v16_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_2D_UPS_S64_D16,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc32_v32_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_2D_UPS_S32_D8,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v8_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_2D_UPS_S64_D32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    case AIE2::G_AIE_POSTINC_3D_LOAD:
      if (getLoadStoreSize(MemOp) == 512) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v32_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_3D_UPS_S32_D16, NoImmediate,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S32_D16_ag_idx_imm};
        case Intrinsic::aie2_acc64_v16_I512_ups:
          return LoadStoreOpcodes{
              /*ISelOpcode=*/AIE2::VLDA_3D_UPS_S64_D32, NoImmediate,
              /*OffsetOpcode=*/AIE2::VLDA_UPS_S64_D32_ag_idx_imm};
        }
      }
      if (getLoadStoreSize(MemOp) == 256) {
        switch (cast<GIntrinsic>(CombOp).getIntrinsicID()) {
        case Intrinsic::aie2_acc32_v16_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_3D_UPS_S32_D16,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v16_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_3D_UPS_S64_D16,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc32_v32_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_3D_UPS_S32_D8,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        case Intrinsic::aie2_acc64_v8_I256_ups:
          return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VLDA_3D_UPS_S64_D32,
                                  NoImmediate,
                                  /*OffsetOpcode=*/{}};
        }
      }
      break;
    }
  }
  return {};
}

bool canCombineSRSUPS(MachineInstr &MemOp, MachineInstr &CombOp) {

  const std::optional<APInt> NoImmediate = {};
  const bool IsSigned = true;

  return getCombinedOpcodeSRSUPS(MemOp, CombOp, NoImmediate, IsSigned)
      .has_value();
}

AddressingModeInfo createAddressModeInfo(MachineInstr &MemI,
                                         MachineOperand &SrcDstOp,
                                         MachineOperand &PtrOp,
                                         std::optional<Register> OffsetReg,
                                         MachineRegisterInfo &MRI) {
  std::optional<ValueAndVReg> OffsetVVReg = {};
  std::optional<APInt> ImmediateOffset = {};
  if (OffsetReg && mi_match(*OffsetReg, MRI, m_GCst(OffsetVVReg))) {
    LLVM_DEBUG(dbgs() << "Found an immediate offset: "
                      << OffsetVVReg->Value.getSExtValue() << "\n");
    ImmediateOffset = OffsetVVReg->Value;
  }

  return {MemI, SrcDstOp, PtrOp, OffsetReg, ImmediateOffset};
}

std::optional<AddressingModeInfo>
AIE2InstructionSelector::getOrDefineAddressingRegister(
    MachineInstr &MemI, MachineRegisterInfo &MRI) {
  switch (MemI.getOpcode()) {
  case AIE2::G_STORE:
  case AIE2::G_LOAD:
    return AddressingModeInfo{MemI,
                              /*SrcDstOp=*/MemI.getOperand(0),
                              /*PtrOp=*/MemI.getOperand(1),
                              /*OffsetReg=*/{},
                              /*ImmediateOffset=*/APInt::getZero(32)};
  case AIE2::G_AIE_OFFSET_STORE:
  case AIE2::G_AIE_OFFSET_LOAD:
  case AIE2::G_AIE_OFFSET_ZEXTLOAD:
  case AIE2::G_AIE_OFFSET_SEXTLOAD:
    return createAddressModeInfo(MemI,
                                 /*SrcDstOp=*/MemI.getOperand(0),
                                 /*PtrOp=*/MemI.getOperand(1),
                                 /*OffsetReg=*/MemI.getOperand(2).getReg(),
                                 MRI);
  case AIE2::G_AIE_POSTINC_STORE:
    return createAddressModeInfo(MemI,
                                 /*SrcDstOp=*/MemI.getOperand(1),
                                 /*PtrOp=*/MemI.getOperand(2),
                                 /*OffsetReg=*/MemI.getOperand(3).getReg(),
                                 MRI);
  case AIE2::G_AIE_POSTINC_LOAD:
  case AIE2::G_AIE_POSTINC_SEXTLOAD:
  case AIE2::G_AIE_POSTINC_ZEXTLOAD:
    return createAddressModeInfo(MemI,
                                 /*SrcDstOp=*/MemI.getOperand(0),
                                 /*PtrOp=*/MemI.getOperand(2),
                                 /*OffsetReg=*/MemI.getOperand(3).getReg(),
                                 MRI);
  case AIE2::G_AIE_POSTINC_2D_STORE:
  case AIE2::G_AIE_POSTINC_2D_SEXTLOAD:
  case AIE2::G_AIE_POSTINC_2D_ZEXTLOAD:
  case AIE2::G_AIE_POSTINC_2D_LOAD: {
    MachineOperand &SrcDstOp =
        (MemI.getOpcode() == AIE2::G_AIE_POSTINC_2D_STORE) ? MemI.getOperand(2)
                                                           : MemI.getOperand(0);
    Register ModifierReg = MemI.getOperand(4).getReg();
    Register IncrReg = MemI.getOperand(5).getReg();
    Register SizeReg = MemI.getOperand(6).getReg();
    Register CountReg = MemI.getOperand(7).getReg();
    Register DReg =
        createDRegSequence(ModifierReg, IncrReg, SizeReg, CountReg, MRI);

    return createAddressModeInfo(MemI, SrcDstOp,
                                 /*PtrOp=*/MemI.getOperand(3),
                                 /*OffsetReg=*/DReg, MRI);
  } break;
  case AIE2::G_AIE_POSTINC_3D_STORE:
  case AIE2::G_AIE_POSTINC_3D_SEXTLOAD:
  case AIE2::G_AIE_POSTINC_3D_ZEXTLOAD:
  case AIE2::G_AIE_POSTINC_3D_LOAD: {
    MachineOperand &SrcDstOp =
        (MemI.getOpcode() == AIE2::G_AIE_POSTINC_3D_STORE) ? MemI.getOperand(3)
                                                           : MemI.getOperand(0);
    Register ModifierReg = MemI.getOperand(5).getReg();
    Register Incr1Reg = MemI.getOperand(6).getReg();
    Register Incr2Reg = MemI.getOperand(7).getReg();
    Register Size1Reg = MemI.getOperand(8).getReg();
    Register Count1Reg = MemI.getOperand(9).getReg();
    Register Size2Reg = MemI.getOperand(10).getReg();
    Register Count2Reg = MemI.getOperand(11).getReg();
    Register DReg =
        createDSRegSequence(ModifierReg, Incr1Reg, Incr2Reg, Size1Reg,
                            Count1Reg, Size2Reg, Count2Reg, MRI);
    return createAddressModeInfo(MemI, SrcDstOp,
                                 /*PtrOp=*/MemI.getOperand(4),
                                 /*OffsetReg=*/DReg, MRI);
  } break;
  }

  return {};
}

void AIE2InstructionSelector::addAddressingMode(MachineInstrBuilder &MIB,
                                                AddressingModeInfo &AMI,
                                                bool FitsImmediateRange,
                                                bool RenderFrameIndex,
                                                MachineRegisterInfo &MRI) {
  MachineInstr *PtrDef = MRI.getVRegDef(AMI.PtrOp.getReg());
  // Only render frame index if we are dealing with an instruction that supports
  // it (we get that information in RenderFrameIndex from the callee) and if the
  // AMI does not have an offset or modifier register, which indicates that the
  // instruction is neither pre-increment nor post-increment
  if (RenderFrameIndex && !AMI.OffsetReg &&
      PtrDef->getOpcode() == AIE2::G_FRAME_INDEX) {
    renderFrameIndex(MIB, *PtrDef, 1);
  } else if (FitsImmediateRange && AMI.ImmediateOffset) {
    MIB.addUse(AMI.PtrOp.getReg());
    MIB.addImm(AMI.ImmediateOffset->getSExtValue());
  } else if (AMI.OffsetReg) {
    MIB.addUse(AMI.PtrOp.getReg());
    MIB.addUse(*AMI.OffsetReg);
  } else {
    MIB.addUse(AMI.PtrOp.getReg());
  }
}

bool AIE2InstructionSelector::select512BitG_AIE_LOAD_UPS(
    MachineInstr &UPSI, LoadStoreOpcodes &LSO, AddressingModeInfo &AMI,
    Register DstReg, Register ShftReg, Register SignReg, bool ConstantSign,
    MachineRegisterInfo &MRI) {
  assert(LSO.OffsetOpcode &&
         "Expected an offset opcode for 512-bit VLDA.UPS!?");

  const TargetRegisterClass *RC = &AIE2::ACC512RegClass;
  Register Low512 = MRI.createVirtualRegister(RC);
  Register High512 = MRI.createVirtualRegister(RC);

  switch (AMI.MemI.getOpcode()) {
  case AIE2::G_LOAD:
  case AIE2::G_AIE_POSTINC_LOAD:
  case AIE2::G_AIE_POSTINC_2D_LOAD:
  case AIE2::G_AIE_POSTINC_3D_LOAD: {
    auto LoadHigher = MIB.buildInstr(*LSO.OffsetOpcode)
                          .addDef(High512)
                          .addUse(ShftReg)
                          .addUse(AMI.PtrOp.getReg())
                          .addImm(32); // Offset

    auto LoadLower = MIB.buildInstr(LSO.ISelOpcode, {Low512}, {});

    // We have to skip the first Def (the 1024-bit Dst-Reg)
    for (auto *Def = AMI.MemI.defs().begin() + 1; Def != AMI.MemI.defs().end();
         Def++)
      LoadLower.addDef(Def->getReg());

    LoadLower.addReg(ShftReg);

    addAddressingMode(LoadLower, AMI, LSO.FitsImmediateRange, false, MRI);

    addSplitMemOperands(AMI.MemI, LoadHigher, LoadLower, 0, 2);

    if (!ConstantSign)
      setUnsetCtrlRegister(*LoadHigher, *LoadLower, MRI, AIE2::crUPSSign,
                           SignReg);

    MIB.buildInstr(AIE2::REG_SEQUENCE, {DstReg}, {})
        .addReg(Low512)
        .addImm(AIE2::sub_512_lo)
        .addReg(High512)
        .addImm(AIE2::sub_512_hi);

    UPSI.eraseFromParent();
    AMI.MemI.eraseFromParent();

    return constrainSelectedInstRegOperands(*LoadLower, TII, TRI, RBI) &&
           constrainSelectedInstRegOperands(*LoadHigher, TII, TRI, RBI) &&
           RBI.constrainGenericRegister(DstReg, AIE2::ACC1024RegClass, MRI);
  }
  case AIE2::G_AIE_OFFSET_LOAD: {
    MachineInstrBuilder LoadHigher;
    if (LSO.FitsImmediateRange) {
      LoadHigher =
          MIB.buildInstr(*LSO.OffsetOpcode)
              .addDef(High512)
              .addUse(ShftReg)
              .addUse(AMI.PtrOp.getReg())
              .addImm(AMI.ImmediateOffset->getSExtValue() + 32); // Offset
    } else {
      // In this case we have to emit an PTR_ADD to evaluate the offset
      insertPtrAddForOffset(MRI, AMI.MemI);
      LoadHigher = MIB.buildInstr(*LSO.OffsetOpcode)
                       .addDef(High512)
                       .addUse(ShftReg)
                       .addUse(AMI.PtrOp.getReg())
                       .addImm(32); // Offset
    }

    auto LoadLower = MIB.buildInstr(LSO.ISelOpcode, {Low512}, {});

    LoadLower.addReg(ShftReg);

    LoadLower.addUse(AMI.PtrOp.getReg());
    if (LSO.FitsImmediateRange) {
      LoadLower.addImm(AMI.ImmediateOffset->getSExtValue()); // Offset
    } else {
      // In this case we have already inserted a PTR_ADD to add the offset to
      // the base pointer
      LoadLower.addImm(0); // Offset
    }

    addSplitMemOperands(AMI.MemI, LoadHigher, LoadLower, 0, 2);

    if (!ConstantSign)
      setUnsetCtrlRegister(*LoadHigher, *LoadLower, MRI, AIE2::crUPSSign,
                           SignReg);

    MIB.buildInstr(AIE2::REG_SEQUENCE, {DstReg}, {})
        .addReg(Low512)
        .addImm(AIE2::sub_512_lo)
        .addReg(High512)
        .addImm(AIE2::sub_512_hi);

    UPSI.eraseFromParent();
    AMI.MemI.eraseFromParent();

    return constrainSelectedInstRegOperands(*LoadLower, TII, TRI, RBI) &&
           constrainSelectedInstRegOperands(*LoadHigher, TII, TRI, RBI) &&
           RBI.constrainGenericRegister(DstReg, AIE2::ACC1024RegClass, MRI);
  }
  default:
    return false;
  }
}

bool AIE2InstructionSelector::selectG_AIE_LOAD_UPS(MachineInstr &UPSI,
                                                   MachineRegisterInfo &MRI) {

  // First use is the G_INTRINSIC_W_SIDE_EFFECTS ID
  Register LoadResult = (std::next(UPSI.uses().begin()))->getReg();
  MachineInstr *LoadOp = getDefIgnoringCopiesAndBitcasts(LoadResult, MRI);

  assert(LoadOp && "Expected SSA.");

  // Do not try to combine if one of the load's defs is used by another
  // instruction between the load and the VUPS or if there is a store
  // between the load and the VUPS.
  if (!canDelayMemOp(*LoadOp, UPSI, MRI))
    return false;

  if (!canCombineSRSUPS(*LoadOp, UPSI) ||
      LoadOp->getParent() != UPSI.getParent() || !MRI.hasOneUse(LoadResult))
    return false;

  std::optional<AddressingModeInfo> AMI =
      getOrDefineAddressingRegister(*LoadOp, MRI);
  if (!AMI)
    return false;

  Register DstReg = UPSI.getOperand(0).getReg();
  // In this case of G_INTRINSIC_W_SIDE_EFFECTS operand 1 is target intrinsic
  // In this case the operand 2 is the source register which is the loaded value
  Register ShftReg = UPSI.getOperand(3).getReg();
  Register SignReg = UPSI.getOperand(4).getReg();

  std::optional<LoadStoreOpcodes> LSO;
  bool ConstantSign = false;
  if (auto SignVal = getIConstantVRegValWithLookThrough(SignReg, MRI)) {
    // SignVal = 1 for signed and 0 for dynamically signed
    LSO = getCombinedOpcodeSRSUPS(AMI->MemI, UPSI, AMI->ImmediateOffset,
                                  SignVal.value().Value == 0x1);
    ConstantSign = true;
  } else {
    LSO = getCombinedOpcodeSRSUPS(AMI->MemI, UPSI, AMI->ImmediateOffset, false);
  }

  assert(LSO && "Unexpected VLDA.UPS combine failure");

  if (MRI.getType(LoadResult).getSizeInBits() == 512) {
    return select512BitG_AIE_LOAD_UPS(UPSI, *LSO, *AMI, DstReg, ShftReg,
                                      SignReg, ConstantSign, MRI);
  }

  auto NewInstr = MIB.buildInstr(LSO->ISelOpcode);

  NewInstr.addDef(DstReg);
  // Skip first def, which is the value directly fed into the UPS unit
  for (auto *Def = std::next(AMI->MemI.defs().begin());
       Def != AMI->MemI.defs().end(); ++Def)
    NewInstr.addDef(Def->getReg());

  NewInstr.addUse(ShftReg);

  addAddressingMode(NewInstr, *AMI, LSO->FitsImmediateRange, false, MRI);

  NewInstr.cloneMemRefs(AMI->MemI);

  if (!ConstantSign)
    setUnsetCtrlRegister(*NewInstr, MRI, AIE2::crUPSSign, SignReg);

  UPSI.eraseFromParent();
  AMI->MemI.eraseFromParent();
  return constrainSelectedInstRegOperands(*NewInstr.getInstr(), TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectVUPS(MachineInstr &I,
                                         MachineRegisterInfo &MRI) {
  // First try to match UPS combine
  if (selectG_AIE_LOAD_UPS(I, MRI))
    return true;

  Register DstReg = I.getOperand(0).getReg();
  // In this case of G_INTRINSIC_W_SIDE_EFFECTS operand 1 is target intrinsic
  Register SrcReg = I.getOperand(2).getReg();
  Register ShftReg = I.getOperand(3).getReg();
  Register SignReg = I.getOperand(4).getReg();

  if (auto SignVal = getIConstantVRegValWithLookThrough(SignReg, MRI)) {
    // Handle constant sign through instruction patterns
    return selectImpl(I, *CoverageInfo);
  }

  unsigned OpCode = getOpCode(cast<GIntrinsic>(I).getIntrinsicID());
  MachineInstrBuilder MI =
      MIB.buildInstr(OpCode, {DstReg}, {}).addReg(SrcReg).addReg(ShftReg);

  setUnsetCtrlRegister(*MI, MRI, AIE2::crUPSSign, SignReg);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectVSRS(MachineInstr &I,
                                         MachineRegisterInfo &MRI) {

  Register DstReg = I.getOperand(0).getReg();
  // In this case of G_INTRINSIC_W_SIDE_EFFECTS operand 1 is target intrinsic
  Register SrcReg = I.getOperand(2).getReg();
  Register ShftReg = I.getOperand(3).getReg();
  Register SignReg = I.getOperand(4).getReg();

  if (auto SignVal = getIConstantVRegValWithLookThrough(SignReg, MRI)) {
    // Handle constant sign through instruction patterns
    return selectImpl(I, *CoverageInfo);
  }

  unsigned OpCode = getOpCode(cast<GIntrinsic>(I).getIntrinsicID());
  MachineInstrBuilder MI =
      MIB.buildInstr(OpCode, {DstReg}, {}).addReg(SrcReg).addReg(ShftReg);

  setUnsetCtrlRegister(*MI, MRI, AIE2::crSRSSign, SignReg);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectVEXTRACT(MachineInstr &I,
                                             MachineRegisterInfo &MRI) {

  Register DstReg = I.getOperand(0).getReg();
  // In this case of G_INTRINSIC operand 1 is target intrinsic
  Register SrcReg = I.getOperand(2).getReg();
  Register LaneReg = I.getOperand(3).getReg();
  Register SignReg = I.getOperand(4).getReg();

  if (auto SignVal = getIConstantVRegValWithLookThrough(SignReg, MRI)) {
    // Handle constant sign through instruction patterns
    return selectImpl(I, *CoverageInfo);
  }

  unsigned OpCode = getOpCode(cast<GIntrinsic>(I).getIntrinsicID());
  MachineInstrBuilder MI =
      MIB.buildInstr(OpCode, {DstReg}, {}).addReg(SrcReg).addReg(LaneReg);

  setUnsetCtrlRegister(*MI, MRI, AIE2::crVaddSign, SignReg);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectVCompare(MachineInstr &I,
                                             MachineRegisterInfo &MRI) {

  Register CmpReg = I.getOperand(0).getReg();
  // In this case of G_INTRINSIC operand 1 is target intrinsic
  Register Src1Reg = I.getOperand(2).getReg();
  Register Src2Reg = I.getOperand(3).getReg();
  Register SignReg = I.getOperand(4).getReg();

  // Handle constant sign through instruction patterns
  if (selectImpl(I, *CoverageInfo)) {
    return true;
  }

  unsigned OpCode = getOpCode(cast<GIntrinsic>(I).getIntrinsicID());
  MachineInstrBuilder MI =
      MIB.buildInstr(OpCode, {CmpReg}, {}).addReg(Src1Reg).addReg(Src2Reg);

  setUnsetCtrlRegister(*MI, MRI, AIE2::crVaddSign, SignReg);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectVSUB_MIN_MAX(MachineInstr &I,
                                                 MachineRegisterInfo &MRI) {

  Register DstReg = I.getOperand(0).getReg();
  Register CmpReg = I.getOperand(1).getReg();
  // In this case of G_INTRINSIC operand 2 is target intrinsic
  Register Src1Reg = I.getOperand(3).getReg();
  Register Src2Reg = I.getOperand(4).getReg();
  Register SignReg = I.getOperand(5).getReg();

  if (auto SignVal = getIConstantVRegValWithLookThrough(SignReg, MRI)) {
    // Handle constant sign through instruction patterns
    return selectImpl(I, *CoverageInfo);
  }

  unsigned OpCode = getOpCode(cast<GIntrinsic>(I).getIntrinsicID());
  MachineInstrBuilder MI = MIB.buildInstr(OpCode, {DstReg, CmpReg}, {})
                               .addReg(Src1Reg)
                               .addReg(Src2Reg);

  setUnsetCtrlRegister(*MI, MRI, AIE2::crVaddSign, SignReg);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectCascadeStreamInsn(MachineInstr &I,
                                                      MachineRegisterInfo &MRI,
                                                      bool isWrite) {

  Register CascadeReg = I.getOperand(isWrite ? 1 : 0).getReg();
  Register EnableReg = I.getOperand(I.getNumOperands() - 1).getReg();

  MachineInstrBuilder MI;
  unsigned OpCode = getOpCode(cast<GIntrinsic>(I).getIntrinsicID());
  if (isWrite)
    MI = MIB.buildInstr(OpCode, {}, {}).addReg(CascadeReg);
  else
    MI = MIB.buildInstr(OpCode, {CascadeReg}, {});

  setUnsetCtrlRegister(*MI, MRI, (isWrite ? AIE2::crMCDEn : AIE2::crSCDEn),
                       EnableReg, 1);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

Register AIE2InstructionSelector::createDRegSequence(Register ModifierReg,
                                                     Register IncrReg,
                                                     Register SizeReg,
                                                     Register CountReg,
                                                     MachineRegisterInfo &MRI) {

  Register DstDReg = MRI.createVirtualRegister(&AIE2::eDRegClass);

  MachineInstrBuilder MI =
      MIB.buildInstr(TargetOpcode::REG_SEQUENCE, {DstDReg}, {})
          .addReg(ModifierReg)
          .addImm(AIE2::sub_mod)
          .addReg(SizeReg)
          .addImm(AIE2::sub_dim_size)
          .addReg(IncrReg)
          .addImm(AIE2::sub_dim_stride)
          .addReg(CountReg)
          .addImm(AIE2::sub_dim_count);

  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eMRegClass,
                           MI->getOperand(1));
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eDJRegClass,
                           MI->getOperand(5));
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eDNRegClass,
                           MI->getOperand(3));
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eDCRegClass,
                           MI->getOperand(7));

  return MI.getReg(0);
}
Register
AIE2InstructionSelector::createSparseRegSequence(Register Vec, Register Mask,
                                                 MachineRegisterInfo &MRI) {
  Register DstDReg = MRI.createVirtualRegister(&AIE2::SPARSEVEC640RegClass);
  MachineInstrBuilder MI =
      MIB.buildInstr(TargetOpcode::REG_SEQUENCE, {DstDReg}, {})
          .addReg(Vec)
          .addImm(AIE2::sub_sparse_x)
          .addReg(Mask)
          .addImm(AIE2::sub_sparse_q);
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::VEC512RegClass,
                           MI->getOperand(1));
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::VEC128RegClass,
                           MI->getOperand(3));
  return MI.getReg(0);
}

Register AIE2InstructionSelector::createDSRegSequence(
    Register ModifierReg, Register Incr1Reg, Register Incr2Reg,
    Register Size1Reg, Register Count1Reg, Register Size2Reg,
    Register Count2Reg, MachineRegisterInfo &MRI) {

  Register DstDSReg = MRI.createVirtualRegister(&AIE2::eDSRegClass);

  MachineInstrBuilder MI =
      MIB.buildInstr(TargetOpcode::REG_SEQUENCE, {DstDSReg}, {})
          .addReg(ModifierReg)
          .addImm(AIE2::sub_mod)
          .addReg(Size1Reg)
          .addImm(AIE2::sub_dim_size)
          .addReg(Incr1Reg)
          .addImm(AIE2::sub_dim_stride)
          .addReg(Count1Reg)
          .addImm(AIE2::sub_dim_count)
          .addReg(Size2Reg)
          .addImm(AIE2::sub_hi_dim_then_sub_dim_size)
          .addReg(Incr2Reg)
          .addImm(AIE2::sub_hi_dim_then_sub_dim_stride)
          .addReg(Count2Reg)
          .addImm(AIE2::sub_hi_dim_then_sub_dim_count);

  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eMRegClass,
                           MI->getOperand(1));
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eDJRegClass,
                           MI->getOperand(5));
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eDJRegClass,
                           MI->getOperand(11));
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eDNRegClass,
                           MI->getOperand(3));
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eDCRegClass,
                           MI->getOperand(7));
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eDNRegClass,
                           MI->getOperand(9));
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::eDCRegClass,
                           MI->getOperand(13));

  return MI.getReg(0);
}

bool AIE2InstructionSelector::selectAddrInsn(MachineInstr &I,
                                             MachineRegisterInfo &MRI) {

  Register PtrOutReg = I.getOperand(0).getReg();
  Register CountOut1Reg = I.getOperand(1).getReg();

  switch (cast<GIntrinsic>(I).getIntrinsicID()) {
  case Intrinsic::aie2_add_2d: {

    Register PtrInReg = I.getOperand(3).getReg();
    Register OffsetReg = I.getOperand(4).getReg();
    Register IncrReg = I.getOperand(5).getReg();
    Register SizeReg = I.getOperand(6).getReg();
    Register CountIn1Reg = I.getOperand(7).getReg();

    if (!RBI.constrainGenericRegister(CountOut1Reg, AIE2::eDCRegClass, MRI))
      return false;

    Register DReg =
        createDRegSequence(OffsetReg, IncrReg, SizeReg, CountIn1Reg, MRI);

    MachineInstrBuilder MI =
        MIB.buildInstr(AIE2::PADDA_2D, {PtrOutReg, CountOut1Reg}, {})
            .addReg(PtrInReg)
            .addReg(DReg);

    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
  }
  case Intrinsic::aie2_add_3d: {

    Register CountOut2Reg = I.getOperand(2).getReg();
    Register PtrInReg = I.getOperand(4).getReg();
    Register OffsetReg = I.getOperand(5).getReg();
    Register Incr1Reg = I.getOperand(6).getReg();
    Register Incr2Reg = I.getOperand(7).getReg();
    Register Size1Reg = I.getOperand(8).getReg();
    Register CountIn1Reg = I.getOperand(9).getReg();
    Register Size2Reg = I.getOperand(10).getReg();
    Register CountIn2Reg = I.getOperand(11).getReg();

    if (!RBI.constrainGenericRegister(CountOut1Reg, AIE2::eDCRegClass, MRI) ||
        !RBI.constrainGenericRegister(CountOut2Reg, AIE2::eDCRegClass, MRI))
      return false;

    Register DReg =
        createDSRegSequence(OffsetReg, Incr1Reg, Incr2Reg, Size1Reg,
                            CountIn1Reg, Size2Reg, CountIn2Reg, MRI);

    MachineInstrBuilder MI =
        MIB.buildInstr(AIE2::PADDA_3D, {PtrOutReg, CountOut1Reg, CountOut2Reg},
                       {})
            .addReg(PtrInReg)
            .addReg(DReg);
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
  }
  default:
    llvm_unreachable("Unexpected addressing intrinsic id");
  }
}

// Build Instruction to get control register
bool AIE2InstructionSelector::selectGetControlRegister(
    MachineInstr &I, MachineRegisterInfo &MRI) {

  Register DstReg = I.getOperand(0).getReg();
  // In this case of G_INTRINSIC operand 1 is target intrinsic
  Register IdxReg = I.getOperand(2).getReg();
  Register CtrlReg;

  // Check if the argument is constant for register map index.
  if (auto Idx = getIConstantVRegValWithLookThrough(IdxReg, MRI))
    CtrlReg = TRI.getControlRegister(Idx->Value.getZExtValue());
  else
    llvm_unreachable("Expected const value for control register map index.");

  if (!RBI.constrainGenericRegister(DstReg, AIE2::eRCRRegClass, MRI))
    return false;

  auto CopyInstr =
      MIB.buildInstr(TargetOpcode::COPY, {DstReg}, {}).addReg(CtrlReg);
  if (!selectCopy(*CopyInstr, MRI)) {
    return false;
  }
  I.eraseFromParent();
  return true;
}

// Build Instruction to set control register
bool AIE2InstructionSelector::selectSetControlRegister(
    MachineInstr &I, MachineRegisterInfo &MRI) {

  Register IdxReg = I.getOperand(1).getReg();
  Register SrcReg = I.getOperand(2).getReg();
  Register CtrlReg;

  // Check if the argument is constant for register map index.
  if (auto Idx = getIConstantVRegValWithLookThrough(IdxReg, MRI))
    CtrlReg = TRI.getControlRegister(Idx->Value.getZExtValue());
  else
    llvm_unreachable("Expected const value for control register map index.");

  // Handle const input val for control regs.
  if (auto Src = getIConstantVRegValWithLookThrough(SrcReg, MRI)) {
    unsigned SrcConstVal = Src->Value.getZExtValue();
    /* Modulo by width of control regs.
       To constrain the max possible value in the register
       according to register width.
    */
    switch (CtrlReg) {
    case AIE2::crSat:
      SrcConstVal = SrcConstVal % (1 << 2);
      break;
    case AIE2::crRnd:
      SrcConstVal = SrcConstVal % (1 << 4);
      break;
    case AIE2::crF2FMask:
    case AIE2::crF2IMask:
    case AIE2::crFPMask:
      SrcConstVal = SrcConstVal % (1 << 5);
      break;
    default:
      break;
    }

    MachineInstrBuilder MI =
        MIB.buildInstr(AIE2::MOV_scalar_imm10_pseudo, {CtrlReg}, {})
            .addImm(SrcConstVal);
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
  }

  auto CopyInstr =
      MIB.buildInstr(TargetOpcode::COPY, {CtrlReg}, {}).addReg(SrcReg);
  if (!selectCopy(*CopyInstr, MRI))
    return false;

  I.eraseFromParent();
  return true;
}

bool AIE2InstructionSelector::selectWriteTM(MachineInstr &I,
                                            MachineRegisterInfo &MRI) {
  Register Value = I.getOperand(1).getReg();
  Register Ptr = I.getOperand(2).getReg();

  MachineMemOperand *MMO = getTileMemOperand(I, MachineMemOperand::MOStore);
  MachineInstrBuilder MI =
      MIB.buildInstr(AIE2::ST_TM, {}, {Value, Ptr}).addMemOperand(MMO);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectReadTM(MachineInstr &I,
                                           MachineRegisterInfo &MRI) {
  Register Dest = I.getOperand(0).getReg();
  Register Ptr = I.getOperand(2).getReg();

  MachineMemOperand *MMO = getTileMemOperand(I, MachineMemOperand::MOLoad);
  MachineInstrBuilder MI =
      MIB.buildInstr(AIE2::LDA_TM, {Dest}, {Ptr}).addMemOperand(MMO);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

unsigned deriveRegBankID(Register Reg, const MachineRegisterInfo &MRI,
                         const RegisterBankInfo &RBI) {
  const RegisterBank *RB = MRI.getRegBankOrNull(Reg);
  if (RB) {
    return RB->getID();
  }
  const TargetRegisterClass *RC = MRI.getRegClassOrNull(Reg);
  if (RC) {
    return RBI.getRegBankFromRegClass(*RC, MRI.getType(Reg)).getID();
  }
  llvm_unreachable("Cannot derive RegBankID from Register");
}

LoadStoreOpcodes AIE2InstructionSelector::getLoadStoreOpcode(
    const MachineInstr &I, const MachineRegisterInfo &MRI,
    const RegisterBankInfo &RBI, std::optional<APInt> Offset) {
  const bool AlwaysFitsImmediateRange = true;
  const bool NoImmediate = false;

  unsigned ISelOpcode;
  bool FitsImmediateRange = false;

  switch (I.getOpcode()) {
  case AIE2::G_STORE:
    if (getLoadStoreSize(I) == 512) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID) {
        return {/*ISelOpcode=*/AIE2::VST_dmw_sts_am_ag_idx_imm,
                AlwaysFitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_am_ag_idx_imm};
      }
      if (RBID == AIE2::VRegBankID) {
        return {/*ISelOpcode=*/AIE2::VST_dmw_sts_w_ag_idx_imm,
                AlwaysFitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_w_ag_idx_imm};
      }
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 256) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      MachineInstr *PtrDef = MRI.getVRegDef(I.getOperand(1).getReg());
      if (PtrDef->getOpcode() == AIE2::G_FRAME_INDEX) {
        if (RBID == AIE2::AccRegBankID) {
          return {/*ISelOpcode=*/AIE2::VST_dmw_sts_am_ag_spill, NoImmediate,
                  /*OffsetOpcode=*/{}};
        }
        if (RBID == AIE2::VRegBankID) {
          return {/*ISelOpcode=*/AIE2::VST_dmw_sts_w_ag_spill, NoImmediate,
                  /*OffsetOpcode=*/{}};
        }
        llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
      } else {
        if (RBID == AIE2::AccRegBankID) {
          return {/*ISelOpcode=*/AIE2::VST_dmw_sts_am_ag_idx_imm,
                  AlwaysFitsImmediateRange,
                  /*OffsetOpcode=*/AIE2::VST_dmw_sts_am_ag_idx_imm};
        }
        if (RBID == AIE2::VRegBankID) {
          return {/*ISelOpcode=*/AIE2::VST_dmw_sts_w_ag_idx_imm,
                  AlwaysFitsImmediateRange,
                  /*OffsetOpcode=*/AIE2::VST_dmw_sts_w_ag_idx_imm};
        }
        llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
      }
    }
    if (getLoadStoreSize(I) == 128) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      MachineInstr *PtrDef = MRI.getVRegDef(I.getOperand(1).getReg());
      if (PtrDef->getOpcode() == AIE2::G_FRAME_INDEX) {
        if (RBID == AIE2::VRegBankID) {
          return {/*ISelOpcode=*/AIE2::ST_dmv_sts_q_ag_spill, NoImmediate,
                  /*OffsetOpcode=*/{}};
        }
        llvm_unreachable("Vector type not VRegBank");
      } else {
        if (RBID == AIE2::VRegBankID) {
          return {/*ISelOpcode=*/AIE2::ST_dmv_sts_q_ag_idx_imm,
                  AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
        }
        llvm_unreachable("Vector type not VRegBank");
      }
    }
    break;
  case AIE2::G_AIE_OFFSET_STORE:
    if (getLoadStoreSize(I) == 512) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID) {
        FitsImmediateRange = checkImmediateRangeSplitting<6, 32, 32>(Offset);
        return {/*ISelOpcode=*/AIE2::VST_dmw_sts_am_ag_idx_imm,
                FitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_am_ag_idx_imm};
      }
      if (RBID == AIE2::VRegBankID) {
        FitsImmediateRange = checkImmediateRangeSplitting<6, 32, 32>(Offset);
        return {/*ISelOpcode=*/AIE2::VST_dmw_sts_w_ag_idx_imm,
                FitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_w_ag_idx_imm};
      }
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 256) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID) {
        FitsImmediateRange = checkImmediateRange<6, 32>(Offset);
        ISelOpcode = FitsImmediateRange ? AIE2::VST_dmw_sts_am_ag_idx_imm
                                        : AIE2::VST_dmw_sts_am_ag_idx;
        return {ISelOpcode, FitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_am_ag_idx_imm};
      }
      if (RBID == AIE2::VRegBankID) {
        FitsImmediateRange = checkImmediateRange<6, 32>(Offset);
        ISelOpcode = FitsImmediateRange ? AIE2::VST_dmw_sts_w_ag_idx_imm
                                        : AIE2::VST_dmw_sts_w_ag_idx;
        return {ISelOpcode, FitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_w_ag_idx_imm};
      }
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 128) {
      FitsImmediateRange = checkImmediateRange<6, 16>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::ST_dmv_sts_q_ag_idx_imm
                                      : AIE2::ST_dmv_sts_q_ag_idx;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 20 || getLoadStoreSize(I) == 32) {
      FitsImmediateRange = checkImmediateRange<6, 4>(Offset);
      ISelOpcode =
          FitsImmediateRange ? AIE2::ST_dms_sts_idx_imm : AIE2::ST_dms_sts_idx;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 16) {
      FitsImmediateRange = checkImmediateRange<3, 1>(Offset);
      ISelOpcode =
          FitsImmediateRange ? AIE2::ST_S16_ag_idx_imm : AIE2::ST_S16_ag_idx;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      FitsImmediateRange = checkImmediateRange<3, 1>(Offset);
      ISelOpcode =
          FitsImmediateRange ? AIE2::ST_S8_ag_idx_imm : AIE2::ST_S8_ag_idx;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_AIE_POSTINC_STORE:
    if (getLoadStoreSize(I) == 128) {
      unsigned RBID = deriveRegBankID(I.getOperand(1).getReg(), MRI, RBI);
      if (RBID == AIE2::VRegBankID) {
        FitsImmediateRange = checkImmediateRange<7, 16>(Offset);
        ISelOpcode = FitsImmediateRange ? AIE2::ST_dmv_sts_q_ag_pstm_nrm_imm
                                        : AIE2::ST_dmv_sts_q_ag_pstm_nrm;
        return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
      }
      llvm_unreachable("Vector type not in VRegBank");
    }
    if (getLoadStoreSize(I) == 256 || getLoadStoreSize(I) == 512) {
      unsigned RBID = deriveRegBankID(I.getOperand(1).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID) {
        FitsImmediateRange = checkImmediateRange<7, 32>(Offset);
        ISelOpcode = FitsImmediateRange ? AIE2::VST_dmw_sts_am_ag_pstm_nrm_imm
                                        : AIE2::VST_dmw_sts_am_ag_pstm_nrm;
        return {ISelOpcode, FitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_am_ag_idx_imm};
      }
      if (RBID == AIE2::VRegBankID) {
        FitsImmediateRange = checkImmediateRange<7, 32>(Offset);
        ISelOpcode = FitsImmediateRange ? AIE2::VST_dmw_sts_w_ag_pstm_nrm_imm
                                        : AIE2::VST_dmw_sts_w_ag_pstm_nrm;
        return {ISelOpcode, FitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_w_ag_idx_imm};
      }
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 20 || getLoadStoreSize(I) == 32) {
      FitsImmediateRange = checkImmediateRange<7, 4>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::ST_dms_sts_pstm_nrm_imm
                                      : AIE2::ST_dms_sts_pstm_nrm;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 16) {
      FitsImmediateRange = checkImmediateRange<4, 1>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::ST_S16_ag_pstm_nrm_imm
                                      : AIE2::ST_S16_ag_pstm_nrm;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      FitsImmediateRange = checkImmediateRange<4, 1>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::ST_S8_ag_pstm_nrm_imm
                                      : AIE2::ST_S8_ag_pstm_nrm;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_AIE_POSTINC_2D_STORE:
    if (getLoadStoreSize(I) == 256 || getLoadStoreSize(I) == 512) {
      unsigned RBID = deriveRegBankID(I.getOperand(2).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID)
        return {/*ISelOpcode=*/AIE2::VST_2D_dmw_sts_am, NoImmediate,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_am_ag_idx_imm};
      if (RBID == AIE2::VRegBankID)
        return {/*ISelOpcode=*/AIE2::VST_2D_dmw_sts_w, NoImmediate,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_w_ag_idx_imm};
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 128) {
      unsigned RBID = deriveRegBankID(I.getOperand(2).getReg(), MRI, RBI);
      if (RBID == AIE2::VRegBankID) {
        return {/*ISelOpcode=*/AIE2::VST_2D_128, NoImmediate,
                /*OffsetOpcode=*/{}};
      }
      llvm_unreachable("128-bit vectors have to be in VRegBank");
    }
    if (getLoadStoreSize(I) == 20 || getLoadStoreSize(I) == 32) {
      return {/*ISelOpcode=*/AIE2::ST_2D_dms_sts, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 16) {
      return {/*ISelOpcode=*/AIE2::ST_2D_S16, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      return {/*ISelOpcode=*/AIE2::ST_2D_S8, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_AIE_POSTINC_3D_STORE:
    if (getLoadStoreSize(I) == 256 || getLoadStoreSize(I) == 512) {
      unsigned RBID = deriveRegBankID(I.getOperand(3).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID)
        return {/*ISelOpcode=*/AIE2::VST_3D_dmw_sts_am, NoImmediate,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_am_ag_idx_imm};
      if (RBID == AIE2::VRegBankID)
        return {/*ISelOpcode=*/AIE2::VST_3D_dmw_sts_w, NoImmediate,
                /*OffsetOpcode=*/AIE2::VST_dmw_sts_w_ag_idx_imm};
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 128) {
      unsigned RBID = deriveRegBankID(I.getOperand(3).getReg(), MRI, RBI);
      if (RBID == AIE2::VRegBankID) {
        return {/*ISelOpcode=*/AIE2::VST_3D_128, NoImmediate,
                /*OffsetOpcode=*/{}};
      }
      llvm_unreachable("128-bit vectors have to be in VRegBank");
    }
    if (getLoadStoreSize(I) == 20 || getLoadStoreSize(I) == 32) {
      return {/*ISelOpcode=*/AIE2::ST_3D_dms_sts, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 16) {
      return {/*ISelOpcode=*/AIE2::ST_3D_S16, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      return {/*ISelOpcode=*/AIE2::ST_3D_S8, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_LOAD:
    if (getLoadStoreSize(I) == 512) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID) {
        return {/*ISelOpcode=*/AIE2::VLDA_dmw_lda_am_ag_idx_imm,
                AlwaysFitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VLDA_dmw_lda_am_ag_idx_imm};
      }
      if (RBID == AIE2::VRegBankID) {
        return {/*ISelOpcode=*/AIE2::VLD_idx_imm_3x32_pseudo,
                AlwaysFitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VLD_idx_imm_3x32_pseudo};
      }
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 256) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      MachineInstr *PtrDef = MRI.getVRegDef(I.getOperand(1).getReg());
      if (PtrDef->getOpcode() == AIE2::G_FRAME_INDEX) {
        if (RBID == AIE2::AccRegBankID) {
          return {/*ISelOpcode=*/AIE2::VLDA_dmw_lda_am_ag_spill, NoImmediate,
                  /*OffsetOpcode=*/{}};
        }
        if (RBID == AIE2::VRegBankID) {
          return {/*ISelOpcode=*/AIE2::VLDA_dmw_lda_w_ag_spill, NoImmediate,
                  /*OffsetOpcode=*/{}};
        }
        llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
      } else {
        if (RBID == AIE2::AccRegBankID) {
          return {/*ISelOpcode=*/AIE2::VLDA_dmw_lda_am_ag_idx_imm,
                  AlwaysFitsImmediateRange,
                  /*OffsetOpcode=*/AIE2::VLDA_dmw_lda_am_ag_idx_imm};
        }
        if (RBID == AIE2::VRegBankID) {
          return {/*ISelOpcode=*/AIE2::VLD_idx_imm_3x32_pseudo,
                  AlwaysFitsImmediateRange,
                  /*OffsetOpcode=*/{}};
        }
        llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
      }
    }
    if (getLoadStoreSize(I) == 128) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      MachineInstr *PtrDef = MRI.getVRegDef(I.getOperand(1).getReg());
      if (RBID == AIE2::VRegBankID) {
        if (PtrDef->getOpcode() == AIE2::G_FRAME_INDEX)
          return {/*ISelOpcode=*/AIE2::LDA_dmv_lda_q_ag_spill, NoImmediate,
                  /*OffsetOpcode=*/{}};
        return {/*ISelOpcode=*/AIE2::VLDA_128, NoImmediate,
                /*OffsetOpcode=*/{}};
      }
      llvm_unreachable("128-bit vectors have to be loaded into VRegBank");
    }
    break;
  case AIE2::G_AIE_OFFSET_LOAD:
    if (getLoadStoreSize(I) == 512) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID) {
        FitsImmediateRange = checkImmediateRangeSplitting<6, 32, 32>(Offset);
        return {/*ISelOpcode=*/AIE2::VLDA_dmw_lda_am_ag_idx_imm,
                FitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VLDA_dmw_lda_am_ag_idx_imm};
      }
      if (RBID == AIE2::VRegBankID) {
        unsigned OffsetOpcode;
        // First try if the Instruction can be selected as multi-slot offset
        // load
        if (checkImmediateRangeSplitting<3, 32, 32>(Offset)) {
          FitsImmediateRange = true;
          ISelOpcode = OffsetOpcode = AIE2::VLD_idx_imm_3x32_pseudo;
        } else if (checkImmediateRange<3, 32>(Offset)) {
          // When Offset is positive and one of the offset is in range of SlotB
          ISelOpcode = AIE2::VLD_idx_imm_3x32_pseudo;
          OffsetOpcode = AIE2::VLDA_dmw_lda_w_ag_idx_imm;
          FitsImmediateRange = true;
        } else if (Offset.has_value() && (*Offset).isNegative() &&
                   checkImmediateRange<3, 32>((*Offset) + 32)) {
          // When Offset is negative and one of the offset is in range of SlotB
          ISelOpcode = AIE2::VLDA_dmw_lda_w_ag_idx_imm;
          OffsetOpcode = AIE2::VLD_idx_imm_3x32_pseudo;
          FitsImmediateRange = true;
        } else {
          // When Offset & Offset+32 are out of range of SlotB
          FitsImmediateRange = checkImmediateRangeSplitting<6, 32, 32>(Offset);
          ISelOpcode = OffsetOpcode = AIE2::VLDA_dmw_lda_w_ag_idx_imm;
        }
        return {/*ISelOpcode=*/ISelOpcode, FitsImmediateRange,
                /*OffsetOpcode=*/OffsetOpcode};
      }
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 256) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID) {
        FitsImmediateRange = checkImmediateRange<6, 32>(Offset);
        ISelOpcode = FitsImmediateRange ? AIE2::VLDA_dmw_lda_am_ag_idx_imm
                                        : AIE2::VLDA_dmw_lda_am_ag_idx;
        return {ISelOpcode, FitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VLDA_dmw_lda_am_ag_idx_imm};
      }
      if (RBID == AIE2::VRegBankID) {
        // First try if the Instruction can be selected as multi-slot offset
        // load
        if (checkImmediateRange<3, 32>(Offset)) {
          FitsImmediateRange = true;
          ISelOpcode = AIE2::VLD_idx_imm_3x32_pseudo;
        } else {
          FitsImmediateRange = checkImmediateRange<6, 32>(Offset);
          ISelOpcode = FitsImmediateRange ? AIE2::VLDA_dmw_lda_w_ag_idx_imm
                                          : AIE2::VLD_idx_pseudo;
        }
        return {ISelOpcode, FitsImmediateRange,
                /*OffsetOpcode=*/{}};
      }
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 128) {
      /* FIXME Currently For non immediate addressing VLDB_128_ag_idx is
       * selected, there should be a better way to decide (some heuristics)
       * which instruction to select between the available LDA_dmv_lda_q_ag_idx
       * which has 128-bit destination operand vs VLDB_128_ag_idx which has
       * 256-bit destination operand. */
      FitsImmediateRange = checkImmediateRange<6, 16>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::LDA_dmv_lda_q_ag_idx_imm
                                      : AIE2::VLDB_128_ag_idx;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 20 || getLoadStoreSize(I) == 32) {
      FitsImmediateRange = checkImmediateRange<6, 4>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::LDA_dms_lda_idx_imm
                                      : AIE2::LDA_dms_lda_idx;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    [[fallthrough]];
  case AIE2::G_AIE_OFFSET_SEXTLOAD:
    if (getLoadStoreSize(I) == 16) {
      FitsImmediateRange = checkImmediateRange<3, 1>(Offset);
      ISelOpcode =
          FitsImmediateRange ? AIE2::LDA_S16_ag_idx_imm : AIE2::LDA_S16_ag_idx;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      FitsImmediateRange = checkImmediateRange<3, 1>(Offset);
      ISelOpcode =
          FitsImmediateRange ? AIE2::LDA_S8_ag_idx_imm : AIE2::LDA_S8_ag_idx;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_AIE_OFFSET_ZEXTLOAD:
    if (getLoadStoreSize(I) == 16) {
      FitsImmediateRange = checkImmediateRange<3, 1>(Offset);
      ISelOpcode =
          FitsImmediateRange ? AIE2::LDA_U16_ag_idx_imm : AIE2::LDA_U16_ag_idx;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      FitsImmediateRange = checkImmediateRange<3, 1>(Offset);
      ISelOpcode =
          FitsImmediateRange ? AIE2::LDA_U8_ag_idx_imm : AIE2::LDA_U8_ag_idx;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_AIE_POSTINC_2D_LOAD:
    if (getLoadStoreSize(I) == 256 || getLoadStoreSize(I) == 512) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID)
        return {/*ISelOpcode=*/AIE2::VLDA_2D_dmw_lda_am, NoImmediate,
                /*OffsetOpcode=*/AIE2::VLDA_dmw_lda_am_ag_idx_imm};
      if (RBID == AIE2::VRegBankID)
        return {/*ISelOpcode=*/AIE2::VLD_2D_pseudo, NoImmediate,
                /*OffsetOpcode=*/AIE2::VLD_idx_imm_3x32_pseudo};
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 128) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::VRegBankID)
        return {/*ISelOpcode=*/AIE2::VLDB_2D_128, NoImmediate,
                /*OffsetOpcode=*/{}};
      llvm_unreachable("Vector type not in VRegBank");
    }
    if (getLoadStoreSize(I) == 20 || getLoadStoreSize(I) == 32) {
      return {/*ISelOpcode=*/AIE2::LDA_2D_dms_lda, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    [[fallthrough]];
  case AIE2::G_AIE_POSTINC_2D_SEXTLOAD:
    if (getLoadStoreSize(I) == 16) {
      return {/*ISelOpcode=*/AIE2::LDA_2D_S16_dmhb_lda, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      return {/*ISelOpcode=*/AIE2::LDA_2D_S8_dmhb_lda, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_AIE_POSTINC_2D_ZEXTLOAD:
    if (getLoadStoreSize(I) == 16) {
      return {/*ISelOpcode=*/AIE2::LDA_2D_U16_dmhb_lda, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      return {/*ISelOpcode=*/AIE2::LDA_2D_U8_dmhb_lda, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_AIE_POSTINC_3D_LOAD:
    if (getLoadStoreSize(I) == 256 || getLoadStoreSize(I) == 512) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID)
        return {/*ISelOpcode=*/AIE2::VLDA_3D_dmw_lda_am, NoImmediate,
                /*OffsetOpcode=*/AIE2::VLDA_dmw_lda_am_ag_idx_imm};
      if (RBID == AIE2::VRegBankID)
        return {/*ISelOpcode=*/AIE2::VLD_3D_pseudo, NoImmediate,
                /*OffsetOpcode=*/AIE2::VLD_idx_imm_3x32_pseudo};
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 128) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::VRegBankID)
        return {/*ISelOpcode=*/AIE2::VLDB_3D_128, NoImmediate,
                /*OffsetOpcode=*/{}};
      llvm_unreachable("Vector type not in VRegBank");
    }
    if (getLoadStoreSize(I) == 20 || getLoadStoreSize(I) == 32) {
      return {/*ISelOpcode=*/AIE2::LDA_3D_dms_lda, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    [[fallthrough]];
  case AIE2::G_AIE_POSTINC_3D_SEXTLOAD:
    if (getLoadStoreSize(I) == 16) {
      return {/*ISelOpcode=*/AIE2::LDA_3D_S16_dmhb_lda, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      return {/*ISelOpcode=*/AIE2::LDA_3D_S8_dmhb_lda, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_AIE_POSTINC_3D_ZEXTLOAD:
    if (getLoadStoreSize(I) == 16) {
      return {/*ISelOpcode=*/AIE2::LDA_3D_U16_dmhb_lda, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      return {/*ISelOpcode=*/AIE2::LDA_3D_U8_dmhb_lda, NoImmediate,
              /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_AIE_POSTINC_LOAD:
    if (getLoadStoreSize(I) == 256 || getLoadStoreSize(I) == 512) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::AccRegBankID) {
        FitsImmediateRange = checkImmediateRange<7, 32>(Offset);
        ISelOpcode = FitsImmediateRange ? AIE2::VLDA_dmw_lda_am_ag_pstm_nrm_imm
                                        : AIE2::VLDA_dmw_lda_am_ag_pstm_nrm;
        return {ISelOpcode, FitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VLDA_dmw_lda_am_ag_idx_imm};
      }
      if (RBID == AIE2::VRegBankID) {
        // First try if the Instruction can be selected as multi-slot offset
        // load
        if (checkImmediateRange<4, 32>(Offset)) {
          FitsImmediateRange = true;
          ISelOpcode = AIE2::VLD_pstm_imm_4x32_pseudo;
        } else {
          FitsImmediateRange = checkImmediateRange<7, 32>(Offset);
          ISelOpcode = FitsImmediateRange ? AIE2::VLDA_dmw_lda_w_ag_pstm_nrm_imm
                                          : AIE2::VLD_pstm_pseudo;
        }
        return {ISelOpcode, FitsImmediateRange,
                /*OffsetOpcode=*/AIE2::VLD_idx_imm_3x32_pseudo};
      }
      llvm_unreachable("Vector type not in AccRegBank nor VRegBank");
    }
    if (getLoadStoreSize(I) == 128) {
      unsigned RBID = deriveRegBankID(I.getOperand(0).getReg(), MRI, RBI);
      if (RBID == AIE2::VRegBankID) {
        /* FIXME Currently For non immediate pstm addressing
         * VLDB_dmv_ldb_ag_pstm_nrm is selected, there should be a better way
         * to decide (some heuristics) which instruction to select
         * between the available LDA_dmv_lda_q_ag_pstm_nrm which has
         * 128-bit destination operand vs VLDB_dmv_ldb_ag_pstm_nrm which
         * has 256-bit destination operand. */
        FitsImmediateRange = checkImmediateRange<7, 16>(Offset);
        ISelOpcode = FitsImmediateRange ? AIE2::LDA_dmv_lda_q_ag_pstm_nrm_imm
                                        : AIE2::VLDB_128_ag_pstm_nrm;
        return {ISelOpcode, FitsImmediateRange,
                /*OffsetOpcode=*/{}};
      }
      llvm_unreachable("Vector type not in VRegBank");
    }
    if (getLoadStoreSize(I) == 20 || getLoadStoreSize(I) == 32) {
      FitsImmediateRange = checkImmediateRange<7, 4>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::LDA_dms_lda_pstm_nrm_imm
                                      : AIE2::LDA_dms_lda_pstm_nrm;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    [[fallthrough]];
  case AIE2::G_AIE_POSTINC_SEXTLOAD:
    if (getLoadStoreSize(I) == 16) {
      FitsImmediateRange = checkImmediateRange<4, 1>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::LDA_S16_ag_pstm_nrm_imm
                                      : AIE2::LDA_S16_ag_pstm_nrm;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      FitsImmediateRange = checkImmediateRange<4, 1>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::LDA_S8_ag_pstm_nrm_imm
                                      : AIE2::LDA_S8_ag_pstm_nrm;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    break;
  case AIE2::G_AIE_POSTINC_ZEXTLOAD:
    if (getLoadStoreSize(I) == 16) {
      FitsImmediateRange = checkImmediateRange<4, 1>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::LDA_U16_ag_pstm_nrm_imm
                                      : AIE2::LDA_U16_ag_pstm_nrm;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    if (getLoadStoreSize(I) == 8) {
      FitsImmediateRange = checkImmediateRange<4, 1>(Offset);
      ISelOpcode = FitsImmediateRange ? AIE2::LDA_U8_ag_pstm_nrm_imm
                                      : AIE2::LDA_U8_ag_pstm_nrm;
      return {ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
    }
    break;
  default:
    break;
  }
  dbgs() << "Cannot select: " << I << "\n";
  llvm_unreachable("Invalid combined instruction");
}

std::optional<LoadStoreOpcodes>
getCombinedOpcodePACK(const MachineInstr &MemOp, const MachineInstr &CombOp,
                      std::optional<APInt> Immediate, bool IsSigned,
                      bool Is32Lanes) {
  const bool AlwaysFitsImmediateRange = true;

  if (CombOp.getOpcode() != AIE2::G_INTRINSIC_W_SIDE_EFFECTS ||
      (cast<GIntrinsic>(CombOp).getIntrinsicID() != Intrinsic::aie2_pack_I4_I8 &&
       cast<GIntrinsic>(CombOp).getIntrinsicID() != Intrinsic::aie2_pack_I8_I16))
    return {};

  assert(getLoadStoreSize(MemOp) == 256 && "Unexpected VST.PACK size");

  unsigned ISelOpcode;
  bool FitsImmediateRange = false;
  const bool NoImmediate = false;

  if (IsSigned) {
    switch (MemOp.getOpcode()) {
    case AIE2::G_STORE:
      if (Is32Lanes) {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_PACK_S8_S16_ag_idx_imm,
                                AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
      } else {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_PACK_S4_S8_ag_idx_imm,
                                AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
      }
      break;
    case AIE2::G_AIE_OFFSET_STORE:
      if (Is32Lanes) {
        FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
        ISelOpcode = FitsImmediateRange ? AIE2::VST_PACK_S8_S16_ag_idx_imm
                                        : AIE2::VST_PACK_S8_S16_ag_idx;
        return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                /*OffsetOpcode=*/{}};
      } else {
        FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
        ISelOpcode = FitsImmediateRange ? AIE2::VST_PACK_S4_S8_ag_idx_imm
                                        : AIE2::VST_PACK_S4_S8_ag_idx;
        return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                /*OffsetOpcode=*/{}};
      }
      break;
    case AIE2::G_AIE_POSTINC_STORE:
      FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
      if (Is32Lanes) {
        ISelOpcode = FitsImmediateRange ? AIE2::VST_PACK_S8_S16_ag_pstm_nrm_imm
                                        : AIE2::VST_PACK_S8_S16_ag_pstm_nrm;
        return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                /*OffsetOpcode=*/{}};
      } else {
        ISelOpcode = FitsImmediateRange ? AIE2::VST_PACK_S4_S8_ag_pstm_nrm_imm
                                        : AIE2::VST_PACK_S4_S8_ag_pstm_nrm;
        return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                /*OffsetOpcode=*/{}};
      }
      break;
    case AIE2::G_AIE_POSTINC_2D_STORE:
      if (Is32Lanes) {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_PACK_S8_S16,
                                NoImmediate,
                                /*OffsetOpcode=*/{}};
      } else {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_PACK_S4_S8,
                                NoImmediate,
                                /*OffsetOpcode=*/{}};
      }
      break;
    case AIE2::G_AIE_POSTINC_3D_STORE:
      if (Is32Lanes) {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_PACK_S8_S16,
                                NoImmediate,
                                /*OffsetOpcode=*/{}};
      } else {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_PACK_S4_S8,
                                NoImmediate,
                                /*OffsetOpcode=*/{}};
      }
      break;
    default:
      return {};
    }
  } else {
    switch (MemOp.getOpcode()) {
    case AIE2::G_STORE:
      if (Is32Lanes) {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_PACK_D8_D16_ag_idx_imm,
                                AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
      } else {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_PACK_D4_D8_ag_idx_imm,
                                AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
      }
      break;
    case AIE2::G_AIE_OFFSET_STORE:
      if (Is32Lanes) {
        FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
        ISelOpcode = FitsImmediateRange ? AIE2::VST_PACK_D8_D16_ag_idx_imm
                                        : AIE2::VST_PACK_D8_D16_ag_idx;
        return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                /*OffsetOpcode=*/{}};
      } else {
        FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
        ISelOpcode = FitsImmediateRange ? AIE2::VST_PACK_D4_D8_ag_idx_imm
                                        : AIE2::VST_PACK_D4_D8_ag_idx;
        return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                /*OffsetOpcode=*/{}};
      }
      break;
    case AIE2::G_AIE_POSTINC_STORE:
      FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
      if (Is32Lanes) {
        ISelOpcode = FitsImmediateRange ? AIE2::VST_PACK_D8_D16_ag_pstm_nrm_imm
                                        : AIE2::VST_PACK_D8_D16_ag_pstm_nrm;
        return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                /*OffsetOpcode=*/{}};
      } else {
        ISelOpcode = FitsImmediateRange ? AIE2::VST_PACK_D4_D8_ag_pstm_nrm_imm
                                        : AIE2::VST_PACK_D4_D8_ag_pstm_nrm;
        return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                                /*OffsetOpcode=*/{}};
      }
      break;
    case AIE2::G_AIE_POSTINC_2D_STORE:
      if (Is32Lanes) {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_PACK_D8_D16,
                                NoImmediate,
                                /*OffsetOpcode=*/{}};
      } else {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_2D_PACK_D4_D8,
                                NoImmediate,
                                /*OffsetOpcode=*/{}};
      }
      break;
    case AIE2::G_AIE_POSTINC_3D_STORE:
      if (Is32Lanes) {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_PACK_D8_D16,
                                NoImmediate,
                                /*OffsetOpcode=*/{}};
      } else {
        return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_3D_PACK_D4_D8,
                                NoImmediate,
                                /*OffsetOpcode=*/{}};
      }
      break;
    default:
      return {};
    }
  }
  return {};
}

bool canCombinePACK(MachineInstr &MemOp, MachineInstr &CombOp) {

  std::optional<APInt> NoImmediate = {};
  bool IsSigned = true;
  bool Is32Lanes = true;

  return getCombinedOpcodePACK(MemOp, CombOp, NoImmediate, IsSigned, Is32Lanes)
      .has_value();
}

bool AIE2InstructionSelector::selectG_AIE_STORE_PACK(MachineInstr &StoreI,
                                                     MachineRegisterInfo &MRI) {

  Register PackResult = (StoreI.uses().begin())->getReg();
  MachineInstr *PackOp = getDefIgnoringCopiesAndBitcasts(PackResult, MRI);

  assert(PackOp && "Expected SSA.");

  if (!canCombinePACK(StoreI, *PackOp) ||
      StoreI.getParent() != PackOp->getParent() || !MRI.hasOneUse(PackResult))
    return false;

  std::optional<AddressingModeInfo> AMI =
      getOrDefineAddressingRegister(StoreI, MRI);
  if (!AMI)
    return false;

  bool Is32Lanes = cast<GIntrinsic>(PackOp)->getIntrinsicID() == Intrinsic::aie2_pack_I8_I16;

  // Note: Operand 1 is the ID of the intrinsic
  Register SrcReg = PackOp->getOperand(2).getReg();
  Register SignReg = PackOp->getOperand(3).getReg();

  std::optional<LoadStoreOpcodes> LSO;
  bool ConstantSign = false;
  if (auto SignVal = getIConstantVRegValWithLookThrough(SignReg, MRI)) {
    // SignVal = 1 for signed and 0 for dynamically signed
    LSO = getCombinedOpcodePACK(StoreI, *PackOp, AMI->ImmediateOffset,
                                SignVal.value().Value == 0x1, Is32Lanes);
    ConstantSign = true;
  } else {
    LSO = getCombinedOpcodePACK(StoreI, *PackOp, AMI->ImmediateOffset, false,
                                Is32Lanes);
  }

  assert(LSO && "Unexpected VST.PACK combine failure");

  auto NewInstr = MIB.buildInstr(LSO->ISelOpcode);

  for (auto Def : StoreI.defs())
    NewInstr.addDef(Def.getReg());

  addAddressingMode(NewInstr, *AMI, LSO->FitsImmediateRange, false, MRI);

  NewInstr.addUse(SrcReg);

  NewInstr.cloneMemRefs(StoreI);

  if (!ConstantSign)
    setUnsetCtrlRegister(*NewInstr, MRI, AIE2::crPackSign, SignReg);

  StoreI.eraseFromParent();
  makeDeadMI(*PackOp, MRI);
  return constrainSelectedInstRegOperands(*NewInstr.getInstr(), TII, TRI, RBI);
}

bool AIE2InstructionSelector::select512BitG_AIE_STORE_SRS(
    LoadStoreOpcodes &LSO, AddressingModeInfo &AMI, Register SrcReg,
    Register ShftReg, Register SignReg, bool ConstantSign,
    MachineRegisterInfo &MRI) {
  assert(LSO.OffsetOpcode && "Expected an offset opcode for 512-bit VST.SRS!?");

  const TargetRegisterClass *RC = &AIE2::ACC512RegClass;
  Register Low512 = MRI.createVirtualRegister(RC);
  Register High512 = MRI.createVirtualRegister(RC);

  switch (AMI.MemI.getOpcode()) {
  case AIE2::G_STORE:
  case AIE2::G_AIE_POSTINC_STORE:
  case AIE2::G_AIE_POSTINC_2D_STORE:
  case AIE2::G_AIE_POSTINC_3D_STORE: {
    auto LowerBits = MIB.buildInstr(TargetOpcode::COPY, {Low512}, {})
                         .addReg(SrcReg, 0, AIE2::sub_512_lo);
    auto HigherBits = MIB.buildInstr(TargetOpcode::COPY, {High512}, {})
                          .addReg(SrcReg, 0, AIE2::sub_512_hi);
    auto StoreHigher = MIB.buildInstr(*LSO.OffsetOpcode)
                           .addReg(AMI.PtrOp.getReg())
                           .addImm(32) // Offset
                           .addReg(HigherBits.getReg(0))
                           .addReg(ShftReg);

    auto StoreLower = MIB.buildInstr(LSO.ISelOpcode);

    for (auto Def : AMI.MemI.defs())
      StoreLower.addDef(Def.getReg());

    addAddressingMode(StoreLower, AMI, LSO.FitsImmediateRange, false, MRI);

    StoreLower.addReg(LowerBits.getReg(0)).addReg(ShftReg);

    addSplitMemOperands(AMI.MemI, StoreHigher, StoreLower, 0, 2);

    if (!ConstantSign)
      setUnsetCtrlRegister(*StoreHigher, *StoreLower, MRI, AIE2::crSRSSign,
                           SignReg);

    AMI.MemI.eraseFromParent();
    return constrainSelectedInstRegOperands(*StoreLower, TII, TRI, RBI) &&
           constrainSelectedInstRegOperands(*StoreHigher, TII, TRI, RBI);
  }
  case AIE2::G_AIE_OFFSET_STORE: {
    auto LowerBits = MIB.buildInstr(TargetOpcode::COPY, {Low512}, {})
                         .addReg(SrcReg, 0, AIE2::sub_512_lo);
    auto HigherBits = MIB.buildInstr(TargetOpcode::COPY, {High512}, {})
                          .addReg(SrcReg, 0, AIE2::sub_512_hi);

    MachineInstrBuilder StoreHigher;
    if (LSO.FitsImmediateRange) {
      StoreHigher =
          MIB.buildInstr(*LSO.OffsetOpcode)
              .addReg(AMI.PtrOp.getReg())
              .addImm(AMI.ImmediateOffset->getSExtValue() + 32) // Offset
              .addReg(HigherBits.getReg(0))
              .addReg(ShftReg);
    } else {
      // In this case we have to emit an PTR_ADD to evaluate the offset
      insertPtrAddForOffset(MRI, AMI.MemI);
      StoreHigher = MIB.buildInstr(*LSO.OffsetOpcode)
                        .addReg(AMI.PtrOp.getReg())
                        .addImm(32) // Offset
                        .addReg(HigherBits.getReg(0))
                        .addReg(ShftReg);
    }

    auto StoreLower = MIB.buildInstr(LSO.ISelOpcode);

    StoreLower.addUse(AMI.PtrOp.getReg());
    if (LSO.FitsImmediateRange) {
      StoreLower.addImm(AMI.ImmediateOffset->getSExtValue()); // Offset
    } else {
      // In this case we have already inserted a PTR_ADD to add the offset to
      // the base pointer
      StoreLower.addImm(0); // Offset
    }

    StoreLower.addReg(LowerBits.getReg(0)).addReg(ShftReg);

    addSplitMemOperands(AMI.MemI, StoreHigher, StoreLower, 0, 2);

    if (!ConstantSign)
      setUnsetCtrlRegister(*StoreHigher, *StoreLower, MRI, AIE2::crSRSSign,
                           SignReg);

    AMI.MemI.eraseFromParent();
    return constrainSelectedInstRegOperands(*StoreLower, TII, TRI, RBI) &&
           constrainSelectedInstRegOperands(*StoreHigher, TII, TRI, RBI);
  }
  default:
    return false;
  }
}

bool AIE2InstructionSelector::selectG_AIE_STORE_SRS(MachineInstr &StoreI,
                                                    MachineRegisterInfo &MRI) {

  Register SrsResult = (StoreI.uses().begin())->getReg();
  MachineInstr *SrsOp = getDefIgnoringCopiesAndBitcasts(SrsResult, MRI);

  assert(SrsOp && "Expected SSA.");

  if (!canCombineSRSUPS(StoreI, *SrsOp) ||
      StoreI.getParent() != SrsOp->getParent() || !MRI.hasOneUse(SrsResult))
    return false;

  std::optional<AddressingModeInfo> AMI =
      getOrDefineAddressingRegister(StoreI, MRI);
  if (!AMI)
    return false;

  // Note: Operand 1 is the ID of the intrinsic
  Register SrcReg = SrsOp->getOperand(2).getReg();
  Register ShftReg = SrsOp->getOperand(3).getReg();
  Register SignReg = SrsOp->getOperand(4).getReg();

  std::optional<LoadStoreOpcodes> LSO;
  bool ConstantSign = false;
  if (auto SignVal = getIConstantVRegValWithLookThrough(SignReg, MRI)) {
    // SignVal = 1 for signed and 0 for dynamically signed
    LSO = getCombinedOpcodeSRSUPS(StoreI, *SrsOp, AMI->ImmediateOffset,
                                  SignVal.value().Value == 0x1);
    ConstantSign = true;
  } else {
    LSO = getCombinedOpcodeSRSUPS(StoreI, *SrsOp, AMI->ImmediateOffset, false);
  }

  assert(LSO && "Unexpected VST.SRS combine failure");

  if (MRI.getType(SrsResult).getSizeInBits() == 512) {
    makeDeadMI(*SrsOp, MRI);
    return select512BitG_AIE_STORE_SRS(*LSO, *AMI, SrcReg, ShftReg, SignReg,
                                       ConstantSign, MRI);
  }

  auto NewInstr = MIB.buildInstr(LSO->ISelOpcode);

  for (auto Def : StoreI.defs())
    NewInstr.addDef(Def.getReg());

  addAddressingMode(NewInstr, *AMI, LSO->FitsImmediateRange, false, MRI);

  NewInstr.addUse(SrcReg);
  NewInstr.addUse(ShftReg);

  NewInstr.cloneMemRefs(StoreI);

  if (!ConstantSign)
    setUnsetCtrlRegister(*NewInstr, MRI, AIE2::crSRSSign, SignReg);

  makeDeadMI(*SrsOp, MRI);
  StoreI.eraseFromParent();
  return constrainSelectedInstRegOperands(*NewInstr.getInstr(), TII, TRI, RBI);
}

std::optional<LoadStoreOpcodes>
getCombinedOpcodeCONV(const MachineInstr &MemOp, const MachineInstr &CombOp,
                      std::optional<APInt> Immediate) {
  const bool AlwaysFitsImmediateRange = true;
  const bool NoImmediate = false;
  if (CombOp.getOpcode() != AIE2::G_INTRINSIC_W_SIDE_EFFECTS ||
      cast<GIntrinsic>(CombOp).getIntrinsicID() != Intrinsic::aie2_v16accfloat_to_v16bf16)
    return {};

  assert(getLoadStoreSize(MemOp) == 256 && "Unexpected VST.CONV size");

  unsigned ISelOpcode;
  bool FitsImmediateRange = false;
  switch (MemOp.getOpcode()) {
  case AIE2::G_STORE:
    return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_CONV_BF16_FP32_ag_idx_imm,
                            AlwaysFitsImmediateRange, /*OffsetOpcode=*/{}};
  case AIE2::G_AIE_OFFSET_STORE:
    FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
    ISelOpcode = FitsImmediateRange ? AIE2::VST_CONV_BF16_FP32_ag_idx_imm
                                    : AIE2::VST_CONV_BF16_FP32_ag_idx;
    return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                            /*OffsetOpcode=*/{}};
  case AIE2::G_AIE_POSTINC_STORE:
    FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
    ISelOpcode = FitsImmediateRange ? AIE2::VST_CONV_BF16_FP32_ag_pstm_nrm_imm
                                    : AIE2::VST_CONV_BF16_FP32_ag_pstm_nrm;
    return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange,
                            /*OffsetOpcode=*/{}};
  case AIE2::G_AIE_POSTINC_2D_STORE:
    return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_CONV_2D_BF16_FP32,
                            NoImmediate,
                            /*OffsetOpcode=*/{}};
  case AIE2::G_AIE_POSTINC_3D_STORE:
    return LoadStoreOpcodes{/*ISelOpcode=*/AIE2::VST_CONV_3D_BF16_FP32,
                            NoImmediate,
                            /*OffsetOpcode=*/{}};
  }
  return {};
}

bool canCombineCONV(MachineInstr &MemOp, MachineInstr &CombOp) {
  const std::optional<APInt> NoImmediate = {};
  return getCombinedOpcodeCONV(MemOp, CombOp, NoImmediate).has_value();
}

bool AIE2InstructionSelector::selectG_AIE_STORE_CONV(MachineInstr &StoreI,
                                                     MachineRegisterInfo &MRI) {

  Register ConvResult = (StoreI.uses().begin())->getReg();
  MachineInstr *ConvOp = getDefIgnoringCopiesAndBitcasts(ConvResult, MRI);

  assert(ConvOp && "Expected SSA.");

  if (!canCombineCONV(StoreI, *ConvOp) ||
      StoreI.getParent() != ConvOp->getParent() || !MRI.hasOneUse(ConvResult))
    return false;

  std::optional<AddressingModeInfo> AMI =
      getOrDefineAddressingRegister(StoreI, MRI);
  if (!AMI)
    return false;

  std::optional<LoadStoreOpcodes> LSO =
      getCombinedOpcodeCONV(StoreI, *ConvOp, AMI->ImmediateOffset);

  assert(LSO && "Unexpected VST.CONV combine failure");

  auto NewInstr = MIB.buildInstr(LSO->ISelOpcode);

  for (auto Def : StoreI.defs())
    NewInstr.addDef(Def.getReg());

  addAddressingMode(NewInstr, *AMI, LSO->FitsImmediateRange, false, MRI);

  // Note: Operand 1 is the ID of the intrinsic
  Register SrcReg = ConvOp->getOperand(2).getReg();
  NewInstr.addUse(SrcReg);

  NewInstr.cloneMemRefs(StoreI);

  makeDeadMI(*ConvOp, MRI);
  StoreI.eraseFromParent();
  return constrainSelectedInstRegOperands(*NewInstr.getInstr(), TII, TRI, RBI);
}

bool AIE2InstructionSelector::select512BitG_AIE_LOAD_STORE(
    MachineInstr &I, LoadStoreOpcodes &LSO, AddressingModeInfo &AMI,
    MachineRegisterInfo &MRI) {
  assert(LSO.OffsetOpcode &&
         "Expected an offset opcode for 512-bit load/store!?");

  LLT SrcDstTy = MRI.getType(AMI.SrcDstOp.getReg());
  bool IsAccumulator = SrcDstTy.getElementType().getSizeInBits() == 64;
  const TargetRegisterClass *RC256 =
      IsAccumulator ? &AIE2::ACC256RegClass : &AIE2::VEC256RegClass;
  const TargetRegisterClass *RC512 =
      IsAccumulator ? &AIE2::ACC512RegClass : &AIE2::VEC512RegClass;
  Register Low256 = MRI.createVirtualRegister(RC256);
  Register High256 = MRI.createVirtualRegister(RC256);

  switch (AMI.MemI.getOpcode()) {
  case AIE2::G_STORE:
  case AIE2::G_AIE_POSTINC_STORE:
  case AIE2::G_AIE_POSTINC_2D_STORE:
  case AIE2::G_AIE_POSTINC_3D_STORE: {
    auto LowerBits = MIB.buildInstr(TargetOpcode::COPY, {Low256}, {})
                         .addReg(AMI.SrcDstOp.getReg(), 0, AIE2::sub_256_lo);
    auto HigherBits = MIB.buildInstr(TargetOpcode::COPY, {High256}, {})
                          .addReg(AMI.SrcDstOp.getReg(), 0, AIE2::sub_256_hi);

    auto StoreHigher = MIB.buildInstr(*LSO.OffsetOpcode, {}, {})
                           .addReg(HigherBits.getReg(0))
                           .addReg(AMI.PtrOp.getReg())
                           .addImm(32); // Offset
    auto StoreLower = MIB.buildInstr(LSO.ISelOpcode, {}, {});

    for (auto Def : AMI.MemI.defs())
      StoreLower.addDef(Def.getReg());

    StoreLower.addReg(LowerBits.getReg(0));

    addAddressingMode(StoreLower, AMI, LSO.FitsImmediateRange, false, MRI);

    addSplitMemOperands(AMI.MemI, StoreHigher, StoreLower, 0, 2);

    AMI.MemI.eraseFromParent();
    return constrainSelectedInstRegOperands(*StoreLower, TII, TRI, RBI) &&
           constrainSelectedInstRegOperands(*StoreHigher, TII, TRI, RBI);
  }
  case AIE2::G_AIE_OFFSET_STORE: {
    auto LowerBits = MIB.buildInstr(TargetOpcode::COPY, {Low256}, {})
                         .addReg(AMI.SrcDstOp.getReg(), 0, AIE2::sub_256_lo);
    auto HigherBits = MIB.buildInstr(TargetOpcode::COPY, {High256}, {})
                          .addReg(AMI.SrcDstOp.getReg(), 0, AIE2::sub_256_hi);

    MachineInstrBuilder StoreHigher;
    if (LSO.FitsImmediateRange) {
      StoreHigher =
          MIB.buildInstr(*LSO.OffsetOpcode, {}, {})
              .addReg(HigherBits.getReg(0))
              .addReg(AMI.PtrOp.getReg())
              .addImm(AMI.ImmediateOffset->getSExtValue() + 32); // Offset
    } else {
      // In this case we have to emit an PTR_ADD to evaluate the offset
      insertPtrAddForOffset(MRI, AMI.MemI);
      StoreHigher = MIB.buildInstr(*LSO.OffsetOpcode, {}, {})
                        .addReg(HigherBits.getReg(0))
                        .addReg(AMI.PtrOp.getReg())
                        .addImm(32); // Offset
    }

    auto StoreLower = MIB.buildInstr(LSO.ISelOpcode, {}, {});

    StoreLower.addReg(LowerBits.getReg(0));

    StoreLower.addUse(AMI.PtrOp.getReg());
    if (LSO.FitsImmediateRange) {
      StoreLower.addImm(AMI.ImmediateOffset->getSExtValue()); // Offset
    } else {
      // In this case we have already inserted a PTR_ADD to add the offset to
      // the base pointer
      StoreLower.addImm(0); // Offset
    }

    addSplitMemOperands(AMI.MemI, StoreHigher, StoreLower, 0, 2);

    AMI.MemI.eraseFromParent();
    return constrainSelectedInstRegOperands(*StoreLower, TII, TRI, RBI) &&
           constrainSelectedInstRegOperands(*StoreHigher, TII, TRI, RBI);
  }
  case AIE2::G_LOAD:
  case AIE2::G_AIE_POSTINC_LOAD:
  case AIE2::G_AIE_POSTINC_2D_LOAD:
  case AIE2::G_AIE_POSTINC_3D_LOAD: {
    auto LoadHigher = MIB.buildInstr(*LSO.OffsetOpcode, {}, {})
                          .addDef(High256)
                          .addUse(AMI.PtrOp.getReg())
                          .addImm(32); // Offset

    auto LoadLower = MIB.buildInstr(LSO.ISelOpcode, {Low256}, {});
    // We have to skip the first Def (the 512-bit Dst-Reg)
    for (auto *Def = AMI.MemI.defs().begin() + 1; Def != AMI.MemI.defs().end();
         Def++)
      LoadLower.addDef(Def->getReg());

    addAddressingMode(LoadLower, AMI, LSO.FitsImmediateRange, false, MRI);

    addSplitMemOperands(AMI.MemI, LoadHigher, LoadLower, 0, 2);

    MIB.buildInstr(AIE2::REG_SEQUENCE, {AMI.SrcDstOp.getReg()}, {})
        .addReg(Low256)
        .addImm(AIE2::sub_256_lo)
        .addReg(High256)
        .addImm(AIE2::sub_256_hi);

    Register SrcDstReg = AMI.SrcDstOp.getReg();
    AMI.MemI.eraseFromParent();
    return constrainSelectedInstRegOperands(*LoadLower, TII, TRI, RBI) &&
           constrainSelectedInstRegOperands(*LoadHigher, TII, TRI, RBI) &&
           RBI.constrainGenericRegister(SrcDstReg, *RC512, MRI);
  }
  case AIE2::G_AIE_OFFSET_LOAD: {
    MachineInstrBuilder LoadHigher;
    if (LSO.FitsImmediateRange) {
      LoadHigher =
          MIB.buildInstr(*LSO.OffsetOpcode, {}, {})
              .addDef(High256)
              .addUse(AMI.PtrOp.getReg())
              .addImm(AMI.ImmediateOffset->getSExtValue() + 32); // Offset
    } else {
      // In this case we have to emit an PTR_ADD to evaluate the offset
      insertPtrAddForOffset(MRI, AMI.MemI);
      LoadHigher = MIB.buildInstr(*LSO.OffsetOpcode, {}, {})
                       .addDef(High256)
                       .addUse(AMI.PtrOp.getReg())
                       .addImm(32); // Offset
    }

    auto LoadLower =
        MIB.buildInstr(LSO.ISelOpcode, {Low256}, {}).addUse(AMI.PtrOp.getReg());
    if (LSO.FitsImmediateRange) {
      LoadLower.addImm(AMI.ImmediateOffset->getSExtValue()); // Offset
    } else {
      // In this case we have already inserted a PTR_ADD to add the offset to
      // the base pointer
      LoadLower.addImm(0); // Offset
    }

    addSplitMemOperands(AMI.MemI, LoadHigher, LoadLower, 0, 2);

    MIB.buildInstr(AIE2::REG_SEQUENCE, {AMI.SrcDstOp.getReg()}, {})
        .addReg(Low256)
        .addImm(AIE2::sub_256_lo)
        .addReg(High256)
        .addImm(AIE2::sub_256_hi);

    Register SrcDstReg = AMI.SrcDstOp.getReg();
    AMI.MemI.eraseFromParent();
    return constrainSelectedInstRegOperands(*LoadLower, TII, TRI, RBI) &&
           constrainSelectedInstRegOperands(*LoadHigher, TII, TRI, RBI) &&
           RBI.constrainGenericRegister(SrcDstReg, *RC512, MRI);
  }
  default:
    return false;
  }
}

static bool getVLDA_CONVOpcode(const MachineInstr &MemOp,
                               const std::optional<APInt> Immediate,
                               unsigned &ISelOpcode, bool &FitsImmediateRange) {
  if (!MemOp.mayLoad())
    return false;

  switch (MemOp.getOpcode()) {
  case AIE2::G_LOAD:
    ISelOpcode = AIE2::VLDA_CONV_FP32_BF16_ag_idx_imm;
    FitsImmediateRange = true;
    return true;
  case AIE2::G_AIE_OFFSET_LOAD:
    FitsImmediateRange = checkImmediateRange<3, 32>(Immediate);
    ISelOpcode = FitsImmediateRange ? AIE2::VLDA_CONV_FP32_BF16_ag_idx_imm
                                    : AIE2::VLDA_CONV_FP32_BF16_ag_idx;
    return true;
  case AIE2::G_AIE_POSTINC_LOAD:
    FitsImmediateRange = checkImmediateRange<4, 32>(Immediate);
    ISelOpcode = FitsImmediateRange ? AIE2::VLDA_CONV_FP32_BF16_pstm_nrm_imm
                                    : AIE2::VLDA_CONV_FP32_BF16_pstm_nrm;
    return true;
  case AIE2::G_AIE_POSTINC_2D_LOAD:
    ISelOpcode = AIE2::VLDA_2D_CONV_FP32_BF16;
    FitsImmediateRange = false;
    return true;
  case AIE2::G_AIE_POSTINC_3D_LOAD:
    ISelOpcode = AIE2::VLDA_3D_CONV_FP32_BF16;
    FitsImmediateRange = false;
    return true;
  }
  return false;
}

std::optional<LoadStoreOpcodes>
getCombinedOpcodeCONVLoad(const MachineInstr &MemOp, const MachineInstr &CombOp,
                          const std::optional<APInt> Immediate) {

  if (CombOp.getOpcode() != AIE2::G_INTRINSIC ||
      cast<GIntrinsic>(CombOp).getIntrinsicID() !=
          Intrinsic::aie2_v16bf16_to_v16accfloat)
    return {};

  unsigned ISelOpcode;
  bool FitsImmediateRange = false;

  if (!getVLDA_CONVOpcode(MemOp, Immediate, ISelOpcode, FitsImmediateRange))
    return {};

  assert(getLoadStoreSize(MemOp) == 256 && "Unexpected VLDA.CONV size");

  return LoadStoreOpcodes{ISelOpcode, FitsImmediateRange, /*OffsetOpcode=*/{}};
}

bool canCombineCONVLoad(MachineInstr &MemOp, MachineInstr &CombOp) {
  const std::optional<APInt> NoImmediate = {};
  return getCombinedOpcodeCONVLoad(MemOp, CombOp, NoImmediate).has_value();
}

bool AIE2InstructionSelector::selectG_AIE_LOAD_CONV(MachineInstr &CONVI,
                                                    MachineRegisterInfo &MRI) {
  Register LoadResult = (std::next(CONVI.uses().begin()))->getReg();
  MachineInstr *LoadOp = getDefIgnoringCopiesAndBitcasts(LoadResult, MRI);

  assert(LoadOp && "Expected SSA.");

  // Do not try to combine if one of the load's defs is used by another
  // instruction between the load and the VCONV or if there is a store
  // between the load and the VCONV.
  if (!canDelayMemOp(*LoadOp, CONVI, MRI))
    return false;

  if (!canCombineCONVLoad(*LoadOp, CONVI) ||
      LoadOp->getParent() != CONVI.getParent() || !MRI.hasOneUse(LoadResult))
    return false;

  std::optional<AddressingModeInfo> AMI =
      getOrDefineAddressingRegister(*LoadOp, MRI);

  if (!AMI)
    return false;

  std::optional<LoadStoreOpcodes> LSO =
      getCombinedOpcodeCONVLoad(AMI->MemI, CONVI, AMI->ImmediateOffset);

  Register DstReg = CONVI.getOperand(0).getReg();

  auto NewInstr = MIB.buildInstr(LSO->ISelOpcode);

  NewInstr.addDef(DstReg);

  for (auto *Def = std::next(AMI->MemI.defs().begin());
       Def != AMI->MemI.defs().end(); ++Def)
    NewInstr.addDef(Def->getReg());

  addAddressingMode(NewInstr, *AMI, LSO->FitsImmediateRange, false, MRI);

  NewInstr.cloneMemRefs(AMI->MemI);

  CONVI.eraseFromParent();

  // Erasing the load instruction breaks later on in the selection code. That is
  // because an iterator is kept on erased instructions. This breaks while
  // trying to eliminate a trivially dead instruction which requires access to
  // its memory operands which have been erased, thus leading to a seg fault. To
  // remedy this, we keep the load to be removed by the trivial dead code
  // elimination and we make sure to assign new virtual register definitions to
  // its live operands to respect SSA.
  makeDeadMI(*LoadOp, MRI);

  return constrainSelectedInstRegOperands(*NewInstr.getInstr(), TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectVCONV(MachineInstr &I,
                                          MachineRegisterInfo &MRI) {
  // Try to match CONV combine
  if (selectG_AIE_LOAD_CONV(I, MRI))
    return true;
  // Resort to TableGen'ed selection patterns
  return selectImpl(I, *CoverageInfo);
}

bool AIE2InstructionSelector::selectG_AIE_LOAD_STORE(MachineInstr &I,
                                                     MachineRegisterInfo &MRI) {

  // First try to match CONV, SRS and PACK combine
  if (selectG_AIE_STORE_CONV(I, MRI) || selectG_AIE_STORE_SRS(I, MRI) ||
      selectG_AIE_STORE_PACK(I, MRI))
    return true;

  std::optional<AddressingModeInfo> AMI = getOrDefineAddressingRegister(I, MRI);
  if (!AMI)
    return false;

  LoadStoreOpcodes LSO =
      getLoadStoreOpcode(AMI->MemI, MRI, RBI, AMI->ImmediateOffset);
  LLT SrcDstTy = MRI.getType(AMI->SrcDstOp.getReg());

  if (SrcDstTy.getSizeInBits() == 512)
    return select512BitG_AIE_LOAD_STORE(I, LSO, *AMI, MRI);

  MachineInstrBuilder NewInstr = MIB.buildInstr(LSO.ISelOpcode);

  for (auto Def : AMI->MemI.defs())
    NewInstr.addDef(Def.getReg());

  if (AMI->MemI.mayStore())
    // If the MemOp is a STORE the first use is the value to be stored
    NewInstr.addUse(AMI->SrcDstOp.getReg());

  addAddressingMode(NewInstr, *AMI, LSO.FitsImmediateRange, true, MRI);

  NewInstr.cloneMemRefs(AMI->MemI);

  AMI->MemI.eraseFromParent();

  return constrainSelectedInstRegOperands(*NewInstr, TII, TRI, RBI);
}

// This function returns the  Vector Select (VSEL) opcode and Select
// parameter Register operand. This function is used in case of extracting
// element from 1024-bit vector when idx is not a compile time constant.
static std::pair<unsigned, Register>
createOpcodeCondRegPair(unsigned EltSize, Register LtReg, MachineIRBuilder &MIB,
                        MachineRegisterInfo &MRI) {
  const TargetRegisterClass *RegClass =
      EltSize == 8 ? &AIE2::eRRegClass : &AIE2::eRS8RegClass;
  auto VSelCond = MIB.buildInstr(AIE2::ADD_add_r_ri, {RegClass}, {})
                      .addReg(LtReg)
                      .addImm(-1);
  Register SelReg = VSelCond.getReg(0);
  unsigned Opcode = 0;
  switch (EltSize) {
  case 8: {
    /* VSEL_8 needs 64-bit select source register
     * to select between 8-bit words.*/
    Opcode = AIE2::VSEL_8;
    Register SrcRegL = MRI.createVirtualRegister(&AIE2::eLRegClass);
    MachineInstrBuilder MI = MIB.buildInstr(AIE2::REG_SEQUENCE, {SrcRegL}, {})
                                 .addReg(SelReg)
                                 .addImm(AIE2::sub_l_even)
                                 .addReg(SelReg)
                                 .addImm(AIE2::sub_l_odd);
    SelReg = MI.getReg(0);
    break;
  }
  case 16:
    Opcode = AIE2::VSEL_16;
    break;
  case 32:
    Opcode = AIE2::VSEL_32;
    break;
  default:
    llvm_unreachable("Unexpected Vector Element Size");
  }
  return std::make_pair(Opcode, SelReg);
}

static unsigned getExtractVecEltOpcode(unsigned EltSize, unsigned InstOpcode) {
  unsigned Opcode = 0;
  bool IsZextExtVecElt = InstOpcode == AIE2::G_AIE_ZEXT_EXTRACT_VECTOR_ELT;
  switch (EltSize) {
  case 8:
    Opcode = IsZextExtVecElt ? AIE2::VEXTRACT_D8 : AIE2::VEXTRACT_S8;
    break;
  case 16:
    Opcode = IsZextExtVecElt ? AIE2::VEXTRACT_D16 : AIE2::VEXTRACT_S16;
    break;
  case 32:
    Opcode = IsZextExtVecElt ? AIE2::VEXTRACT_D32 : AIE2::VEXTRACT_S32;
    break;
  // there is no AIE vector with elt size 64, VEXTRACT_D64/VEXTRACT_S64 is
  // selected only when the extracted value is another vector of size 64-bit.
  default:
    llvm_unreachable("Unexpected Extracted Vector Element Size");
  }
  assert(Opcode != 0 && "Expected a NonZero Opcode");
  return Opcode;
}

static unsigned getInsertVecEltOpcode(unsigned EltSize, unsigned InstOpcode) {
  switch (EltSize) {
  case 8:
    return AIE2::VINSERT_8;
  case 16:
    return AIE2::VINSERT_16;
  case 32:
    return AIE2::VINSERT_32;
  default:
    llvm_unreachable("Unexpected vector elt size for insert vec elt!");
  }
}

namespace {

// Vector source and index regs for extract/insert vector elt.
struct SelSrcAndIdx {
  Register SrcReg;
  Register IdxReg;
  /* For a 1024-bit vector input */
  // Get the Low and High parts of a 1024-bit register.
  Register SubSrcReg512Lo = 0;
  Register SubSrcReg512Hi = 0;
  // Select the Low (0) or High (1) 512-bit part of a 1024-bit vector to be used
  // as an input to VEXTRACT or VINSERT based on the idx.
  bool SelLoOrHi = 0;
  // Get the opcode and sel reg for the generated VSEL insn.
  unsigned VSelOpcode = 0;
  Register VSelReg = 0;
};

} // end anonymous namespace

static SelSrcAndIdx getExtractOrInsertVectorEltInputs(
    MachineInstr &I, const TargetRegisterInfo &TRI, MachineRegisterInfo &MRI,
    const AIE2InstrInfo &TII, const AIE2RegisterBankInfo &RBI,
    MachineIRBuilder &MIB) {
  MachineFunction *MF = I.getMF();
  MachineOperand &RegOp0 = I.getOperand(1);
  unsigned Idx = 2;
  if (I.getOpcode() == AIE2::G_AIE_INSERT_VECTOR_ELT) {
    Idx = 3;
  }
  MachineOperand &RegOp1 = I.getOperand(Idx);
  Register SrcReg0 = RegOp0.getReg();
  Register SrcReg1 = RegOp1.getReg();
  LLT SrcVecTy = MRI.getType(SrcReg0);
  LLT SrcEltTy = SrcVecTy.getElementType();
  unsigned VecSize = SrcVecTy.getSizeInBits();
  unsigned EltSize = SrcEltTy.getSizeInBits();
  unsigned NumLanes = SrcVecTy.getNumElements();
  unsigned HalfNumLanes = NumLanes / 2;
  const TargetRegisterClass *RC512 = &AIE2::VEC512RegClass;
  SelSrcAndIdx SelSrcIdx;
  SelSrcIdx.SrcReg = SrcReg0;
  SelSrcIdx.IdxReg = SrcReg1;
  switch (VecSize) {
  case 256: {
    SelSrcIdx.SrcReg = MRI.createVirtualRegister(RC512);
    MachineInstrBuilder MI =
        MIB.buildInstr(AIE2::REG_SEQUENCE, {SelSrcIdx.SrcReg}, {})
            .addReg(SrcReg0)
            .addImm(AIE2::sub_256_lo);
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MI, AIE2::VEC256RegClass,
                             MI->getOperand(1));
    break;
  }
  case 512:
    // 512 bit vectors are natively supported by the instruction.
    break;
  case 1024: {
    Register SrcRegLo = MRI.createVirtualRegister(RC512);
    Register SrcRegHi = MRI.createVirtualRegister(RC512);
    auto IdxVal = getIConstantVRegValWithLookThrough(SrcReg1, MRI);
    // Non-Const Idx case
    // %0 <- 0
    // %1 <- idx
    // %2 <- <num_of_elem_512bits>
    // %3 = LT %1, %2
    /* select index */
    // %4 = SELNEZ %0, %2, %3
    /* adjust index */
    // %5 = SUB %1, %4
    /* create bitvector for vector select */
    // %6 = ADD %3, -1
    // %7 = VSEL_16 <sub_512bit_lo>, <sub_512bit_hi>, %6
    if (!IdxVal) {
      auto SubRegCopyLo = MIB.buildInstr(TargetOpcode::COPY, {SrcRegLo}, {})
                              .addReg(SrcReg0, 0, AIE2::sub_512_lo);
      auto SubRegCopyHi = MIB.buildInstr(TargetOpcode::COPY, {SrcRegHi}, {})
                              .addReg(SrcReg0, 0, AIE2::sub_512_hi);
      SelSrcIdx.SubSrcReg512Lo = SubRegCopyLo.getReg(0);
      SelSrcIdx.SubSrcReg512Hi = SubRegCopyHi.getReg(0);
      auto SelIdx0 =
          MIB.buildInstr(AIE2::MOV_RLC_imm10_pseudo, {&AIE2::eRRegClass}, {})
              .addImm(0);
      auto SelIdx1 =
          MIB.buildInstr(AIE2::MOV_RLC_imm10_pseudo, {&AIE2::eRRegClass}, {})
              .addImm(HalfNumLanes);
      auto Lt = MIB.buildInstr(AIE2::LT, {&AIE2::eR27RegClass}, {SrcReg1}, {})
                    .addReg(SelIdx1.getReg(0));
      auto IdxAdjust = MIB.buildInstr(AIE2::SELNEZ, {&AIE2::eRRegClass}, {})
                           .addReg(SelIdx0.getReg(0))
                           .addReg(SelIdx1.getReg(0))
                           .addReg(Lt.getReg(0));
      auto NewIdx = MIB.buildInstr(AIE2::SUB, {&AIE2::eRRegClass}, {})
                        .addReg(SrcReg1)
                        .addReg(IdxAdjust.getReg(0));
      auto [VSelOpcode, VSelReg] =
          createOpcodeCondRegPair(EltSize, Lt.getReg(0), MIB, MRI);
      auto VSel = MIB.buildInstr(VSelOpcode, {&AIE2::VEC512RegClass}, {})
                      .addReg(SelSrcIdx.SubSrcReg512Lo)
                      .addReg(SelSrcIdx.SubSrcReg512Hi)
                      .addReg(VSelReg);
      SelSrcIdx.VSelOpcode = VSelOpcode;
      SelSrcIdx.VSelReg = VSelReg;
      SelSrcIdx.SrcReg = VSel.getReg(0);
      SelSrcIdx.IdxReg = NewIdx.getReg(0);
      constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *VSel,
                               AIE2::VEC512RegClass, VSel->getOperand(1));
      constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *VSel,
                               AIE2::VEC512RegClass, VSel->getOperand(2));
    } else {
      // Const Idx case
      unsigned LaneIdx = IdxVal->Value.getZExtValue();
      unsigned AdjustedIdx =
          LaneIdx < HalfNumLanes ? LaneIdx : LaneIdx - HalfNumLanes;
      SelSrcIdx.IdxReg =
          MIB.buildInstr(AIE2::MOV_RLC_imm10_pseudo, {&AIE2::eRRegClass}, {})
              .addImm(AdjustedIdx)
              .getReg(0);
      if (LaneIdx < HalfNumLanes) {
        auto SubRegCopyLo = MIB.buildInstr(TargetOpcode::COPY, {SrcRegLo}, {})
                                .addReg(SrcReg0, 0, AIE2::sub_512_lo);
        RegOp0.setReg(SubRegCopyLo.getReg(0));
        SelSrcIdx.SrcReg = SrcRegLo;
        SelSrcIdx.SelLoOrHi = 0;
      } else {
        auto SubRegCopyHi = MIB.buildInstr(TargetOpcode::COPY, {SrcRegHi}, {})
                                .addReg(SrcReg0, 0, AIE2::sub_512_hi);
        RegOp0.setReg(SubRegCopyHi.getReg(0));
        SelSrcIdx.SrcReg = SrcRegHi;
        SelSrcIdx.SelLoOrHi = 1;
      }
    }
    break;
  }
  default:
    llvm_unreachable(
        "Unexpected input vector size for extract/insert vector elt!");
  }
  return SelSrcIdx;
}

bool AIE2InstructionSelector::selectG_AIE_EXTRACT_VECTOR_ELT(
    MachineInstr &I, MachineRegisterInfo &MRI) {
  MachineOperand &RegOp0 = I.getOperand(1);
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg0 = RegOp0.getReg();
  LLT SrcVecTy = MRI.getType(SrcReg0);
  LLT SrcEltTy = SrcVecTy.getElementType();
  unsigned EltSize = SrcEltTy.getSizeInBits();
  SelSrcAndIdx SelSrcIdx =
      getExtractOrInsertVectorEltInputs(I, TRI, MRI, TII, RBI, MIB);
  unsigned Opcode = getExtractVecEltOpcode(EltSize, I.getOpcode());
  MachineInstrBuilder MI = MIB.buildInstr(Opcode, {DstReg}, {})
                               .addReg(SelSrcIdx.SrcReg)
                               .addReg(SelSrcIdx.IdxReg);
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectG_AIE_INSERT_VECTOR_ELT(
    MachineInstr &I, MachineRegisterInfo &MRI) {
  Register DstVecReg = I.getOperand(0).getReg();
  unsigned DstVecSize = MRI.getType(DstVecReg).getSizeInBits();
  Register SrcVecReg = I.getOperand(1).getReg();
  Register ValReg = I.getOperand(2).getReg();
  Register IdxReg = I.getOperand(3).getReg();
  LLT SrcVecEltTy = MRI.getType(SrcVecReg).getElementType();
  unsigned SrcVecEltSize = SrcVecEltTy.getSizeInBits();

  // Get the appropriate VINSERT opcode.
  unsigned Opcode = getInsertVecEltOpcode(SrcVecEltSize, I.getOpcode());
  // VINSERT needs a 512bit src register.
  SelSrcAndIdx SelSrcIdx =
      getExtractOrInsertVectorEltInputs(I, TRI, MRI, TII, RBI, MIB);

  const TargetRegisterClass *RC512 = &AIE2::VEC512RegClass;
  MachineInstrBuilder VINSERT;

  // Copy to the original register.
  switch (DstVecSize) {
  case 256: {
    Register Tmp512VecDstReg = MRI.createVirtualRegister(RC512);
    VINSERT = MIB.buildInstr(Opcode, {Tmp512VecDstReg}, {});
    MachineInstrBuilder CopyInstr =
        MIB.buildInstr(TargetOpcode::COPY, {DstVecReg}, {})
            .addReg(Tmp512VecDstReg, 0, AIE2::sub_256_lo);
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *CopyInstr,
                             AIE2::VEC256RegClass, CopyInstr->getOperand(0));
    break;
  }
  case 512: {
    VINSERT = MIB.buildInstr(Opcode, {DstVecReg}, {});
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *VINSERT, *RC512,
                             VINSERT->getOperand(0));
    break;
  }
  case 1024: {
    // Non Const idx case.
    // ...
    // %6 = ADD %3, -1
    // %7 = VSEL_32 <sub_512bit_lo_orig>, <sub_512bit_hi_orig>, %6
    // %8 = VINSERT32 %7, <val>, %5
    /* select lo and hi parts for the REG_SEQUENCE */
    // %9 = VSEL_32 %8, <sub_512bit_lo_orig>, %6
    // %10 = VSEL_32 <sub_512bit_hi_orig>, %8, %6
    // %11 = REG_SEQUENCE %9, sub_512bit_lo, %10, sub_512bit_hi

    auto IdxVal = getIConstantVRegValWithLookThrough(IdxReg, MRI);
    Register Tmp512VecDstReg = MRI.createVirtualRegister(RC512);
    VINSERT = MIB.buildInstr(Opcode, {Tmp512VecDstReg}, {});
    MachineInstrBuilder RegSeq1024;
    if (!IdxVal) {
      auto VSel1 = MIB.buildInstr(SelSrcIdx.VSelOpcode, {RC512}, {})
                       .addReg(Tmp512VecDstReg)
                       .addReg(SelSrcIdx.SubSrcReg512Lo)
                       .addReg(SelSrcIdx.VSelReg);
      constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *VSel1, *RC512,
                               VSel1->getOperand(1));
      constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *VSel1, *RC512,
                               VSel1->getOperand(2));
      auto VSel2 = MIB.buildInstr(SelSrcIdx.VSelOpcode, {RC512}, {})
                       .addReg(SelSrcIdx.SubSrcReg512Hi)
                       .addReg(Tmp512VecDstReg)
                       .addReg(SelSrcIdx.VSelReg);
      constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *VSel2, *RC512,
                               VSel2->getOperand(1));
      constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *VSel2, *RC512,
                               VSel2->getOperand(2));

      RegSeq1024 = MIB.buildInstr(AIE2::REG_SEQUENCE, {DstVecReg}, {})
                       .addReg(VSel1.getReg(0))
                       .addImm(AIE2::sub_512_lo)
                       .addReg(VSel2.getReg(0))
                       .addImm(AIE2::sub_512_hi);
    } else {
      // Const idx case.
      Register TempOrig512Vec = MRI.createVirtualRegister(RC512);
      MachineInstrBuilder CopyInstr =
          MIB.buildInstr(TargetOpcode::COPY, {TempOrig512Vec}, {});
      RegSeq1024 = MIB.buildInstr(AIE2::REG_SEQUENCE, {DstVecReg}, {});
      if (SelSrcIdx.SelLoOrHi) {
        CopyInstr.addReg(SrcVecReg, 0, AIE2::sub_512_lo);
        RegSeq1024.addReg(TempOrig512Vec)
            .addImm(AIE2::sub_512_lo)
            .addReg(Tmp512VecDstReg)
            .addImm(AIE2::sub_512_hi);
      } else {
        CopyInstr.addReg(SrcVecReg, 0, AIE2::sub_512_hi);
        RegSeq1024.addReg(Tmp512VecDstReg)
            .addImm(AIE2::sub_512_lo)
            .addReg(TempOrig512Vec)
            .addImm(AIE2::sub_512_hi);
      }
      constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *CopyInstr, *RC512,
                               CopyInstr->getOperand(0));
    }
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *RegSeq1024,
                             AIE2::VEC1024RegClass, RegSeq1024->getOperand(0));
    break;
  }
  default:
    llvm_unreachable("Unexpected input vector size for insert vec elt!");
  }
  VINSERT.addReg(SelSrcIdx.SrcReg).addReg(SelSrcIdx.IdxReg).addReg(ValReg);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*VINSERT, TII, TRI, RBI);
}

// Select extract 128-bit Intrinsics
bool AIE2InstructionSelector::selectExtractI128(MachineInstr &I,
                                                Register DstReg,
                                                Register SrcReg,
                                                MachineRegisterInfo &MRI) {
  LLT DstTy = MRI.getType(DstReg);
  assert(DstTy.getSizeInBits() == 128);
  LLT SrcTy = MRI.getType(SrcReg);

  unsigned SubReg = AIE2::NoSubRegister;
  switch (SrcTy.getSizeInBits()) {
  case 256:
    SubReg = AIE2::NoSubRegister;
    break;
  case 512:
    SubReg = AIE2::sub_256_lo;
    break;
  default:
    llvm_unreachable("Unexpected input size for extracting 128-bit vector");
  }

  // Select using a COPY to a 128-bit register.
  MachineInstr *CopyMI = MIB.buildInstr(TargetOpcode::COPY, {DstReg}, {})
                             .addReg(SrcReg, 0, SubReg);
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *CopyMI,
                           AIE2::VEC128RegClass, CopyMI->getOperand(0));

  I.eraseFromParent();
  return true;
}

// Select set 128-bit Intrinsics
bool AIE2InstructionSelector::selectSetI128(MachineInstr &I,
                                            MachineOperand &DstReg,
                                            MachineOperand &SrcReg,
                                            MachineRegisterInfo &MRI) {
  LLT SrcTy = MRI.getType(SrcReg.getReg());
  assert(SrcTy.getSizeInBits() == 128);
  LLT DstTy = MRI.getType(DstReg.getReg());
  const unsigned DstTySize = DstTy.getSizeInBits();
  assert(DstTySize == 256 || DstTySize == 512);

  // Constrain input vector to VEC128 RC, and output to VEC256/VEC512
  const TargetRegisterClass &OutRC =
      DstTySize == 256 ? AIE2::VEC256RegClass : AIE2::VEC512RegClass;
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, I, AIE2::VEC128RegClass,
                           SrcReg);
  constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, I, OutRC, DstReg);

  if (DstTySize == 256) {
    MIB.buildInstr(TargetOpcode::COPY, {DstReg}, {SrcReg});
  } else if (DstTySize == 512) {
    auto SrcInW =
        MIB.buildInstr(TargetOpcode::COPY, {&AIE2::VEC256RegClass}, {SrcReg});
    // Create 512-bit sources from 256-bit sources.
    MIB.buildInstr(AIE2::REG_SEQUENCE, {DstReg}, {})
        .addReg(SrcInW.getReg(0))
        .addImm(AIE2::sub_256_lo);
  } else {
    llvm_unreachable("Expected 256 or 512 bit input vector");
  }

  I.eraseFromParent();
  return true;
}

bool AIE2InstructionSelector::selectGetSS(MachineInstr &I,
                                          MachineRegisterInfo &MRI) {
  Register ValReg = I.getOperand(0).getReg();
  Register StatusReg = I.getOperand(1).getReg();
  // In this case of G_INTRINSIC operand 2 is target intrinsic

  unsigned OpCode = getOpCode(cast<GIntrinsic>(I).getIntrinsicID());
  MachineInstrBuilder MI = MIB.buildInstr(OpCode, {ValReg}, {});

  auto CopyInstr =
      MIB.buildInstr(TargetOpcode::COPY, {StatusReg}, {Register(AIE2::srSS0)});
  if (!selectCopy(*CopyInstr, MRI)) {
    return false;
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectPutMSB(MachineInstr &I,
                                           MachineRegisterInfo &MRI) {
  // In this case of G_INTRINSIC operand 0 is target intrinsic
  Register ValReg = I.getOperand(1).getReg();
  Register TLastReg = I.getOperand(2).getReg();
  auto TLastVal = getIConstantVRegValWithLookThrough(TLastReg, MRI);
  unsigned OpCode = AIE2::MOV_mv_scl2ms_doTlast_reg;
  if (TLastVal) {
    unsigned ConstTLastVal = TLastVal->Value.getZExtValue();
    OpCode =
        (ConstTLastVal == 0) ? AIE2::MOV_mv_scl2ms : AIE2::MOV_TLAST_mv_scl2ms;
  }
  MachineInstrBuilder MI = MIB.buildInstr(OpCode, {}, {ValReg});
  if (!TLastVal) {
    MI.addReg(TLastReg);
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectPutMSNB(MachineInstr &I,
                                            MachineRegisterInfo &MRI) {
  Register StatusReg = I.getOperand(0).getReg();
  // In this case of G_INTRINSIC operand 1 is target intrinsic
  Register ValReg = I.getOperand(2).getReg();
  Register TLastReg = I.getOperand(3).getReg();
  auto TLastVal = getIConstantVRegValWithLookThrough(TLastReg, MRI);
  unsigned OpCode = AIE2::MOV_NB_mv_scl2ms_doTlast_reg;
  if (TLastVal) {
    unsigned ConstTLastVal = TLastVal->Value.getZExtValue();
    OpCode = (ConstTLastVal == 0) ? AIE2::MOV_NB_mv_scl2ms
                                  : AIE2::MOV_NB_TLAST_mv_scl2ms;
  }
  MachineInstrBuilder MI = MIB.buildInstr(OpCode, {}, {ValReg});
  if (!TLastVal) {
    MI.addReg(TLastReg);
  }

  auto CopyInstr =
      MIB.buildInstr(TargetOpcode::COPY, {StatusReg}, {Register(AIE2::srMS0)});
  if (!selectCopy(*CopyInstr, MRI)) {
    return false;
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}
unsigned int getVLDSparseOpcode(MachineInstr &I) {
  switch (cast<GIntrinsic>(I).getIntrinsicID()) {
  case Intrinsic::aie2_sparse_pop_16_and_get_pointer:
  case Intrinsic::aie2_sparse_pop_16_bfloat_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_POP_16_and_get_pointer;
  case Intrinsic::aie2_sparse_pop_16_set_lo:
  case Intrinsic::aie2_sparse_pop_16_bfloat_set_lo:
    return AIE2::PSEUDO_VLD_SPARSE_POP_16_set_low;
  case Intrinsic::aie2_sparse_pop_16_insert_hi:
  case Intrinsic::aie2_sparse_pop_16_bfloat_insert_hi:
    return AIE2::PSEUDO_VLD_SPARSE_POP_16_insert_hi;
  case Intrinsic::aie2_sparse_peek_16_and_get_pointer:
  case Intrinsic::aie2_sparse_peek_16_bfloat_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_PEEK_16_and_get_pointer;
  case Intrinsic::aie2_sparse_peek_16_set_lo:
  case Intrinsic::aie2_sparse_peek_16_bfloat_set_lo:
    return AIE2::PSEUDO_VLD_SPARSE_PEEK_16_set_low;
  case Intrinsic::aie2_sparse_peek_16_insert_hi:
  case Intrinsic::aie2_sparse_peek_16_bfloat_insert_hi:
    return AIE2::PSEUDO_VLD_SPARSE_PEEK_16_insert_hi;
  case Intrinsic::aie2_sparse_pop_8_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_POP_8_and_get_pointer;
  case Intrinsic::aie2_sparse_pop_8_set_lo:
    return AIE2::PSEUDO_VLD_SPARSE_POP_8_set_low;
  case Intrinsic::aie2_sparse_pop_8_insert_hi:
    return AIE2::PSEUDO_VLD_SPARSE_POP_8_insert_hi;
  case Intrinsic::aie2_sparse_peek_8_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_PEEK_8_and_get_pointer;
  case Intrinsic::aie2_sparse_peek_8_set_lo:
    return AIE2::PSEUDO_VLD_SPARSE_PEEK_8_set_low;
  case Intrinsic::aie2_sparse_peek_8_insert_hi:
    return AIE2::PSEUDO_VLD_SPARSE_PEEK_8_insert_hi;
  case Intrinsic::aie2_sparse_pop_4_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_POP_4_and_get_pointer;
  case Intrinsic::aie2_sparse_pop_4_set_lo:
    return AIE2::PSEUDO_VLD_SPARSE_POP_4_set_low;
  case Intrinsic::aie2_sparse_pop_4_insert_hi:
    return AIE2::PSEUDO_VLD_SPARSE_POP_4_insert_hi;
  case Intrinsic::aie2_sparse_peek_4_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_PEEK_4_and_get_pointer;
  case Intrinsic::aie2_sparse_peek_4_set_lo:
    return AIE2::PSEUDO_VLD_SPARSE_PEEK_4_set_low;
  case Intrinsic::aie2_sparse_peek_4_insert_hi:
    return AIE2::PSEUDO_VLD_SPARSE_PEEK_4_insert_hi;
  case Intrinsic::aie2_sparse_reset_16:
    return AIE2::VLDB_SPARSE_RESET_16;
  case Intrinsic::aie2_sparse_fill_16:
    return AIE2::VLDB_SPARSE_FILL_16;
  case Intrinsic::aie2_sparse_reset_16_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_RESET_16_and_get_pointer;
  case Intrinsic::aie2_sparse_fill_16_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_FILL_16_and_get_pointer;
  case Intrinsic::aie2_sparse_reset_8:
    return AIE2::VLDB_SPARSE_RESET_8;
  case Intrinsic::aie2_sparse_fill_8:
    return AIE2::VLDB_SPARSE_FILL_8;
  case Intrinsic::aie2_sparse_reset_8_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_RESET_8_and_get_pointer;
  case Intrinsic::aie2_sparse_fill_8_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_FILL_8_and_get_pointer;
  case Intrinsic::aie2_sparse_reset_4:
    return AIE2::VLDB_SPARSE_RESET_4;
  case Intrinsic::aie2_sparse_fill_4:
    return AIE2::VLDB_SPARSE_FILL_4;
  case Intrinsic::aie2_sparse_reset_4_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_RESET_4_and_get_pointer;
  case Intrinsic::aie2_sparse_fill_4_and_get_pointer:
    return AIE2::PSEUDO_VLD_SPARSE_FILL_4_and_get_pointer;
  }
  llvm_unreachable("unreachable: Failed to get sparse load opcode");
  return AIE2::INSTRUCTION_LIST_END;
}
bool AIE2InstructionSelector::selectVLDSparseOP_Pseudo(
    MachineInstr &I, MachineRegisterInfo &MRI) {
  switch (cast<GIntrinsic>(I).getIntrinsicID()) {
  case Intrinsic::aie2_sparse_pop_16_and_get_pointer:
  case Intrinsic::aie2_sparse_pop_16_bfloat_and_get_pointer:
  case Intrinsic::aie2_sparse_pop_8_and_get_pointer:
  case Intrinsic::aie2_sparse_pop_4_and_get_pointer:
  case Intrinsic::aie2_sparse_peek_16_and_get_pointer:
  case Intrinsic::aie2_sparse_peek_16_bfloat_and_get_pointer:
  case Intrinsic::aie2_sparse_peek_8_and_get_pointer:
  case Intrinsic::aie2_sparse_peek_4_and_get_pointer: {
    Register PtrOut = I.getOperand(0).getReg();
    Register VecOut = I.getOperand(1).getReg();
    Register MaskOut = I.getOperand(2).getReg();
    Register PtrIn = I.getOperand(6).getReg();

    Register OutPtrLow = MRI.createVirtualRegister(&AIE2::eDN0RegClass);
    Register OutSparseVecLow =
        MRI.createVirtualRegister(&AIE2::SPARSEVEC640RegClass);
    MachineInstrBuilder PseudoMI = MIB.buildInstr(
        getVLDSparseOpcode(I), {OutPtrLow, OutSparseVecLow}, {PtrIn});

    auto VecCopyMI = MIB.buildInstr(TargetOpcode::COPY, {VecOut}, {})
                         .addReg(OutSparseVecLow, 0, AIE2::sub_sparse_x);
    auto MaskCopyMI = MIB.buildInstr(TargetOpcode::COPY, {MaskOut}, {})
                          .addReg(OutSparseVecLow, 0, AIE2::sub_sparse_q);
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *VecCopyMI,
                             AIE2::VEC512RegClass, VecCopyMI->getOperand(0));
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MaskCopyMI,
                             AIE2::VEC128RegClass, MaskCopyMI->getOperand(0));
    MIB.buildInstr(TargetOpcode::COPY, {PtrOut}, {}).addReg(OutPtrLow);

    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*PseudoMI, TII, TRI, RBI);
  }
  case Intrinsic::aie2_sparse_pop_16_set_lo:
  case Intrinsic::aie2_sparse_pop_16_bfloat_set_lo:
  case Intrinsic::aie2_sparse_pop_8_set_lo:
  case Intrinsic::aie2_sparse_pop_4_set_lo:
  case Intrinsic::aie2_sparse_peek_16_set_lo:
  case Intrinsic::aie2_sparse_peek_16_bfloat_set_lo:
  case Intrinsic::aie2_sparse_peek_8_set_lo:
  case Intrinsic::aie2_sparse_peek_4_set_lo: {
    Register PtrOut = I.getOperand(0).getReg();
    Register VecOut = I.getOperand(1).getReg();
    Register MaskOut = I.getOperand(2).getReg();
    Register PtrIn = I.getOperand(6).getReg();

    Register OutPtrLow = MRI.createVirtualRegister(&AIE2::ePRegClass);
    Register OutSparseVecLow =
        MRI.createVirtualRegister(&AIE2::SPARSEVEC640RegClass);
    MachineInstrBuilder PseudoMI = MIB.buildInstr(
        getVLDSparseOpcode(I), {OutPtrLow, OutSparseVecLow}, {PtrIn});

    auto VecCopyMI = MIB.buildInstr(TargetOpcode::COPY, {VecOut}, {})
                         .addReg(OutSparseVecLow, 0, AIE2::sub_sparse_x);
    auto MaskCopyMI = MIB.buildInstr(TargetOpcode::COPY, {MaskOut}, {})
                          .addReg(OutSparseVecLow, 0, AIE2::sub_sparse_q);
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *VecCopyMI,
                             AIE2::VEC512RegClass, VecCopyMI->getOperand(0));
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MaskCopyMI,
                             AIE2::VEC128RegClass, MaskCopyMI->getOperand(0));
    MIB.buildInstr(TargetOpcode::COPY, {PtrOut}, {}).addReg(OutPtrLow);

    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*PseudoMI, TII, TRI, RBI);
  }
  case Intrinsic::aie2_sparse_pop_16_insert_hi:
  case Intrinsic::aie2_sparse_pop_16_bfloat_insert_hi:
  case Intrinsic::aie2_sparse_pop_8_insert_hi:
  case Intrinsic::aie2_sparse_pop_4_insert_hi:
  case Intrinsic::aie2_sparse_peek_16_insert_hi:
  case Intrinsic::aie2_sparse_peek_16_bfloat_insert_hi:
  case Intrinsic::aie2_sparse_peek_8_insert_hi:
  case Intrinsic::aie2_sparse_peek_4_insert_hi: {
    Register PtrOut = I.getOperand(0).getReg();
    Register VecOut = I.getOperand(1).getReg();
    Register MaskOut = I.getOperand(2).getReg();
    Register VecIn = I.getOperand(6).getReg();
    Register MaskIn = I.getOperand(7).getReg();
    Register PtrIn = I.getOperand(8).getReg();

    Register OutPtr = MRI.createVirtualRegister(&AIE2::ePRegClass);
    Register InSparseVecSeq = createSparseRegSequence(VecIn, MaskIn, MRI);
    Register OutSparseVec =
        MRI.createVirtualRegister(&AIE2::SPARSEVEC640RegClass);
    MachineInstrBuilder PseudoMI = MIB.buildInstr(
        getVLDSparseOpcode(I), {OutPtr, OutSparseVec}, {PtrIn, InSparseVecSeq});

    auto VecCopyMI = MIB.buildInstr(TargetOpcode::COPY, {VecOut}, {})
                         .addReg(OutSparseVec, 0, AIE2::sub_sparse_x);
    auto MaskCopyMI = MIB.buildInstr(TargetOpcode::COPY, {MaskOut}, {})
                          .addReg(OutSparseVec, 0, AIE2::sub_sparse_q);
    auto PtrCopyMI = MIB.buildInstr(TargetOpcode::COPY, {PtrOut}, {OutPtr});

    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *PtrCopyMI,
                             AIE2::ePRegClass, PtrCopyMI->getOperand(0));
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *VecCopyMI,
                             AIE2::VEC512RegClass, VecCopyMI->getOperand(0));
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *MaskCopyMI,
                             AIE2::VEC128RegClass, MaskCopyMI->getOperand(0));

    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*PseudoMI, TII, TRI, RBI);
  }
  }
  return false;
}

bool AIE2InstructionSelector::selectVLDSparseINIT_Pseudo(
    MachineInstr &I, MachineRegisterInfo &MRI) {
  switch (cast<GIntrinsic>(I).getIntrinsicID()) {
  case Intrinsic::aie2_sparse_fill_4:
  case Intrinsic::aie2_sparse_reset_4:
  case Intrinsic::aie2_sparse_fill_8:
  case Intrinsic::aie2_sparse_reset_8:
  case Intrinsic::aie2_sparse_fill_16:
  case Intrinsic::aie2_sparse_reset_16: {
    Register PtrIn = I.getOperand(2).getReg();
    Register OutPtr = MRI.createVirtualRegister(&AIE2::ePRegClass);
    MachineInstrBuilder MI =
        MIB.buildInstr(getVLDSparseOpcode(I), {OutPtr}, {PtrIn});
    Register PtrOut = I.getOperand(0).getReg();
    auto PtrCopyMI = MIB.buildInstr(TargetOpcode::COPY, {PtrOut}, {OutPtr});
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *PtrCopyMI,
                             AIE2::ePRegClass, PtrCopyMI->getOperand(0));
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
  }
  case Intrinsic::aie2_sparse_fill_4_and_get_pointer:
  case Intrinsic::aie2_sparse_reset_4_and_get_pointer:
  case Intrinsic::aie2_sparse_fill_8_and_get_pointer:
  case Intrinsic::aie2_sparse_reset_8_and_get_pointer:
  case Intrinsic::aie2_sparse_fill_16_and_get_pointer:
  case Intrinsic::aie2_sparse_reset_16_and_get_pointer: {
    Register PtrIn = I.getOperand(2).getReg();
    Register OutPtr = MRI.createVirtualRegister(&AIE2::eDN0RegClass);
    MachineInstrBuilder MI =
        MIB.buildInstr(getVLDSparseOpcode(I), {OutPtr}, {PtrIn});
    Register PtrOut = I.getOperand(0).getReg();
    auto PtrCopyMI = MIB.buildInstr(TargetOpcode::COPY, {PtrOut}, {OutPtr});
    constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, *PtrCopyMI,
                             AIE2::ePRegClass, PtrCopyMI->getOperand(0));
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
  }
    return false;
  }
  return false;
}

bool AIE2InstructionSelector::selectPutMS_PH(MachineInstr &I,
                                             MachineRegisterInfo &MRI) {
  // The number of operands is used to detect a non blocking or a blocking write
  // and select the right instructions. A non blocking write has 5 operands
  // whereas a blocking write has 4.
  auto NumOperands = I.getNumOperands();
  bool isNonBlocking = (I.getNumOperands() == 5);

  Register TLastReg = I.getOperand(NumOperands - 3).getReg();
  Register DstIDReg = I.getOperand(NumOperands - 2).getReg();
  Register PcktTyReg = I.getOperand(NumOperands - 1).getReg();
  auto TLastVal = getIConstantVRegValWithLookThrough(TLastReg, MRI);
  auto PcktTy = getIConstantVRegValWithLookThrough(PcktTyReg, MRI);
  if (!PcktTy) {
    dbgs() << "Cannot select: " << I << "\n";
    llvm_unreachable("Parameter 'pcktType' must be a compile time constant");
  }
  unsigned OpCode = isNonBlocking ? AIE2::MOV_NB_mv_ph2ms_doTlast_reg
                                  : AIE2::MOV_mv_ph2ms_doTlast_reg;
  if (TLastVal) {
    unsigned ConstTLastVal = TLastVal->Value.getZExtValue();
    if (isNonBlocking) {
      OpCode = (ConstTLastVal == 0) ? AIE2::MOV_NB_mv_ph2ms
                                    : AIE2::MOV_NB_TLAST_mv_ph2ms;
    } else
      OpCode =
          (ConstTLastVal == 0) ? AIE2::MOV_mv_ph2ms : AIE2::MOV_TLAST_mv_ph2ms;
  }
  auto PcktTyVal3Bit = PcktTy->Value.getLoBits(3).getZExtValue();
  MachineInstrBuilder MI =
      MIB.buildInstr(OpCode, {}, {DstIDReg, PcktTyVal3Bit});
  if (!TLastVal) {
    MI.addReg(TLastReg);
  }
  if (isNonBlocking) {
    Register StatusReg = I.getOperand(NumOperands - 5).getReg();
    auto CopyInstr = MIB.buildInstr(TargetOpcode::COPY, {StatusReg},
                                    {Register(AIE2::srMS0)});
    if (!selectCopy(*CopyInstr, MRI)) {
      return false;
    }
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIE2InstructionSelector::selectPutMS_CPH(MachineInstr &I,
                                              MachineRegisterInfo &MRI) {
  // The number of operands is used to detect a non blocking or a blocking write
  // and select the right instructions. A non blocking write has 7 operands
  // whereas a blocking write has 6.
  auto NumOperands = I.getNumOperands();
  bool isNonBlocking = (I.getNumOperands() == 7);

  Register TLastReg = I.getOperand(NumOperands - 5).getReg();
  Register AddrReg = I.getOperand(NumOperands - 4).getReg();
  auto NWordsReg = I.getOperand(NumOperands - 3).getReg();
  auto OpTypeReg = I.getOperand(NumOperands - 2).getReg();
  Register RspID = I.getOperand(NumOperands - 1).getReg();
  auto TLastVal = getIConstantVRegValWithLookThrough(TLastReg, MRI);
  auto NWords = getIConstantVRegValWithLookThrough(NWordsReg, MRI);
  auto OpType = getIConstantVRegValWithLookThrough(OpTypeReg, MRI);
  if (!NWords || !OpType) {
    dbgs() << "Cannot select: " << I << "\n";
    llvm_unreachable(
        "Parameters 'n_words' and 'op_type' must be compile time constants");
  }
  unsigned OpCode = (isNonBlocking) ? AIE2::MOV_NB_mv_cph2ms_doTlast_reg
                                    : AIE2::MOV_mv_cph2ms_doTlast_reg;
  if (TLastVal) {
    unsigned ConstTLastVal = TLastVal->Value.getZExtValue();
    if (isNonBlocking) {
      OpCode = (ConstTLastVal == 0) ? AIE2::MOV_NB_mv_cph2ms
                                    : AIE2::MOV_NB_TLAST_mv_cph2ms;
    } else {
      OpCode = (ConstTLastVal == 0) ? AIE2::MOV_mv_cph2ms
                                    : AIE2::MOV_TLAST_mv_cph2ms;
    }
  }
  auto NWordsVal2Bit = (NWords->Value - 1).getLoBits(2).getZExtValue();
  auto OpTypeVal2Bit = OpType->Value.getLoBits(2).getZExtValue();
  MachineInstrBuilder MI = MIB.buildInstr(
      OpCode, {}, {AddrReg, NWordsVal2Bit, OpTypeVal2Bit, RspID});
  if (!TLastVal) {
    MI.addReg(TLastReg);
  }

  if (isNonBlocking) {
    Register StatusReg = I.getOperand(NumOperands - 7).getReg();
    auto CopyInstr = MIB.buildInstr(TargetOpcode::COPY, {StatusReg},
                                    {Register(AIE2::srMS0)});
    if (!selectCopy(*CopyInstr, MRI)) {
      return false;
    }
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

namespace llvm {
InstructionSelector *createAIE2InstructionSelector(const AIE2TargetMachine &TM,
                                                   AIE2Subtarget &Subtarget,
                                                   AIE2RegisterBankInfo &RBI) {
  return new AIE2InstructionSelector(TM, Subtarget, RBI);
}

} // end namespace llvm
