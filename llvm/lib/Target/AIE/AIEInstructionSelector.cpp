//===- AIEInstructionSelector.cpp -----------------------------------------===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// AIE.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "AIE1RegisterBankInfo.h"
#include "AIERegisterInfo.h"
#include "AIETargetMachine.h"
#include "InstPrinter/AIEInstPrinter.h"
#include "MCTargetDesc/AIEMCTargetDesc.h"
#include "llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"
#include "llvm/CodeGen/GlobalISel/Utils.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineJumpTableInfo.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/IR/IntrinsicsAIE.h"

#define DEBUG_TYPE "aie-isel"

using namespace llvm;

namespace {

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "AIEGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

class AIEInstructionSelector : public InstructionSelector {
public:
  AIEInstructionSelector(const AIETargetMachine &TM, const AIESubtarget &STI,
                         const RegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;
  bool selectG_ZEXT(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_SEXT_INREG(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_PTR_ADD(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_LOAD(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_IMPLICIT_DEF(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_GLOBAL_VALUE(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_CONSTANT(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_FCONSTANT(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_BRCOND(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_BRINDIRECT(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectG_JUMP_TABLE(MachineInstr &I, MachineRegisterInfo &MRI);
  bool selectPHI(MachineInstr &I, MachineRegisterInfo &MRI);

  static const char *getName() { return DEBUG_TYPE; }

  void setupMF(MachineFunction &MF, GISelKnownBits *KB,
               CodeGenCoverage *CoverageInfo, ProfileSummaryInfo *PSI,
               BlockFrequencyInfo *BFI) override {
    InstructionSelector::setupMF(MF, KB, CoverageInfo, PSI, BFI);
    MIB.setMF(MF);
  }

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;

  void renderFrameIndex(MachineInstrBuilder &MIB, const MachineInstr &MI,
                        int OpIdx) const;

  // const AIETargetMachine &TM;
  const AIEInstrInfo &TII;
  const AIERegisterInfo &TRI;
  const RegisterBankInfo &RBI;

  MachineIRBuilder MIB;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "AIEGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "AIEGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "AIEGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

AIEInstructionSelector::AIEInstructionSelector(const AIETargetMachine &TM,
                                               const AIESubtarget &STI,
                                               const RegisterBankInfo &RBI)
    : InstructionSelector(), /*TM(TM),*/ TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "AIEGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "AIEGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

void AIEInstructionSelector::renderFrameIndex(MachineInstrBuilder &MIB,
                                              const MachineInstr &MI,
                                              int OpIdx) const {
  MIB.addFrameIndex((MI.getOperand(1).getIndex()));
}

/// Given a register bank, return the smallest register class
/// that can hold a value on that bank
static const TargetRegisterClass *
getMinClassForRegBank(const RegisterBank &RB) {
  unsigned RegBankID = RB.getID();

  if (RegBankID == AIE::GPRRegBankID) {
    return &AIE::GPRRegClass;
  }

  if (RegBankID == AIE::PTRRegBankID) {
    return &AIE::PTRRegClass;
  }

  if (RegBankID == AIE::MODRegBankID) {
    return &AIE::MODRegClass;
  }

  if (RegBankID == AIE::CBRegBankID) {
    return &AIE::mCSRegClass;
  }

  return nullptr;
}

static bool selectCopy(MachineInstr &I, MachineRegisterInfo &MRI,
                       const TargetRegisterInfo &TRI,
                       const RegisterBankInfo &RBI) {

  for (const MachineOperand &MO : I.operands()) {
    if (MO.getReg().isPhysical())
      continue;

    const RegisterBank &RB = *RBI.getRegBank(MO.getReg(), MRI, TRI);
    const auto *RC = getMinClassForRegBank(RB);
    if (!RC)
      continue;
    if (!RBI.constrainGenericRegister(MO.getReg(), *RC, MRI))
      return false;
  }

  return true;
}

bool AIEInstructionSelector::selectG_ZEXT(MachineInstr &I,
                                          MachineRegisterInfo &MRI) {
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();

  const RegisterBank *DstRB = RBI.getRegBank(DstReg, MRI, TRI);
  const RegisterBank *SrcRB = RBI.getRegBank(SrcReg, MRI, TRI);

  assert(((DstRB != SrcRB) || (DstRB->getID() != AIE::PTRRegBankID)) &&
         "Cannot extend to 32-bits on 20-bit registers");

  if (DstRB->getID() == SrcRB->getID()) {
    auto Zext = MIB.buildInstr(AIE::MOVT_S12, {DstReg}, {SrcReg}).addImm(0);
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*Zext, TII, TRI, RBI);
  }

  I.setDesc(TII.get(AIE::COPY));
  return selectCopy(I, MRI, TRI, RBI);
}

bool AIEInstructionSelector::selectG_SEXT_INREG(MachineInstr &I,
                                                MachineRegisterInfo &MRI) {
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();

  const RegisterBank *DstRB = RBI.getRegBank(DstReg, MRI, TRI);
  const RegisterBank *SrcRB = RBI.getRegBank(SrcReg, MRI, TRI);

  // We only support sign-extension on GPRs
  if (DstRB->getID() != SrcRB->getID() || DstRB->getID() != AIE::GPRRegBankID)
    return false;

  int64_t Imm = I.getOperand(2).getImm();
  MachineInstrBuilder MI;
  if (Imm == 8) {
    MI = MIB.buildInstr(AIE::SE8, {DstReg}, {SrcReg});
  } else if (Imm == 16) {
    MI = MIB.buildInstr(AIE::SE16, {DstReg}, {SrcReg});
  } else {
    if (Imm < 0 || Imm > 32)
      return false;

    // Expand sext_inreg into ashr (shl reg, amnt), amnt
    auto SHLAmt =
        MIB.buildInstr(AIE::MOV_S12, {&AIE::GPRRegClass}, {}).addImm(32 - Imm);
    MI = MIB.buildInstr(AIE::LSHL, {&AIE::GPRRegClass},
                        {SrcReg, SHLAmt.getReg(0)});
    auto SHRAmt = MIB.buildInstr(AIE::MOV_S12, {&AIE::GPRRegClass}, {})
                      .addImm(-(32 - Imm));
    MI = MIB.buildInstr(AIE::ASHL, {DstReg}, {MI.getReg(0), SHRAmt.getReg(0)});
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool AIEInstructionSelector::selectG_PTR_ADD(MachineInstr &I,
                                             MachineRegisterInfo &MRI) {
  Register DstReg = I.getOperand(0).getReg();
  Register Src1Reg = I.getOperand(1).getReg();
  Register Src2Reg = I.getOperand(2).getReg();

  const RegisterBank *DstRB = RBI.getRegBank(DstReg, MRI, TRI);
  const RegisterBank *Src1RB = RBI.getRegBank(Src1Reg, MRI, TRI);
  const RegisterBank *Src2RB = RBI.getRegBank(Src2Reg, MRI, TRI);

  // Pointer addition on GPRs is a simple ADD, and requires all operands in GPRs
  if (DstRB->getID() == AIE::GPRRegBankID) {
    if (Src1RB->getID() != AIE::GPRRegBankID ||
        Src1RB->getID() != Src2RB->getID())
      return false;

    // FIXME: Constants on the RHS could be folded into the ADD instruction by
    // relying on the TableGen patterns for G_ADD on GPRRegbank
    I.setDesc(TII.get(AIE::ADD));
    return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
  }

  if (DstRB->getID() != AIE::PTRRegBankID ||
      Src1RB->getID() != AIE::PTRRegBankID ||
      Src2RB->getID() != AIE::MODRegBankID)
    return false;

  I.setDesc(TII.get(AIE::PADDA_nrm));
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool AIEInstructionSelector::selectG_LOAD(MachineInstr &I,
                                          MachineRegisterInfo &MRI) {
  Register DstReg = I.getOperand(0).getReg();
  Register PtrReg = I.getOperand(1).getReg();

  const unsigned DstRB = RBI.getRegBank(DstReg, MRI, TRI)->getID();
  const unsigned PtrRB = RBI.getRegBank(PtrReg, MRI, TRI)->getID();

  // The pointer needs to reside in PTRs
  if (PtrRB != AIE::PTRRegBankID)
    return false;

  if (DstRB != AIE::PTRRegBankID)
    return selectImpl(I, *CoverageInfo);

  MIB.buildInstr(AIE::LDA_ind_PTR, {DstReg}, {PtrReg});

  I.eraseFromParent();
  return RBI.constrainGenericRegister(DstReg, AIE::PTRRegClass, MRI);
}

bool AIEInstructionSelector::selectG_IMPLICIT_DEF(MachineInstr &I,
                                                  MachineRegisterInfo &MRI) {
  I.setDesc(TII.get(TargetOpcode::IMPLICIT_DEF));
  // Make sure no input operands are passed to IMPLICIT_DEF
  while (I.getNumOperands() > 1)
    I.removeOperand(1);
  const Register DstReg = I.getOperand(0).getReg();
  const RegisterBank &DstRB = *RBI.getRegBank(DstReg, MRI, TRI);
  const TargetRegisterClass *RC = getMinClassForRegBank(DstRB);
  return RBI.constrainGenericRegister(DstReg, *RC, MRI);
}

bool AIEInstructionSelector::selectG_GLOBAL_VALUE(MachineInstr &I,
                                                  MachineRegisterInfo &MRI) {
  I.setDesc(TII.get(AIE::MOV_U20));
  const Register DstReg = I.getOperand(0).getReg();
  const RegisterBank &DstRB = *RBI.getRegBank(DstReg, MRI, TRI);

  const TargetRegisterClass *RC = DstRB.getID() == AIE::PTRRegBankID
                                      ? &AIE::GPRPTRMOD_and_PTRRegClass
                                      : &AIE::GPRRegClass;
  return RBI.constrainGenericRegister(DstReg, *RC, MRI);
}

bool AIEInstructionSelector::selectG_CONSTANT(MachineInstr &I,
                                              MachineRegisterInfo &MRI) {
  const Register DstReg = I.getOperand(0).getReg();
  const LLT Ty = MRI.getType(DstReg);
  // If the register class has already been constrained by the user of this
  // constant, we can fallback to the TableGen'ed selection code which creates
  // "smarter" MOV_ instructions using predicates for the immediate.
  //
  // If the reg class wasn't fixed, the Tablegen code would create an extra copy
  // to the gprregbank: the constant is materialized in a mmv0cg20 reg, and the
  // gpr reg bank does not cover that class, hence the extra copy. The problem
  // is that the extra copy isn't legal (no class assigned).  E.g.
  //   %1:mmv0cg20 = MOV_U20 1048575
  //   %0:gprregbank(s32) = COPY %1:mmv0cg20
  //
  // Also, we can only use the Tablegen ISel code for constants on GPRs because
  // we decided that the register bank corresponding to the mmv0cg20 class is
  // the gprregbank. (See AIERegisterBankInfo::getRegBankFromRegClass).
  // Therefore the tablegen Isel code would fail to select a constant on a PTR:
  // getRegBankFromRegClass(mmv0cg20) is gprregbank, while the reg bank for the
  // G_CONSTANT would be ptrregbank.
  if (const TargetRegisterClass *RC = MRI.getRegClassOrNull(DstReg)) {
    if (RBI.getRegBankFromRegClass(*RC, Ty).getID() == AIE::GPRRegBankID) {
      // Not all Tablegen patterns are supported by GISel
      if (selectImpl(I, *CoverageInfo))
        return true;
    }
  }

  uint64_t Imm = I.getOperand(1).getCImm()->getZExtValue();
  const RegisterBank &DstRB = *RBI.getRegBank(DstReg, MRI, TRI);
  if (DstRB.getID() == AIE::GPRRegBankID) {
    if (Ty == LLT::scalar(32)) {
      Register ScratchReg = MRI.createVirtualRegister(&AIE::GPRRegClass);
      MIB.buildInstr(AIE::MOV_U20, {ScratchReg}, {}).addImm(Imm & 0xfffff);
      MIB.buildInstr(AIE::MOVT_S12, {DstReg}, {ScratchReg})
          .addImm((Imm >> 20) & 0xfff);
    } else {
      assert((Ty == LLT::pointer(0, 20) || Ty == LLT::scalar(20)) &&
             "Only support 20, 32-bit integer and 20-bit pointer constants");
      MIB.buildInstr(AIE::MOV_U20, {DstReg}, {}).addImm(Imm & 0xfffff);
    }
    RBI.constrainGenericRegister(DstReg, AIE::GPRRegClass, MRI);
  } else {
    assert(DstRB.getID() == AIE::PTRRegBankID &&
           "Expected constants only on GPR and PTR register banks");
    assert((Ty == LLT::pointer(0, 20) || Ty == LLT::scalar(20)) &&
           "Only support pointer, i20 typed constants on PTR register banks");
    MIB.buildInstr(AIE::MOV_U20, {DstReg}, {}).addImm(Imm & 0xfffff);
    RBI.constrainGenericRegister(DstReg, AIE::GPRPTRMOD_and_PTRRegClass, MRI);
  }
  I.removeFromParent();
  return true;
}

bool AIEInstructionSelector::selectG_FCONSTANT(MachineInstr &I,
                                               MachineRegisterInfo &MRI) {
  const Register DstReg = I.getOperand(0).getReg();
  const LLT Ty = MRI.getType(DstReg);

  // Doing bitwise conversion to split it into two.
  uint64_t Imm =
      I.getOperand(1).getFPImm()->getValue().bitcastToAPInt().getZExtValue();
  const RegisterBank &DstRB = *RBI.getRegBank(DstReg, MRI, TRI);
  assert(DstRB.getID() == AIE::GPRRegBankID &&
         "Expected float point constants only on GPR");
  assert(Ty == LLT::scalar(32) && "Expected f32");

  Register ScratchReg = MRI.createVirtualRegister(&AIE::GPRRegClass);
  MIB.buildInstr(AIE::MOV_U20, {ScratchReg}, {}).addImm(Imm & 0xfffff);
  MIB.buildInstr(AIE::MOVT_S12, {DstReg}, {ScratchReg})
      .addImm((Imm >> 20) & 0xfff);

  RBI.constrainGenericRegister(DstReg, AIE::GPRRegClass, MRI);
  I.removeFromParent();
  return true;
}

bool AIEInstructionSelector::selectG_BRCOND(MachineInstr &I,
                                            MachineRegisterInfo &MRI) {
  assert((I.getOpcode() == TargetOpcode::G_BRCOND) && "unexpected instruction");

  Register CondReg = I.getOperand(0).getReg();
  MachineBasicBlock *DestMBB = I.getOperand(1).getMBB();

  const unsigned CondRB = RBI.getRegBank(CondReg, MRI, TRI)->getID();

  // The pointer needs to reside in GPRs
  if (CondRB != AIE::GPRRegBankID)
    return false;

  MIB.buildInstr(AIE::BNEZ, {}, {CondReg}).addMBB(DestMBB);

  I.eraseFromParent();
  return true;
}

bool AIEInstructionSelector::selectG_BRINDIRECT(MachineInstr &I,
                                                MachineRegisterInfo &MRI) {
  I.setDesc(TII.get(AIE::JA));
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool AIEInstructionSelector::selectG_JUMP_TABLE(MachineInstr &I,
                                                MachineRegisterInfo &MRI) {
  I.setDesc(TII.get(AIE::MOV_U20));
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool AIEInstructionSelector::selectPHI(MachineInstr &I,
                                       MachineRegisterInfo &MRI) {
  const Register DstReg = I.getOperand(0).getReg();
  const LLT Ty = MRI.getType(DstReg);
  const RegClassOrRegBank &RegClassOrBank = MRI.getRegClassOrRegBank(DstReg);
  const TargetRegisterClass *DstRC =
      RegClassOrBank.dyn_cast<const TargetRegisterClass *>();
  if (!DstRC) {
    if (!Ty.isValid()) {
      LLVM_DEBUG(dbgs() << "PHI without a type and regclass!?");
      return false;
    }

    const RegisterBank &RB = *RegClassOrBank.get<const RegisterBank *>();
    DstRC = getMinClassForRegBank(RB);
    if (!DstRC) {
      LLVM_DEBUG(
          dbgs() << "Couldn't retrieve register class from register bank");
      return false;
    }
  }
  I.setDesc(TII.get(TargetOpcode::PHI));
  return RBI.constrainGenericRegister(DstReg, *DstRC, MRI);
}

bool AIEInstructionSelector::select(MachineInstr &I) {

  MachineFunction &MF = *I.getParent()->getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  if (I.isPHI())
    return selectPHI(I, MRI);

  if (!I.isPreISelOpcode()) {

    if (I.isCopy())
      return selectCopy(I, MRI, TRI, RBI);
    return true;
  }

  MIB.setInstrAndDebugLoc(I);
  using namespace TargetOpcode;

  switch (I.getOpcode()) {
  case G_FREEZE:
  case G_PTRTOINT:
  case G_INTTOPTR:
  case G_TRUNC:
    I.setDesc(TII.get(COPY));
    return selectCopy(I, MRI, TRI, RBI);
  case G_ZEXT:
    return selectG_ZEXT(I, MRI);
  case G_SEXT_INREG:
    return selectG_SEXT_INREG(I, MRI);
  case G_PTR_ADD:
    return selectG_PTR_ADD(I, MRI);
  case G_LOAD:
    return selectG_LOAD(I, MRI);
  case G_CONSTANT:
    return selectG_CONSTANT(I, MRI);
  case G_FCONSTANT:
    return selectG_FCONSTANT(I, MRI);
  case G_GLOBAL_VALUE:
    return selectG_GLOBAL_VALUE(I, MRI);
  case G_IMPLICIT_DEF:
    return selectG_IMPLICIT_DEF(I, MRI);
  case G_BRCOND:
    return selectG_BRCOND(I, MRI);
  case G_BRINDIRECT:
    return selectG_BRINDIRECT(I, MRI);
  case G_JUMP_TABLE:
    return selectG_JUMP_TABLE(I, MRI);
  default:
    return selectImpl(I, *CoverageInfo);
  }

  return false;
}

namespace llvm {
InstructionSelector *createAIEInstructionSelector(const AIETargetMachine &TM,
                                                  AIESubtarget &Subtarget,
                                                  RegisterBankInfo &RBI) {
  return new AIEInstructionSelector(TM, Subtarget, RBI);
}
} // end namespace llvm
