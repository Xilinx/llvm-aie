//===- AIERegisterBankInfo.cpp --------------------------------------------===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the RegisterBankInfo class for AIE.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "AIEBaseRegisterBankInfo.h"
#include "AIEInstrInfo.h"
#include "AIERegisterInfo.h"
#include "MCTargetDesc/AIEMCTargetDesc.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/Support/Debug.h"

using namespace llvm;

unsigned AIEBaseRegisterBankInfo::getRegBankBaseIdxOffset(unsigned RBIdx,
                                                          unsigned Size) {
  if (RBIdx == PMI_GPR) {
    if (Size <= 32)
      return 0;
    return -1;
  }
  if (RBIdx == PMI_GPR64) {
    if (Size <= 64)
      return 0;
    return -1;
  }

  if (RBIdx == PMI_PTR) {
    if (Size <= 20)
      return 0;
    return -1;
  }

  if (RBIdx == PMI_MOD) {
    if (Size <= 20)
      return 0;
    return -1;
  }

  if (RBIdx == PMI_CB) {
    if (Size <= 20)
      return 0;
    return -1;
  }
  if (RBIdx == PMI_VREG128) {
    if (Size <= 128)
      return 0;
    return -1;
  }
  if (RBIdx == PMI_VREG256) {
    if (Size <= 256)
      return 0;
    return -1;
  }
  if (RBIdx == PMI_VREG512) {
    if (Size <= 512)
      return 0;
    return -1;
  }
  if (RBIdx == PMI_VREG1024) {
    if (Size <= 1024)
      return 0;
    return -1;
  }
  if (RBIdx == PMI_ACC256) {
    if (Size <= 256)
      return 0;
    return -1;
  }
  if (RBIdx == PMI_ACC512) {
    if (Size <= 512)
      return 0;
    return -1;
  }
  if (RBIdx == PMI_ACC1024) {
    if (Size <= 1024)
      return 0;
    return -1;
  }
  return -1;
}

RegisterBankInfo::InstructionMappings
AIEBaseRegisterBankInfo::getInstrAlternativeMappings(
    const MachineInstr &MI) const {

  switch (MI.getOpcode()) {
  case TargetOpcode::G_TRUNC: {
    InstructionMappings AltMappings;
    const InstructionMapping &GPRMapping = getInstructionMapping(
        /*ID*/ 1, /*Cost*/ 1,
        getOperandsMapping(
            {getValueMapping(PMI_GPR, 20), getValueMapping(PMI_GPR, 32)}),
        /*NumOperands*/ 2);
    const InstructionMapping &PTRGPRMapping = getInstructionMapping(
        /*ID*/ 2, /*Cost*/ 1,
        getOperandsMapping(
            {getValueMapping(PMI_PTR, 20), getValueMapping(PMI_GPR, 32)}),
        /*NumOperands*/ 2);

    AltMappings.push_back(&GPRMapping);
    AltMappings.push_back(&PTRGPRMapping);
    return AltMappings;
  }
  case TargetOpcode::G_ANYEXT:
  case TargetOpcode::G_SEXT:
  case TargetOpcode::G_ZEXT: {
    InstructionMappings AltMappings;
    const InstructionMapping &GPRMapping = getInstructionMapping(
        /*ID*/ 1, /*Cost*/ 1,
        getOperandsMapping(
            {getValueMapping(PMI_GPR, 32), getValueMapping(PMI_GPR, 20)}),
        /*NumOperands*/ 2);

    AltMappings.push_back(&GPRMapping);
    return AltMappings;
  }
  case TargetOpcode::G_PTR_ADD: {
    InstructionMappings AltMappings;
    const InstructionMapping &GPRMapping =
        getInstructionMapping(1, 1, getValueMapping(PMI_GPR, 32), 3);
    const InstructionMapping &PTRGPRMapping = getInstructionMapping(
        /*ID*/ 2, /*Cost*/ 1,
        getOperandsMapping({getValueMapping(PMI_PTR, 20),
                            getValueMapping(PMI_PTR, 20),
                            getValueMapping(PMI_MOD, 20)}),
        /*NumOperands*/ 3);

    AltMappings.push_back(&GPRMapping);
    AltMappings.push_back(&PTRGPRMapping);
    return AltMappings;
  }
  case TargetOpcode::G_INTTOPTR: {
    InstructionMappings AltMappings;
    const InstructionMapping &GPRMapping =
        getInstructionMapping(1, 1, getValueMapping(PMI_GPR, 32), 2);
    const InstructionMapping &PTRMapping = getInstructionMapping(
        /*ID*/ 2, /*Cost*/ 1,
        getOperandsMapping(
            {getValueMapping(PMI_PTR, 20), getValueMapping(PMI_PTR, 20)}),
        /*NumOperands*/ 2);
    const InstructionMapping &PTRGPRMapping = getInstructionMapping(
        /*ID*/ 3, /*Cost*/ 1,
        getOperandsMapping(
            {getValueMapping(PMI_GPR, 20), getValueMapping(PMI_PTR, 20)}),
        /*NumOperands*/ 2);

    AltMappings.push_back(&GPRMapping);
    AltMappings.push_back(&PTRMapping);
    AltMappings.push_back(&PTRGPRMapping);
    return AltMappings;
  }
  default:
    break;
  }
  return RegisterBankInfo::getInstrAlternativeMappings(MI);
}

void AIEBaseRegisterBankInfo::applyMappingImpl(
    MachineIRBuilder &Builder,
    const OperandsMapper &OpdMapper) const {
  switch (OpdMapper.getMI().getOpcode()) {
  case TargetOpcode::G_ANYEXT:
  case TargetOpcode::G_SEXT:
  case TargetOpcode::G_ZEXT:
    // Those ID must match getInstrAlternativeMappings.
    assert(OpdMapper.getInstrMapping().getID() == 1 &&
           "Don't know how to handle that ID");
    return applyDefaultMapping(OpdMapper);
  case TargetOpcode::G_TRUNC:
  case TargetOpcode::G_PTR_ADD:
    // Those ID must match getInstrAlternativeMappings.
    assert((OpdMapper.getInstrMapping().getID() >= 1 &&
            OpdMapper.getInstrMapping().getID() <= 2) &&
           "Don't know how to handle that ID");
    return applyDefaultMapping(OpdMapper);
  case TargetOpcode::G_INTTOPTR:
    // Those ID must match getInstrAlternativeMappings.
    assert((OpdMapper.getInstrMapping().getID() >= 1 &&
            OpdMapper.getInstrMapping().getID() <= 3) &&
           "Don't know how to handle that ID");
    return applyDefaultMapping(OpdMapper);
  default:
    llvm_unreachable("Don't know how to handle that operation");
  }
}

const RegisterBankInfo::InstructionMapping &
AIEBaseRegisterBankInfo::getSameKindOfOperandsMapping(
    const MachineInstr &MI) const {
  const MachineFunction &MF = *MI.getParent()->getParent();
  const MachineRegisterInfo &MRI = MF.getRegInfo();

  unsigned NumOperands = MI.getNumOperands();
  assert(NumOperands <= 3 &&
         "This code is for instructions with 3 or less operands");

  LLT Ty = MRI.getType(MI.getOperand(0).getReg());
  unsigned Size = Ty.getSizeInBits();

  PartialMappingIdx RBIdx = getPartialMappingIdx(Ty);

  return getInstructionMapping(DefaultMappingID, 1,
                               getValueMapping(RBIdx, Size), NumOperands);
}

AIEBaseRegisterBankInfo::PartialMappingIdx
AIEBaseRegisterBankInfo::getPartialMappingIdx(const LLT &Ty) {
  LLT ElemTy = Ty.getScalarType();
  // As a top-level guess, pointers go in PTRs, 20bit scalar go in MODs
  // and all other integers go in GPRs.
  if (Ty.isPointer())
    return PMI_PTR;
  else if (Ty.isScalar()) {
    unsigned short ScalarSize = Ty.getScalarSizeInBits();
    return ScalarSize <= 32 ? (ScalarSize == 20 ? PMI_MOD : PMI_GPR)
                            : (ScalarSize <= 64 ? PMI_GPR64 : PMI_VREG128);
  } else {
    switch (Ty.getSizeInBits()) {
    case 32:
      return PMI_GPR;
    case 64:
      return PMI_GPR64;
    case 128:
    case 256:
      return (ElemTy.getSizeInBits() == 64) ? PMI_ACC256 : PMI_VREG256;
    case 512:
      return (ElemTy.getSizeInBits() == 64) ? PMI_ACC512 : PMI_VREG512;
    case 1024: {
      return (ElemTy.getSizeInBits() == 64) ? PMI_ACC1024 : PMI_VREG1024;
    }
    default:
      llvm_unreachable("Unsupported register size.");
    }
  }
  return PMI_None;
}

bool AIEBaseRegisterBankInfo::requiresGPRRegBank(const MachineInstr &MI,
                                                 const MachineRegisterInfo &MRI,
                                                 unsigned Depth) const {
  switch (MI.getOpcode()) {
  case TargetOpcode::G_ANYEXT:
  case TargetOpcode::G_SEXT:
  case TargetOpcode::G_ZEXT:
    return true;
  default:
    break;
  }

  if (!MI.isPHI() || Depth > 3)
    return false;

  return any_of(MRI.use_nodbg_instructions(MI.getOperand(0).getReg()),
                [&](const MachineInstr &UseMI) {
                  return requiresGPRRegBank(UseMI, MRI, Depth + 1);
                });
}

bool AIEBaseRegisterBankInfo::requiresPTRRegBank(const MachineInstr &MI,
                                                 const MachineRegisterInfo &MRI,
                                                 unsigned Depth) const {
  switch (MI.getOpcode()) {
  case TargetOpcode::G_INTTOPTR:
    return true;
  default:
    break;
  }
  return false;
}

const RegisterBankInfo::InstructionMapping &
AIEBaseRegisterBankInfo::getInstrMapping(const MachineInstr &MI) const {
  const unsigned Opc = MI.getOpcode();

  // Try the default logic for non-generic instructions that are either copies
  // or already have some operands assigned to banks.
  if (!isPreISelGenericOpcode(Opc) || Opc == TargetOpcode::G_PHI) {
    const RegisterBankInfo::InstructionMapping &Mapping =
        getInstrMappingImpl(MI);
    if (Mapping.isValid())
      return Mapping;
  }

  const MachineFunction &MF = *MI.getParent()->getParent();
  const MachineRegisterInfo &MRI = MF.getRegInfo();

  // Use stating mappings if possible.
  // TODO: Benchmark if this is worth it instead of falling back to a
  // dynamic approach.
  switch (Opc) {
  // Arithmetic ops.
  case TargetOpcode::G_ADD:
  case TargetOpcode::G_SUB:
  case TargetOpcode::G_MUL:
  case TargetOpcode::G_AND:
  case TargetOpcode::G_OR:
  case TargetOpcode::G_XOR:
  case TargetOpcode::G_SHL:
  case TargetOpcode::G_LSHR:
  case TargetOpcode::G_ASHR:
    return getSameKindOfOperandsMapping(MI);
  case TargetOpcode::G_INTTOPTR: {
    // Before a pointer can be used as an address, it needs to be moved to a
    // pointer register. Thus, by default we do the int to pointer cast on the
    // pointer register bank
    return getSameKindOfOperandsMapping(MI);
  }
  case TargetOpcode::G_PTR_ADD: {
    return getInstructionMapping(
        /*ID*/ 2, /*Cost*/ 1,
        getOperandsMapping({getValueMapping(PMI_PTR, 20),
                            getValueMapping(PMI_PTR, 20),
                            getValueMapping(PMI_MOD, 20)}),
        /*NumOperands*/ 3);
  }
  default:
    break;
  }

  const unsigned NumOperands = MI.getNumOperands();
  unsigned Cost = 1;

  // Track the size and bank of each register..
  SmallVector<unsigned, 4> OpSize(NumOperands);
  SmallVector<PartialMappingIdx, 4> OpRegBankIdx(NumOperands);
  for (unsigned Idx = 0; Idx < NumOperands; ++Idx) {
    const auto &MO = MI.getOperand(Idx);
    if (!MO.isReg() || !MO.getReg())
      continue;

    LLT Ty = MRI.getType(MO.getReg());
    if (!Ty.isValid())
      continue;
    OpSize[Idx] = Ty.getSizeInBits();
    OpRegBankIdx[Idx] = getPartialMappingIdx(MRI.getType(MO.getReg()));
  }

  // Some of the instructions require fine tuning of the mapping computed above
  switch (Opc) {
  case TargetOpcode::G_ICMP: {
    // Scalar and pointer comparisons are only supported on GPRs, but we might
    // have assigned pointers to PTRs
    OpRegBankIdx[2] = PMI_GPR;
    OpRegBankIdx[3] = PMI_GPR;
    break;
  }
  case TargetOpcode::G_SELECT: {
    // Pointers are selected on GPRs
    if (OpSize[0] == 20)
      OpRegBankIdx = {PMI_GPR, PMI_GPR, PMI_GPR, PMI_GPR};
    break;
  }
  case TargetOpcode::G_FRAME_INDEX: {
    OpRegBankIdx = {PMI_PTR};
    break;
  }
  case TargetOpcode::G_CONSTANT: {
    if (OpSize[0] != 20)
      break;
    [[fallthrough]];
  }
  case TargetOpcode::G_PTRTOINT:
  case TargetOpcode::G_TRUNC: {
    if (any_of(MRI.use_nodbg_instructions(MI.getOperand(0).getReg()),
               [&](const MachineInstr &UseMI) {
                 return requiresGPRRegBank(UseMI, MRI, 0);
               })) {
      OpRegBankIdx[0] = PMI_GPR;
      break;
    }

    if (any_of(MRI.use_nodbg_instructions(MI.getOperand(0).getReg()),
               [&](const MachineInstr &UseMI) {
                 return requiresPTRRegBank(UseMI, MRI, 0);
               })) {
      OpRegBankIdx[0] = PMI_PTR;
      break;
    }
    break;
  }
  }

  // Tweak banks for AIE-generic instruction. Those have the same names across
  // AIE versions, but not necessarily the same OpCode enum value. Handle them
  // in version-specific code.
  setAIEGenericInstrMapping(MI, OpSize, OpRegBankIdx);

  // Finally construct the computed mapping.
  return getInstrMappingFinal(MI, Cost, OpSize, OpRegBankIdx);
}

// Construct the computed mapping.
const RegisterBankInfo::InstructionMapping &
AIEBaseRegisterBankInfo::getInstrMappingFinal(
    const MachineInstr &MI, unsigned Cost,
    const SmallVector<unsigned, 4> &OpSize,
    const SmallVector<PartialMappingIdx, 4> &OpRegBankIdx) const {

  const MachineFunction &MF = *MI.getParent()->getParent();
  const MachineRegisterInfo &MRI = MF.getRegInfo();
  const unsigned NumOperands = MI.getNumOperands();
  SmallVector<const ValueMapping *, 8> OpdsMapping(NumOperands);
  for (unsigned Idx = 0; Idx < NumOperands; ++Idx) {
    if (MI.getOperand(Idx).isReg() && MI.getOperand(Idx).getReg()) {
      LLT Ty = MRI.getType(MI.getOperand(Idx).getReg());
      if (!Ty.isValid())
        continue;
      const auto *Mapping = getValueMapping(OpRegBankIdx[Idx], OpSize[Idx]);
      if (!Mapping->isValid())
        return getInvalidInstructionMapping();

      OpdsMapping[Idx] = Mapping;
    }
  }

  return getInstructionMapping(DefaultMappingID, Cost,
                               getOperandsMapping(OpdsMapping), NumOperands);
}
