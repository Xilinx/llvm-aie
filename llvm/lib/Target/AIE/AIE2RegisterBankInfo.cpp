//===- AIE2RegisterBankInfo.cpp -------------------------------------------===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the RegisterBankInfo class for
//  AIEngine V2.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "AIE2RegisterBankInfo.h"
#include "AIE2InstrInfo.h"
#include "AIE2RegisterInfo.h"
#include "MCTargetDesc/AIE2MCTargetDesc.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/IR/IntrinsicsAIE2.h"
#include "llvm/Support/Debug.h"

#define GET_TARGET_REGBANK_IMPL

#include "AIE2GenRegisterBank.inc"
using namespace llvm;

RegisterBankInfo::PartialMapping AIE2GenRegisterBankInfo::PartMappings[]{
    // StartIdx, Length, RegBank
    // 0: GPR 32-bit value
    {0, 32, AIE2::GPRRegBank},
    // 1: PTR 20-bit value
    {0, 20, AIE2::PTRRegBank},
    // 2: MOD 20-bit value
    {0, 20, AIE2::MODRegBank},
    // 3(PMI_CB)
    {},
    // 4: GPR 64-bit value
    {0, 64, AIE2::GPRRegBank},
    // 5(undef),6(undef)
    {},
    {},
    // 7: VREG 256-bit value
    {0, 256, AIE2::VRegBank},
    // 8: VREG 512-bit value
    {0, 512, AIE2::VRegBank},
    // 9: VREG 1024-bit value
    {0, 1024, AIE2::VRegBank},
    // 10: AccREG 256-bit value
    {0, 256, AIE2::AccRegBank},
    // 11: AccREG 512-bit value
    {0, 512, AIE2::AccRegBank},
    // 12: AccREG 1024-bit value
    {0, 1024, AIE2::AccRegBank},
};

// ValueMappings.
RegisterBankInfo::ValueMapping AIE2GenRegisterBankInfo::ValMappings[]{
    /* BreakDown, NumBreakDowns */
    // 0: invalid
    {nullptr, 0},
    // 3-operands instructions
    // 1: GPR 32-bit value. <-- This must match First3OpsIdx.
    {&PartMappings[PMI_GPR - PMI_Min], 1},
    {&PartMappings[PMI_GPR - PMI_Min], 1},
    {&PartMappings[PMI_GPR - PMI_Min], 1},
    // 4: PTR 20-bit value.
    {&PartMappings[PMI_PTR - PMI_Min], 1},
    {&PartMappings[PMI_PTR - PMI_Min], 1},
    {&PartMappings[PMI_PTR - PMI_Min], 1},
    // 7: MOD 20-bit value. <-- This must match Last3OpsIdx
    {&PartMappings[PMI_MOD - PMI_Min], 1},
    {&PartMappings[PMI_MOD - PMI_Min], 1},
    {&PartMappings[PMI_MOD - PMI_Min], 1},
    // 10: AIE1's CB:
    {},
    {},
    {},
    // 13: GPR 64-bit value.
    {&PartMappings[PMI_GPR64 - PMI_Min], 1},
    {&PartMappings[PMI_GPR64 - PMI_Min], 1},
    {&PartMappings[PMI_GPR64 - PMI_Min], 1},
    // 16:
    {&PartMappings[PMI_VREG256 - PMI_Min], 1},
    {&PartMappings[PMI_VREG256 - PMI_Min], 1},
    {&PartMappings[PMI_VREG256 - PMI_Min], 1},
    // 19:
    {&PartMappings[PMI_VREG512 - PMI_Min], 1},
    {&PartMappings[PMI_VREG512 - PMI_Min], 1},
    {&PartMappings[PMI_VREG512 - PMI_Min], 1},
    // 22:
    {&PartMappings[PMI_VREG1024 - PMI_Min], 1},
    {&PartMappings[PMI_VREG1024 - PMI_Min], 1},
    {&PartMappings[PMI_VREG1024 - PMI_Min], 1},
    // 25:
    {&PartMappings[PMI_ACC256 - PMI_Min], 1},
    // 26:
    {&PartMappings[PMI_ACC512 - PMI_Min], 1},
    // 27:
    {&PartMappings[PMI_ACC1024 - PMI_Min], 1},
};

const RegisterBankInfo::ValueMapping *
AIE2GenRegisterBankInfo::getValueMapping(PartialMappingIdx RBIdx,
                                         unsigned Size) const {
  assert(RBIdx != PartialMappingIdx::PMI_None && "No mapping needed for that");
  unsigned BaseIdxOffset = getRegBankBaseIdxOffset(RBIdx, Size);
  if (BaseIdxOffset == -1u)
    return &ValMappings[InvalidIdx];

  unsigned ValMappingIdx;
  PartialMappingIdx PMIdx;
  ValueMappingIdx VMIdx = ValueMappingIdx::First3OpsIdx;
  ValueMappingIdx DistRegBanks = ValueMappingIdx::DistanceBetweenRegBanks;
  switch (RBIdx) {
  case PMI_GPR:
  case PMI_PTR:
  case PMI_MOD:
  case PMI_GPR64:
    PMIdx = PartialMappingIdx::PMI_Min;
    break;
  case PMI_VREG256:
  case PMI_VREG512:
  case PMI_VREG1024:
    PMIdx = PartialMappingIdx::PMI_VREGMin;
    VMIdx = ValueMappingIdx::FirstVecOpsIdx;
    break;
  case PMI_ACC256:
  case PMI_ACC512:
  case PMI_ACC1024:
    PMIdx = PartialMappingIdx::PMI_ACC256;
    DistRegBanks = ValueMappingIdx::DistanceBetweenAccRegBanks;
    VMIdx = ValueMappingIdx::FirstAccOpsIdx;
    break;
  default:
    llvm_unreachable("Unsupported PartialMappingIdx.");
  }
  ValMappingIdx = VMIdx + (RBIdx - PMIdx + BaseIdxOffset) * DistRegBanks;
  assert(ValMappingIdx >= First3OpsIdx && ValMappingIdx <= LastOpsIdx &&
         "Mapping out of bound");
  return &ValMappings[ValMappingIdx];
}

AIE2RegisterBankInfo::AIE2RegisterBankInfo(const TargetRegisterInfo &TRI)
    : AIE2GenRegisterBankInfo() {

  static llvm::once_flag InitializeRegisterBankFlag;

  static auto InitializeRegisterBankOnce = [&]() {
    // We have only one set of register banks, whatever the subtarget
    // is. Therefore, the initialization of the RegBanks table should be
    // done only once. Indeed the table of all register banks
    // (AIE2::RegBanks) is unique in the compiler. At some point, it
    // will get tablegen'ed and the whole constructor becomes empty.

    const RegisterBank &RBGPR = getRegBank(AIE2::GPRRegBankID);
    (void)RBGPR;
    assert(&AIE2::GPRRegBank == &RBGPR && "The order in RegBanks is messed up");

    const RegisterBank &RBPTR = getRegBank(AIE2::PTRRegBankID);
    (void)RBPTR;
    assert(&AIE2::PTRRegBank == &RBPTR && "The order in RegBanks is messed up");
    const RegisterBank &RBVREG = getRegBank(AIE2::VRegBankID);
    (void)RBVREG;
    assert(&AIE2::VRegBank == &RBVREG && "The order in RegBanks is messed up");
    const RegisterBank &RBACCREG = getRegBank(AIE2::AccRegBankID);
    (void)RBACCREG;
    assert(&AIE2::AccRegBank == &RBACCREG &&
           "The order in RegBanks is messed up");
    assert(verify(TRI) && "Invalid register bank information");
  };

  llvm::call_once(InitializeRegisterBankFlag, InitializeRegisterBankOnce);
}

const RegisterBankInfo::InstructionMapping &
AIE2RegisterBankInfo::getInstrMapping(const MachineInstr &MI) const {
  const unsigned Opc = MI.getOpcode();

  const MachineFunction &MF = *MI.getParent()->getParent();
  const MachineRegisterInfo &MRI = MF.getRegInfo();

  const unsigned NumOperands = MI.getNumOperands();
  unsigned Cost = 1;

  // Track the size and bank of each register..
  SmallVector<unsigned, 4> OpSize(NumOperands);
  SmallVector<PartialMappingIdx, 4> OpRegBankIdx(NumOperands);
  const LLT S16 = LLT::scalar(16);
  const LLT S20 = LLT::scalar(20);
  const LLT S32 = LLT::scalar(32);
  const LLT S64 = LLT::scalar(64);
  switch (Opc) {
  case TargetOpcode::G_FRAME_INDEX: {
    OpSize = {20};
    OpRegBankIdx = {PMI_PTR};
    break;
  }
  case TargetOpcode::G_ZEXT: {
    LLT DstTy = MRI.getType(MI.getOperand(0).getReg());
    LLT SrcTy = MRI.getType(MI.getOperand(1).getReg());
    assert(DstTy == S32 && SrcTy == S20 &&
           "Expected to see only 20-to-32 bit extensions");
    return AIEBaseRegisterBankInfo::getInstrMapping(MI);
  }
  case TargetOpcode::G_TRUNC: {
    LLT DstTy = MRI.getType(MI.getOperand(0).getReg());
    LLT SrcTy = MRI.getType(MI.getOperand(1).getReg());
    assert((DstTy == S16 || DstTy == S20 || DstTy == S32) &&
           (SrcTy == S32 || SrcTy == S64) &&
           "Expected to see only 32-or-64 to 16-or-20-or-32 bit truncations");
    return AIEBaseRegisterBankInfo::getInstrMapping(MI);
  }
  default:
    // Base class implementation for others
    return AIEBaseRegisterBankInfo::getInstrMapping(MI);
  }

  return AIEBaseRegisterBankInfo::getInstrMappingFinal(MI, Cost, OpSize,
                                                       OpRegBankIdx);
}

void AIE2RegisterBankInfo::setAIEGenericInstrMapping(
    const MachineInstr &MI, SmallVector<unsigned, 4> &OpSize,
    SmallVector<PartialMappingIdx, 4> &OpRegBankIdx) const {
  switch (MI.getOpcode()) {
  case AIE2::G_AIE_OFFSET_STORE:
  case AIE2::G_AIE_OFFSET_LOAD:
  case AIE2::G_AIE_OFFSET_ZEXTLOAD:
  case AIE2::G_AIE_OFFSET_SEXTLOAD: {
    // Offset is operand #2
    OpRegBankIdx[2] = PMI_MOD;
    break;
  }
  case AIE2::G_AIE_POSTINC_STORE:
  case AIE2::G_AIE_POSTINC_LOAD:
  case AIE2::G_AIE_POSTINC_ZEXTLOAD:
  case AIE2::G_AIE_POSTINC_SEXTLOAD: {
    // Offset is operand #3
    OpRegBankIdx[3] = PMI_MOD;
    break;
  }
  }
}

const RegisterBank &
AIE2RegisterBankInfo::getRegBankFromRegClass(const TargetRegisterClass &RC,
                                             LLT Ty) const {
  const auto &GPRs = getRegBank(AIE2::GPRRegBankID);
  const auto &PTRs = getRegBank(AIE2::PTRRegBankID);
  const auto &MODs = getRegBank(AIE2::MODRegBankID);
  const auto &VECs = getRegBank(AIE2::VRegBankID);
  const auto &ACCs = getRegBank(AIE2::AccRegBankID);

  switch (RC.getID()) {
  case AIE2::eRRegClassID:
  case AIE2::mSsRegClassID:
  case AIE2::eRS4RegClassID:
  case AIE2::eRS8RegClassID:
  case AIE2::eR26RegClassID:
  case AIE2::eR27RegClassID:
  case AIE2::eR28RegClassID:
  case AIE2::eR29RegClassID:
  case AIE2::mSRmRegClassID:
  case AIE2::eLRegClassID:
  case AIE2::eL_with_sub_l_even_in_eRS8RegClassID:
  case AIE2::eL_with_sub_l_even_in_eRS4RegClassID:
  case AIE2::eL_with_sub_l_even_in_eR26RegClassID:
  case AIE2::eL_with_sub_l_even_in_eR28RegClassID:
    return GPRs;
  case AIE2::ePRegClassID:
  case AIE2::eP_as_32BitRegClassID:
  case AIE2::eSpecial20_as_32BitRegClassID:
    return PTRs;
  case AIE2::eMRegClassID:
  case AIE2::eM_as_32BitRegClassID:
  case AIE2::eDNRegClassID:
  case AIE2::eDJRegClassID:
  case AIE2::eDCRegClassID:
    return MODs;
  case AIE2::mLdaSclRegClassID:
  case AIE2::mMvSclDstRegClassID:
    return Ty.isPointer() ? PTRs
                          : (Ty.getScalarSizeInBits() == 20 ? MODs : GPRs);
  case AIE2::VEC128RegClassID:
  case AIE2::VEC256RegClassID:
  case AIE2::VEC512RegClassID:
  case AIE2::VEC1024RegClassID:
  case AIE2::eYsRegClassID:
  case AIE2::mXvRegClassID:
  case AIE2::mXwRegClassID:
  case AIE2::mWaRegClassID:
  case AIE2::eWHERegClassID:
  case AIE2::eWHORegClassID:
  case AIE2::eWLERegClassID:
  case AIE2::eWLORegClassID:
  case AIE2::eXERegClassID:
  case AIE2::eXORegClassID:
  case AIE2::mXaRegClassID:
  case AIE2::mXmRegClassID:
  case AIE2::mXnRegClassID:
  case AIE2::mQQmRegClassID:
  case AIE2::mQQaRegClassID:
  case AIE2::mQQsRegClassID:
    return VECs;
  case AIE2::ACC256RegClassID:
  case AIE2::ACC512RegClassID:
  case AIE2::ACC1024RegClassID:
  case AIE2::eAMLLRegClassID:
  case AIE2::eAMLHRegClassID:
  case AIE2::eAMHLRegClassID:
  case AIE2::eAMHHRegClassID:
  case AIE2::mAMmRegClassID:
  case AIE2::eBMLRegClassID:
  case AIE2::eBMHRegClassID:
  case AIE2::eBMSHRegClassID:
  case AIE2::eBMSLRegClassID:
  case AIE2::mBMmRegClassID:
  case AIE2::mBMsRegClassID:
  case AIE2::eCMRegClassID:
  case AIE2::mCMsRegClassID:
  case AIE2::ACC1024_with_sub_512_hi_in_eBMSHRegClassID:
  case AIE2::mBMaRegClassID:
    return ACCs;
  case AIE2::mShflDstRegClassID:
    return Ty.getScalarType().getSizeInBits() == 64 ? ACCs : VECs;
  default:
    if (GPRs.covers(RC)) {
      return GPRs;
    }
    if (PTRs.covers(RC)) {
      return PTRs;
    }
    if (MODs.covers(RC)) {
      return MODs;
    }
    if (VECs.covers(RC)) {
      return VECs;
    }
    if (ACCs.covers(RC)) {
      return ACCs;
    }
    dbgs() << "ID: " << RC.getID() << "\n";
    llvm_unreachable("Register class not supported");
  }
}
