; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: opt -mtriple=aie2 --passes="hardware-loops" --enable-aie-hardware-loops %s -S -o - | \
; RUN:     FileCheck %s
; RUN: opt -mtriple=aie2 --passes="hardware-loops" --enable-aie-hardware-loops \
; RUN:                                   --enable-aie-zero-overhead-loops %s -S -o - | \
; RUN:     FileCheck %s --check-prefix=CHECK-ZOL

; We can support nested hardware loops.
; If true ZOLs are enabled, the inner loop can use it
define void @nested(ptr nocapture %A, i32 %N) {
; CHECK-LABEL: @nested(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP20:%.*]] = icmp eq i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP20]], label [[WHILE_END7:%.*]], label [[WHILE_COND1_PREHEADER_US_PREHEADER:%.*]]
; CHECK:       while.cond1.preheader.us.preheader:
; CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.start.loop.iterations.i32(i32 [[N]])
; CHECK-NEXT:    br label [[WHILE_COND1_PREHEADER_US:%.*]]
; CHECK:       while.cond1.preheader.us:
; CHECK-NEXT:    [[I_021_US:%.*]] = phi i32 [ [[INC6_US:%.*]], [[WHILE_COND1_WHILE_END_CRIT_EDGE_US:%.*]] ], [ 0, [[WHILE_COND1_PREHEADER_US_PREHEADER]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = phi i32 [ [[TMP0]], [[WHILE_COND1_PREHEADER_US_PREHEADER]] ], [ [[TMP6:%.*]], [[WHILE_COND1_WHILE_END_CRIT_EDGE_US]] ]
; CHECK-NEXT:    [[MUL_US:%.*]] = mul i32 [[I_021_US]], [[N]]
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @llvm.start.loop.iterations.i32(i32 [[N]])
; CHECK-NEXT:    br label [[WHILE_BODY3_US:%.*]]
; CHECK:       while.body3.us:
; CHECK-NEXT:    [[J_019_US:%.*]] = phi i32 [ 0, [[WHILE_COND1_PREHEADER_US]] ], [ [[INC_US:%.*]], [[WHILE_BODY3_US]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ [[TMP2]], [[WHILE_COND1_PREHEADER_US]] ], [ [[TMP4:%.*]], [[WHILE_BODY3_US]] ]
; CHECK-NEXT:    [[ADD_US:%.*]] = add i32 [[J_019_US]], [[MUL_US]]
; CHECK-NEXT:    [[ARRAYIDX_US:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i32 [[ADD_US]]
; CHECK-NEXT:    store i32 [[ADD_US]], ptr [[ARRAYIDX_US]], align 4
; CHECK-NEXT:    [[INC_US]] = add nuw i32 [[J_019_US]], 1
; CHECK-NEXT:    [[TMP4]] = call i32 @llvm.loop.decrement.reg.i32(i32 [[TMP3]], i32 1)
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ne i32 [[TMP4]], 0
; CHECK-NEXT:    br i1 [[TMP5]], label [[WHILE_BODY3_US]], label [[WHILE_COND1_WHILE_END_CRIT_EDGE_US]]
; CHECK:       while.cond1.while.end_crit_edge.us:
; CHECK-NEXT:    [[INC6_US]] = add nuw i32 [[I_021_US]], 1
; CHECK-NEXT:    [[TMP6]] = call i32 @llvm.loop.decrement.reg.i32(i32 [[TMP1]], i32 1)
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ne i32 [[TMP6]], 0
; CHECK-NEXT:    br i1 [[TMP7]], label [[WHILE_COND1_PREHEADER_US]], label [[WHILE_END7]]
; CHECK:       while.end7:
; CHECK-NEXT:    ret void
;
; CHECK-ZOL-LABEL: @nested(
; CHECK-ZOL-NEXT:  entry:
; CHECK-ZOL-NEXT:    [[CMP20:%.*]] = icmp eq i32 [[N:%.*]], 0
; CHECK-ZOL-NEXT:    br i1 [[CMP20]], label [[WHILE_END7:%.*]], label [[WHILE_COND1_PREHEADER_US_PREHEADER:%.*]]
; CHECK-ZOL:       while.cond1.preheader.us.preheader:
; CHECK-ZOL-NEXT:    [[TMP0:%.*]] = call i32 @llvm.start.loop.iterations.i32(i32 [[N]])
; CHECK-ZOL-NEXT:    br label [[WHILE_COND1_PREHEADER_US:%.*]]
; CHECK-ZOL:       while.cond1.preheader.us:
; CHECK-ZOL-NEXT:    [[I_021_US:%.*]] = phi i32 [ [[INC6_US:%.*]], [[WHILE_COND1_WHILE_END_CRIT_EDGE_US:%.*]] ], [ 0, [[WHILE_COND1_PREHEADER_US_PREHEADER]] ]
; CHECK-ZOL-NEXT:    [[TMP1:%.*]] = phi i32 [ [[TMP0]], [[WHILE_COND1_PREHEADER_US_PREHEADER]] ], [ [[TMP3:%.*]], [[WHILE_COND1_WHILE_END_CRIT_EDGE_US]] ]
; CHECK-ZOL-NEXT:    [[MUL_US:%.*]] = mul i32 [[I_021_US]], [[N]]
; CHECK-ZOL-NEXT:    call void @llvm.set.loop.iterations.i32(i32 [[N]])
; CHECK-ZOL-NEXT:    br label [[WHILE_BODY3_US:%.*]]
; CHECK-ZOL:       while.body3.us:
; CHECK-ZOL-NEXT:    [[J_019_US:%.*]] = phi i32 [ 0, [[WHILE_COND1_PREHEADER_US]] ], [ [[INC_US:%.*]], [[WHILE_BODY3_US]] ]
; CHECK-ZOL-NEXT:    [[ADD_US:%.*]] = add i32 [[J_019_US]], [[MUL_US]]
; CHECK-ZOL-NEXT:    [[ARRAYIDX_US:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i32 [[ADD_US]]
; CHECK-ZOL-NEXT:    store i32 [[ADD_US]], ptr [[ARRAYIDX_US]], align 4
; CHECK-ZOL-NEXT:    [[INC_US]] = add nuw i32 [[J_019_US]], 1
; CHECK-ZOL-NEXT:    [[TMP2:%.*]] = call i1 @llvm.loop.decrement.i32(i32 1)
; CHECK-ZOL-NEXT:    br i1 [[TMP2]], label [[WHILE_BODY3_US]], label [[WHILE_COND1_WHILE_END_CRIT_EDGE_US]]
; CHECK-ZOL:       while.cond1.while.end_crit_edge.us:
; CHECK-ZOL-NEXT:    [[INC6_US]] = add nuw i32 [[I_021_US]], 1
; CHECK-ZOL-NEXT:    [[TMP3]] = call i32 @llvm.loop.decrement.reg.i32(i32 [[TMP1]], i32 1)
; CHECK-ZOL-NEXT:    [[TMP4:%.*]] = icmp ne i32 [[TMP3]], 0
; CHECK-ZOL-NEXT:    br i1 [[TMP4]], label [[WHILE_COND1_PREHEADER_US]], label [[WHILE_END7]]
; CHECK-ZOL:       while.end7:
; CHECK-ZOL-NEXT:    ret void
;
entry:
  %cmp20 = icmp eq i32 %N, 0
  br i1 %cmp20, label %while.end7, label %while.cond1.preheader.us

while.cond1.preheader.us:
  %i.021.us = phi i32 [ %inc6.us, %while.cond1.while.end_crit_edge.us ], [ 0, %entry ]
  %mul.us = mul i32 %i.021.us, %N
  br label %while.body3.us

while.body3.us:
  %j.019.us = phi i32 [ 0, %while.cond1.preheader.us ], [ %inc.us, %while.body3.us ]
  %add.us = add i32 %j.019.us, %mul.us
  %arrayidx.us = getelementptr inbounds i32, ptr %A, i32 %add.us
  store i32 %add.us, ptr %arrayidx.us, align 4
  %inc.us = add nuw i32 %j.019.us, 1
  %exitcond = icmp eq i32 %inc.us, %N
  br i1 %exitcond, label %while.cond1.while.end_crit_edge.us, label %while.body3.us

while.cond1.while.end_crit_edge.us:
  %inc6.us = add nuw i32 %i.021.us, 1
  %exitcond23 = icmp eq i32 %inc6.us, %N
  br i1 %exitcond23, label %while.end7, label %while.cond1.preheader.us

while.end7:
  ret void
}

declare i32 @llvm.start.loop.iterations.i32(i32) #0
declare { i32, i1 } @llvm.test.start.loop.iterations.i32(i32) #0
declare i32 @llvm.loop.decrement.reg.i32(i32, i32) #0
