; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates

; RUN: opt -S -passes=sroa < %s | FileCheck %s

; Check that SROA can work with pointers whose size isn't a multiple of 8.
; In the target layout below, a pointer is 20-bit.

; What we want to see is that the struct alloca is removed.

target datalayout = "p:20:32"

%vector_iterator = type { ptr }

define %vector_iterator @copy_it(ptr nonnull align 4 dereferenceable(4) %this) {
; CHECK-LABEL: @copy_it(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[RETVAL_SROA_0_0_COPYLOAD:%.*]] = load ptr, ptr [[THIS:%.*]], align 4
; CHECK-NEXT:    [[RETVAL_SROA_2_0_THIS_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[THIS]], i20 3
; CHECK-NEXT:    [[RETVAL_SROA_2_SROA_0_0_COPYLOAD:%.*]] = load i8, ptr [[RETVAL_SROA_2_0_THIS_SROA_IDX]], align 1
; CHECK-NEXT:    [[ORIG_IT_FCA_0_INSERT:%.*]] = insertvalue [[VECTOR_ITERATOR:%.*]] poison, ptr [[RETVAL_SROA_0_0_COPYLOAD]], 0
; CHECK-NEXT:    ret [[VECTOR_ITERATOR]] [[ORIG_IT_FCA_0_INSERT]]
;
entry:
  %retval = alloca %vector_iterator, align 4
  call void @llvm.memcpy.p0.p0.i32(ptr align 4 %retval, ptr align 4 %this, i32 4, i1 false)
  %orig_it = load %vector_iterator, ptr %retval, align 4
  ret %vector_iterator %orig_it
}

define ptr @copy_it_as_ptr(ptr nonnull align 4 dereferenceable(4) %this) {
; CHECK-LABEL: @copy_it_as_ptr(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[RETVAL_SROA_0_0_COPYLOAD:%.*]] = load ptr, ptr [[THIS:%.*]], align 4
; CHECK-NEXT:    [[RETVAL_SROA_2_0_THIS_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[THIS]], i20 3
; CHECK-NEXT:    [[RETVAL_SROA_2_SROA_0_0_COPYLOAD:%.*]] = load i8, ptr [[RETVAL_SROA_2_0_THIS_SROA_IDX]], align 1
; CHECK-NEXT:    ret ptr [[RETVAL_SROA_0_0_COPYLOAD]]
;
entry:
  %retval = alloca %vector_iterator, align 4
  call void @llvm.memcpy.p0.p0.i32(ptr align 4 %retval, ptr align 4 %this, i32 4, i1 false)
  %ptr.addr = getelementptr inbounds %vector_iterator, ptr %retval, i32 0
  %ptr = load ptr, ptr %ptr.addr, align 4
  ret ptr %ptr
}

declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg)
