; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; NOTE: Example file for converting loop iter count to assumes in Loop
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates
; unit test for the WAW register renaming pass and check edge cases
; RUN: opt -S -passes='loop-metadata' < %s | FileCheck %s

; for loop where loop counter is incremented by +1 and starts at 0
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @incrementByOne(ptr %ptr, i32 noundef %n) #0 {
; CHECK-LABEL: @incrementByOne(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[I_0]], [[N:%.*]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 3
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 8
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INC]] = add nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP0:![0-9]+]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret void

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, ptr %ptr, i32 %i.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 8
  store i32 %add, ptr %arrayidx, align 4
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !6
}

; for loop where loop counter is incremented by +7 and starts at 0
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @incrementByMultiple(ptr %ptr, i32 noundef %n) #0 {
; CHECK-LABEL: @incrementByMultiple(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD2:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[I_0]], [[N:%.*]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 27
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 8
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD2]] = add nsw i32 [[I_0]], 7
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP0]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %add2, %for.body ]
  %cmp = icmp slt i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret void

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, ptr %ptr, i32 %i.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 8
  store i32 %add, ptr %arrayidx, align 4
  %add2 = add nsw i32 %i.0, 7
  br label %for.cond, !llvm.loop !6
}

; outside guard of the loop counter, but if the loop is entered, the loop will
; execute multiple times.
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @outsideGuard(ptr %ptr, i32 noundef %n) #0 {
; CHECK-LABEL: @outsideGuard(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[IF_THEN]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp slt i32 [[I_0]], [[N]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 3
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP1]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       for.body:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 8
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INC]] = add nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP0]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  %cmp = icmp sgt i32 %n, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %cmp1 = icmp slt i32 %i.0, %n
  br i1 %cmp1, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  br label %if.end

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, ptr %ptr, i32 %i.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 8
  store i32 %add, ptr %arrayidx, align 4
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !6

if.end:                                           ; preds = %for.cond.cleanup, %entry
  ret void
}

; decrement loop by -1
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @decrement(ptr %ptr, i32 noundef %n) #0 {
; CHECK-LABEL: @decrement(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ [[N:%.*]], [[ENTRY:%.*]] ], [ [[DEC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[I_0]], 0
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 4
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 8
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[DEC]] = add nsw i32 [[I_0]], -1
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP0]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ %n, %entry ], [ %dec, %for.body ]
  %cmp = icmp sgt i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret void

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, ptr %ptr, i32 %i.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 8
  store i32 %add, ptr %arrayidx, align 4
  %dec = add nsw i32 %i.0, -1
  br label %for.cond, !llvm.loop !6
}

; decrement loop counter by 7
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @decrementByMultiple(ptr %ptr, i32 noundef %n) #0 {
; CHECK-LABEL: @decrementByMultiple(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ [[N:%.*]], [[ENTRY:%.*]] ], [ [[SUB:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[I_0]], 0
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 28
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 8
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[SUB]] = sub nsw i32 [[I_0]], 7
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP0]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ %n, %entry ], [ %sub, %for.body ]
  %cmp = icmp sgt i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret void

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, ptr %ptr, i32 %i.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 8
  store i32 %add, ptr %arrayidx, align 4
  %sub = sub nsw i32 %i.0, 7
  br label %for.cond, !llvm.loop !6
}


!2 = distinct !{!2, !7, !8, !9}
!6 = distinct !{!6, !7, !8, !9}
!7 = !{!"llvm.loop.mustprogress"}
!8 = !{!"llvm.loop.itercount.range", i64 4}
!9 = !{!"llvm.loop.unroll.disable"}

