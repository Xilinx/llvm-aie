; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; NOTE: Example file for converting loop iter count to assumes in Loop
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates
; unit test for the WAW register renaming pass and check edge cases
; RUN: opt -S -passes='loop-metadata' < %s | FileCheck %s

; for loop where loop counter is incremented by +1 and starts at 0
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @incrementByOne(ptr %ptr, i32 noundef %n) #0 {
; CHECK-LABEL: @incrementByOne(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[I_0]], [[N:%.*]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 9
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 8
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INC]] = add nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP0:![0-9]+]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret void

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, ptr %ptr, i32 %i.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 8
  store i32 %add, ptr %arrayidx, align 4
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !3
}

; for loop where loop counter is incremented by +7 and starts at 0
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @incrementByMultiple(ptr %ptr, i32 noundef %n) #0 {
; CHECK-LABEL: @incrementByMultiple(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD2:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[I_0]], [[N:%.*]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 27
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 8
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD2]] = add nsw i32 [[I_0]], 7
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4:![0-9]+]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %add2, %for.body ]
  %cmp = icmp slt i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret void

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, ptr %ptr, i32 %i.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 8
  store i32 %add, ptr %arrayidx, align 4
  %add2 = add nsw i32 %i.0, 7
  br label %for.cond, !llvm.loop !6
}

; outside guard of the loop counter, but if the loop is entered, the loop will
; execute multiple times.
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @outsideGuard(ptr %ptr, i32 noundef %n) #0 {
; CHECK-LABEL: @outsideGuard(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[IF_THEN]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp slt i32 [[I_0]], [[N]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 3
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP1]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       for.body:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 8
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INC]] = add nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  %cmp = icmp sgt i32 %n, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %cmp1 = icmp slt i32 %i.0, %n
  br i1 %cmp1, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  br label %if.end

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, ptr %ptr, i32 %i.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 8
  store i32 %add, ptr %arrayidx, align 4
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !6

if.end:                                           ; preds = %for.cond.cleanup, %entry
  ret void
}

; decrement loop by -1
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @decrement(ptr %ptr, i32 noundef %n) #0 {
; CHECK-LABEL: @decrement(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ [[N:%.*]], [[ENTRY:%.*]] ], [ [[DEC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[I_0]], 0
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 4
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 8
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[DEC]] = add nsw i32 [[I_0]], -1
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ %n, %entry ], [ %dec, %for.body ]
  %cmp = icmp sgt i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret void

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, ptr %ptr, i32 %i.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 8
  store i32 %add, ptr %arrayidx, align 4
  %dec = add nsw i32 %i.0, -1
  br label %for.cond, !llvm.loop !6
}

; decrement loop counter by 7
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @decrementByMultiple(ptr %ptr, i32 noundef %n) #0 {
; CHECK-LABEL: @decrementByMultiple(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ [[N:%.*]], [[ENTRY:%.*]] ], [ [[SUB:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[I_0]], 0
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 28
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 8
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[SUB]] = sub nsw i32 [[I_0]], 7
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ %n, %entry ], [ %sub, %for.body ]
  %cmp = icmp sgt i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret void

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, ptr %ptr, i32 %i.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 8
  store i32 %add, ptr %arrayidx, align 4
  %sub = sub nsw i32 %i.0, 7
  br label %for.cond, !llvm.loop !6
}


; make sure that the added compare in the assume has matching types
; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @type_matching(ptr %ptr, i16 noundef signext %n) #0 {
; CHECK-LABEL: @type_matching(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[PTR_ADDR:%.*]] = alloca ptr, align 4
; CHECK-NEXT:    [[N_ADDR:%.*]] = alloca i16, align 2
; CHECK-NEXT:    [[I:%.*]] = alloca i16, align 2
; CHECK-NEXT:    store ptr [[PTR:%.*]], ptr [[PTR_ADDR]], align 4
; CHECK-NEXT:    store i16 [[N:%.*]], ptr [[N_ADDR]], align 2
; CHECK-NEXT:    store i16 0, ptr [[I]], align 2
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP0:%.*]] = load i16, ptr [[I]], align 2
; CHECK-NEXT:    [[CONV:%.*]] = sext i16 [[TMP0]] to i32
; CHECK-NEXT:    [[TMP1:%.*]] = load i16, ptr [[N_ADDR]], align 2
; CHECK-NEXT:    [[CONV1:%.*]] = sext i16 [[TMP1]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[CONV]], [[CONV1]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[PTR_ADDR]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i16, ptr [[I]], align 2
; CHECK-NEXT:    [[IDXPROM:%.*]] = sext i16 [[TMP3]] to i32
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], i32 [[IDXPROM]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP4]], 8
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[PTR_ADDR]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = load i16, ptr [[I]], align 2
; CHECK-NEXT:    [[IDXPROM2:%.*]] = sext i16 [[TMP6]] to i32
; CHECK-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds i32, ptr [[TMP5]], i32 [[IDXPROM2]]
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX3]], align 4
; CHECK-NEXT:    br label [[FOR_INC:%.*]]
; CHECK:       for.inc:
; CHECK-NEXT:    [[TMP7:%.*]] = load i16, ptr [[I]], align 2
; CHECK-NEXT:    [[INC:%.*]] = add i16 [[TMP7]], 1
; CHECK-NEXT:    store i16 [[INC]], ptr [[I]], align 2
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP6:![0-9]+]]
; CHECK:       for.end:
; CHECK-NEXT:    ret void
;
entry:
  %ptr.addr = alloca ptr, align 4
  %n.addr = alloca i16, align 2
  %i = alloca i16, align 2
  store ptr %ptr, ptr %ptr.addr, align 4
  store i16 %n, ptr %n.addr, align 2
  store i16 0, ptr %i, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i16, ptr %i, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, ptr %n.addr, align 2
  %conv1 = sext i16 %1 to i32
  %cmp = icmp slt i32 %conv, %conv1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %ptr.addr, align 4
  %3 = load i16, ptr %i, align 2
  %idxprom = sext i16 %3 to i32
  %arrayidx = getelementptr inbounds i32, ptr %2, i32 %idxprom
  %4 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %4, 8
  %5 = load ptr, ptr %ptr.addr, align 4
  %6 = load i16, ptr %i, align 2
  %idxprom2 = sext i16 %6 to i32
  %arrayidx3 = getelementptr inbounds i32, ptr %5, i32 %idxprom2
  store i32 %add, ptr %arrayidx3, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i16, ptr %i, align 2
  %inc = add i16 %7, 1
  store i16 %inc, ptr %i, align 2
  br label %for.cond, !llvm.loop !2

for.end:                                          ; preds = %for.cond
  ret void
}

; find IV even if it is hidden in a truncation operation
; Function Attrs: mustprogress nofree norecurse nosync nounwind memory(argmem: readwrite, inaccessiblemem: write)
define dso_local void @basicIVTruncation(i32 noundef %num_elems, i32 noundef %n) local_unnamed_addr #0 {
; CHECK-LABEL: @basicIVTruncation(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[CONV:%.*]] = and i32 [[I_0]], 65535
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[CONV]], [[N:%.*]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[N]], 3
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[ADD]] = add nuw nsw i32 [[CONV]], 1
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4]]
;
entry:
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %add, %for.body ]
  %conv = and i32 %i.0, 65535
  %cmp = icmp ult i32 %conv, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret void

for.body:                                         ; preds = %for.cond, %for.body
  %add = add nuw nsw i32 %conv , 1
  br label %for.cond, !llvm.loop !6
}

; Only insert an assertion, if the header already contains the loop bounds Value.
; Otherwise the IR is not correct and moving the loop Bounds into the header is
; not yet desired.
; Function Attrs: mustprogress noinline
define  dso_local void @assume_insertion_only_in_correct_header(ptr nonnull align 32 dereferenceable(128) %params) {
; CHECK-LABEL: @assume_insertion_only_in_correct_header(
; CHECK-NEXT:  for.body.lr.ph:
; CHECK-NEXT:    [[INNER_G:%.*]] = getelementptr inbounds i8, ptr [[PARAMS:%.*]], i20 12
; CHECK-NEXT:    [[OUTER_G:%.*]] = getelementptr inbounds i8, ptr [[PARAMS]], i20 8
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[J_0349:%.*]] = phi i32 [ 0, [[FOR_BODY_LR_PH:%.*]] ], [ [[INC103:%.*]], [[FOR_COND8_FOR_COND_CLEANUP10_CRIT_EDGE:%.*]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[INNER_G]], align 4
; CHECK-NEXT:    br label [[FOR_BODY11:%.*]]
; CHECK:       for.cond8.for.cond.cleanup10_crit_edge:
; CHECK-NEXT:    [[INC103]] = add nuw nsw i32 [[J_0349]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[OUTER_G]], align 8
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[INC103]], [[TMP1]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]], !llvm.loop [[LOOP4]]
; CHECK:       for.body11:
; CHECK-NEXT:    [[I_0315:%.*]] = phi i32 [ 0, [[FOR_BODY]] ], [ [[INC:%.*]], [[FOR_BODY11]] ]
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0315]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = icmp sgt i32 [[TMP0]], 3
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TMP2]])
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND8_FOR_COND_CLEANUP10_CRIT_EDGE]], label [[FOR_BODY11]], !llvm.loop [[LOOP4]]
;
for.body.lr.ph:
  %inner_g = getelementptr inbounds i8, ptr %params, i20 12
  %outer_g = getelementptr inbounds i8, ptr %params, i20 8
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.cond8.for.cond.cleanup10_crit_edge
  ret void

for.body:                                         ; preds = %for.body.lr.ph, %for.cond8.for.cond.cleanup10_crit_edge
  %j.0349 = phi i32 [ 0, %for.body.lr.ph ], [ %inc103, %for.cond8.for.cond.cleanup10_crit_edge ]
  %46 = load i32, ptr %inner_g, align 4
  br label %for.body11

for.cond8.for.cond.cleanup10_crit_edge:           ; preds = %for.body11
  %inc103 = add nuw nsw i32 %j.0349, 1
  %114 = load i32, ptr %outer_g, align 8
  %cmp = icmp ult i32 %inc103, %114
  br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !6

for.body11:                                       ; preds = %for.body, %for.body11
  %i.0315 = phi i32 [ 0, %for.body ], [ %inc, %for.body11 ]
  %inc = add nuw nsw i32 %i.0315, 1
  %exitcond.not = icmp eq i32 %inc, %46
  br i1 %exitcond.not, label %for.cond8.for.cond.cleanup10_crit_edge, label %for.body11, !llvm.loop !6
}

; Check Loop Rotation abort Condition: Loop Exit is not the header, i.e. already rotated
; Function Attrs: mustprogress noinline
define  dso_local void @header_is_loop_exit(ptr nonnull align 32 dereferenceable(64) %params) {
; CHECK-LABEL: @header_is_loop_exit(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[PARAMS:%.*]], align 32
; CHECK-NEXT:    [[DIV7:%.*]] = lshr i32 [[TMP0]], 6
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[I_014:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD:%.*]], [[FOR_BODY_EXIT:%.*]] ]
; CHECK-NEXT:    [[OP_PARAMS_I_I_I:%.*]] = getelementptr inbounds i8, ptr [[PARAMS]], i20 32
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr [[OP_PARAMS_I_I_I]], align 32
; CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i8 [[TMP1]], -1
; CHECK-NEXT:    [[TMP2:%.*]] = tail call i1 @llvm.is.constant.i1(i1 [[CMP3]])
; CHECK-NEXT:    [[TMP3:%.*]] = and i1 [[CMP3]], [[TMP2]]
; CHECK-NEXT:    br i1 [[TMP3]], label [[FOR_BODY_EXIT]], label [[IF_END_I_I_I_I:%.*]]
; CHECK:       if.end.i.i.i.i:
; CHECK-NEXT:    br label [[FOR_BODY_EXIT]]
; CHECK:       for.body.exit:
; CHECK-NEXT:    [[ADD]] = add nuw nsw i32 [[I_014]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[ADD]], [[DIV7]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]], !llvm.loop [[LOOP4]]
;
entry:
  %0 = load i32, ptr %params, align 32
  %div7 = lshr i32 %0, 6
  br label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.014 = phi i32 [ 0, %entry ], [ %add, %for.body.exit ]
  %op_params.i.i.i = getelementptr inbounds i8, ptr %params, i20 32
  %3 = load i8, ptr %op_params.i.i.i, align 32
  %cmp3 = icmp eq i8 %3, -1
  %4 = tail call i1 @llvm.is.constant.i1(i1 %cmp3)
  %5 = and i1 %cmp3, %4
  br i1 %5, label %for.body.exit, label %if.end.i.i.i.i

if.end.i.i.i.i:
  br label %for.body.exit

for.body.exit:
  %add = add nuw nsw i32 %i.014, 1
  %cmp2 = icmp ult i32 %add, %div7
  br i1 %cmp2, label %for.body, label %for.cond.cleanup, !llvm.loop !6
}

; Header has unconditional branch, abort Loop rotataion and metadata adding
; Function Attrs: mustprogress noinline
define  dso_local void @header_unconditional(ptr nonnull align 32 dereferenceable(64) %params) {
; CHECK-LABEL: @header_unconditional(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[PARAMS:%.*]], align 32
; CHECK-NEXT:    [[DIV7:%.*]] = lshr i32 [[TMP0]], 6
; CHECK-NEXT:    [[CMP211:%.*]] = icmp ult i32 0, [[DIV7]]
; CHECK-NEXT:    br i1 [[CMP211]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[I_014:%.*]] = phi i32 [ [[ADD:%.*]], [[FOR_BODY_EXIT:%.*]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    br label [[FOR_BODY_EXIT]]
; CHECK:       for.body.exit:
; CHECK-NEXT:    [[ADD]] = add nuw nsw i32 [[I_014]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[ADD]], [[DIV7]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], !llvm.loop [[LOOP4]]
;
entry:
  %0 = load i32, ptr %params, align 32
  %div7 = lshr i32 %0, 6
  %cmp211 = icmp ult i32 0, %div7
  br i1 %cmp211, label %for.body, label %for.cond.cleanup

for.cond.cleanup:
  ret void

for.body:
  %i.014 = phi i32 [ 0, %entry ], [ %add, %for.body.exit ]
  br label %for.body.exit

for.body.exit:
  %add = add nuw nsw i32 %i.014, 1
  %cmp2 = icmp ult i32 %add, %div7
  br i1 %cmp2, label %for.body, label %for.cond.cleanup, !llvm.loop !6
}

!2 = distinct !{!2, !7, !8, !9}
!6 = distinct !{!6, !7, !8, !9}
!7 = !{!"llvm.loop.mustprogress"}
!8 = !{!"llvm.loop.itercount.range", i64 4}
!9 = !{!"llvm.loop.unroll.disable"}
!3 = distinct !{!3, !11, !7, !9}
!11 = !{!"llvm.loop.itercount.range", i64 10, i64 65}
