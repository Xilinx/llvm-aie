//===- MCOperandIndex.td -----------------------------------*- tablegen -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// Modifications (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: llvm-tblgen --gen-instr-format -I %p -I %p/../ -I %p/../../../../include %s 2>&1 | FileCheck %s \
// (MCCodeEmitter lda:) Value.insertBits(op.extractBitsAsZExtValue(18, 0), 110, 18);
// RUN: -D#%,I128_LDA_NUM_BITS=18 -D#%,I128_LDA_BIT_POS=110 \
// (MCCodeEmitter ldb:) Value.insertBits(op.extractBitsAsZExtValue(17, 0), 93, 17);
// RUN: -D#%,I128_LDB_NUM_BITS=17 -D#%,I128_LDB_BIT_POS=93 \
// (MCCodeEmitter vec_all:) Value.insertBits(op.extractBitsAsZExtValue(37, 0), 2, 37);
// RUN: -D#%,I128_VECA_NUM_BITS=37 -D#%,I128_VECA_BIT_POS=2 \
// (MCCodeEmitter alu:) Value.insertBits(op.extractBitsAsZExtValue(19, 0), 73, 19);
// RUN: -D#%,I128_ALU_NUM_BITS=19 -D#%,I128_ALU_BIT_POS=73 \
// (MCCodeEmitter lng:) Value.insertBits(op.extractBitsAsZExtValue(28, 0), 40, 28);
// RUN: -D#%,I128_LNG_NUM_BITS=28 -D#%,I128_LNG_BIT_POS=40 \
// RUN: -D#%,I128_SIZE=128 \
// (MCCodeEmitter reg:) Value.insertBits(op.extractBitsAsZExtValue(6, 0), 18, 6);
// RUN: -D#%,MOV_REG_NUM_BITS=6 -D#%,MOV_REG_BIT_POS=18 \
// (MCCodeEmitter imm0/1:) Value.insertBits(op.extractBitsAsZExtValue(12, 0), 4, 12);
//                         Value.insertBits(op.extractBitsAsZExtValue(14, 0), 4, 14);
// RUN: -D#%,MOV_IMM0_NUM_BITS=6 -D#%,MOV_IMM0_BIT_POS=24 \
// RUN: -D#%,MOV_IMM1_NUM_BITS=14 -D#%,MOV_IMM1_BIT_POS=4 \
// RUN: -D#%,MOV_SIZE=32

include "llvm/Target/Target.td"
include "llvm/Target/CodeGenFormat.td"

let Namespace = "TEST" in {
def instr16_slot : InstSlot<"instr16", 14>;
def lda_slot     : InstSlot<"lda", 18>;
def ldb_slot     : InstSlot<"ldb", 17>;
def alu_slot     : InstSlot<"alu", 19>;
def lng_slot     : InstSlot<"lng", 28>;
def veca_slot    : InstSlot<"veca", 37>;
}

include "Inputs/CommonFormatTesting.td"

def I128_LDA_LDB_NOP_ALU_LNG_NOP_VEC_ALL
    : TEST__instr128__V_formats__V_move__ldb_alu_st_mv_all_vec_all
        <(outs),
         (ins lda_slot:$lda,
              ldb_slot:$ldb,
              alu_slot:$alu,
              lng_slot:$lng,
              veca_slot:$vec_all),
         [],
         "i128_lda_ldb_nop_alu_lng_nop_vec_all",
         "$lda, $ldb, $alu, $lng, $vec_all">
{
   let hasSideEffects = 0;
   let mayLoad = 0;
   let mayStore = 0;

   bits<19> alu;
   bits<28> lng;
   let alu_st = {0b0, alu, 0};
   let mv_all = {0b000, lng};
}

// WE check below id the offsets generated by CodeGenFormat are the same than
// the ones generated by CodeGenEmitter.

// CHECK: #ifdef GET_FORMATS_FORMATS_DEFS
// CHECK:  TEST::I128_LDA_LDB_NOP_ALU_LNG_NOP_VEC_ALL - Index : [[#%,I128_INDEX:]] - FieldIndex : [[#%,I128_FIELDINDEX:]]
// CHECK: "lda"
// CHECK-SAME: { [[#I128_SIZE - I128_LDA_NUM_BITS - I128_LDA_BIT_POS]], [[#I128_SIZE - I128_LDA_BIT_POS - 1]] }
// CHECK: "ldb"
// CHECK-SAME: { [[#I128_SIZE - I128_LDB_NUM_BITS - I128_LDB_BIT_POS]], [[#I128_SIZE - I128_LDB_BIT_POS - 1]] }
// CHECK: "alu"
// CHECK-SAME: { [[#I128_SIZE - I128_ALU_NUM_BITS - I128_ALU_BIT_POS]], [[#I128_SIZE - I128_ALU_BIT_POS - 1]] }
// CHECK: "lng"
// CHECK-SAME: { [[#I128_SIZE - I128_LNG_NUM_BITS - I128_LNG_BIT_POS]], [[#I128_SIZE - I128_LNG_BIT_POS - 1]] }
// CHECK: "vec_all"
// CHECK-SAME: { [[#I128_SIZE - I128_VECA_NUM_BITS - I128_VECA_BIT_POS]], [[#I128_SIZE - I128_VECA_BIT_POS - 1]] }

def MOV_U20 : TEST_mov20<(outs mMv0Cg20:$reg), (ins uimm20:$imm), [], "mov.u20", "$reg, $imm">;
// CHECK:  TEST::MOV_U20 - Index : [[#%,MOV_U20_INDEX:]]
// CHECK: "imm"
// CHECK-SAME: { [[#MOV_SIZE - MOV_IMM0_NUM_BITS - MOV_IMM0_BIT_POS]], [[#MOV_SIZE - MOV_IMM0_BIT_POS - 1]] }
// CHECK: "reg"
// CHECK-SAME: { [[#MOV_SIZE - MOV_REG_NUM_BITS - MOV_REG_BIT_POS]], [[#MOV_SIZE - MOV_REG_BIT_POS - 1]] }
// CHECK: "imm"
// CHECK-SAME: { [[#MOV_SIZE - MOV_IMM1_NUM_BITS - MOV_IMM1_BIT_POS]], [[#MOV_SIZE - MOV_IMM1_BIT_POS - 1]] }


// CHECK-LABEL: OpFields[] = {
// CHECK: I128_LDA_LDB_NOP_ALU_LNG_NOP_VEC_ALL [[#I128_OPFIELDS:]]
// CHECK-NEXT: FieldsHierarchyTables[[[#LDA_FIELD_INDEX:]]]
// CHECK-NEXT: FieldsHierarchyTables[[[#LDB_FIELD_INDEX:]]]
// CHECK-NEXT: FieldsHierarchyTables[[[#ALU_FIELD_INDEX:]]]
// CHECK-NEXT: FieldsHierarchyTables[[[#LNG_FIELD_INDEX:]]]
// CHECK-NEXT: FieldsHierarchyTables[[[#VEC_FIELD_INDEX:]]]
// CHECK: MOV_U20 [[#MOV_OPFIELDS:]]
// CHECK-NEXT: FieldsHierarchyTables[[[#REG_FIELD_INDEX:]]]
// CHECK-NEXT: FieldsHierarchyTables[[[#IMM0_FIELD_INDEX:]]]
// CHECK-NEXT: FieldsHierarchyTables[[[#IMM1_FIELD_INDEX:]]]

// CHECK-LABEL: FieldRanges[] = {
// CHECK: I128_LDA_LDB_NOP_ALU_LNG_NOP_VEC_ALL [[#RANGE0:]]
// CHECK: // MOV_U20 [[#RANGE1:]]
// CHECK: // Sentinel [[#RANGE2:]]

// We check below two things:
// - the (good) mapping between the slots Kinds and the MCOperand Index
// - the match between the emitted Indexes and the indexes generated by CodeGenEmitter:
//   - op: lda, MI.getOperand(0)
//   - op: ldb, MI.getOperand(1)
//   - op: vec_all, MI.getOperand(4)
//   - op: alu, MI.getOperand(2)
//   - op: lng, MI.getOperand(3)

// CHECK-LABEL: static MCFormatDesc const Formats[] = {
// CHECK: TEST::I128_LDA_LDB_NOP_ALU_LNG_NOP_VEC_ALL - Index : [[#I128_INDEX]]
// CHECK: /* Slots - Fields mapper */
// CHECK: TESTSlotKind::TEST_SLOT_LDA, &FieldsHierarchyTables[[[#%,I128_LDAINDEX:]]] },
// CHECK-SAME: { TESTSlotKind::TEST_SLOT_LDB, &FieldsHierarchyTables[[[#%,I128_LDBINDEX:]]] },
// CHECK-SAME: { TESTSlotKind::TEST_SLOT_ALU, &FieldsHierarchyTables[[[#%,I128_ALUINDEX:]]] },
// CHECK-SAME: { TESTSlotKind::TEST_SLOT_LNG, &FieldsHierarchyTables[[[#%,I128_LNGINDEX:]]] },
// CHECK-SAME: { TESTSlotKind::TEST_SLOT_VECA, &FieldsHierarchyTables[[[#%,I128_VECAINDEX:]]] }}
// CHECK: /* MCOperand - Slots mapper */
// CHECK: {&FieldRanges[[[#RANGE0]]], [[#RANGE1]]},
