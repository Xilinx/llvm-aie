; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: opt -S -O2 -mtriple=aie %s -o - | FileCheck %s

; Verify that we can unroll some basic vector loops.   This is essentially a test of the cost models
; in AIETargetTransformInfo

; ModuleID = '<stdin>'
source_filename = "LLVMDialectModule"

@a = external global [256 x float]

define void @core13() {
; CHECK-LABEL: @core13(
; CHECK-NEXT:    [[CONSTEXPR1:%.*]] = and i64 ptrtoint (ptr @a to i64), 28
; CHECK-NEXT:    [[CONSTEXPR2:%.*]] = icmp eq i64 [[CONSTEXPR1]], 0
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[CONSTEXPR2]])
; CHECK-NEXT:    store float 1.400000e+01, ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 3), align 4
; CHECK-NEXT:    store float 8.000000e+00, ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 5), align 4
; CHECK-NEXT:    store float 1.400000e+01, ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 9), align 4
; CHECK-NEXT:    [[UNMASKEDLOAD:%.*]] = load <8 x float>, ptr @a, align 4
; CHECK-NEXT:    [[TMP1:%.*]] = fmul <8 x float> [[UNMASKEDLOAD]], [[UNMASKEDLOAD]]
; CHECK-NEXT:    store <8 x float> [[TMP1]], ptr @a, align 4
; CHECK-NEXT:    [[UNMASKEDLOAD1:%.*]] = load <8 x float>, ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 8), align 4
; CHECK-NEXT:    [[TMP2:%.*]] = fmul <8 x float> [[UNMASKEDLOAD1]], [[UNMASKEDLOAD1]]
; CHECK-NEXT:    store <8 x float> [[TMP2]], ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 8), align 4
; CHECK-NEXT:    [[UNMASKEDLOAD2:%.*]] = load <8 x float>, ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 16), align 4
; CHECK-NEXT:    [[TMP3:%.*]] = fmul <8 x float> [[UNMASKEDLOAD2]], [[UNMASKEDLOAD2]]
; CHECK-NEXT:    store <8 x float> [[TMP3]], ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 16), align 4
; CHECK-NEXT:    [[UNMASKEDLOAD3:%.*]] = load <8 x float>, ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 24), align 4
; CHECK-NEXT:    [[TMP4:%.*]] = fmul <8 x float> [[UNMASKEDLOAD3]], [[UNMASKEDLOAD3]]
; CHECK-NEXT:    store <8 x float> [[TMP4]], ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 24), align 4
; CHECK-NEXT:    [[UNMASKEDLOAD4:%.*]] = load <8 x float>, ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 32), align 4
; CHECK-NEXT:    [[TMP5:%.*]] = fmul <8 x float> [[UNMASKEDLOAD4]], [[UNMASKEDLOAD4]]
; CHECK-NEXT:    store <8 x float> [[TMP5]], ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 32), align 4
; CHECK-NEXT:    [[UNMASKEDLOAD5:%.*]] = load <8 x float>, ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 40), align 4
; CHECK-NEXT:    [[TMP6:%.*]] = fmul <8 x float> [[UNMASKEDLOAD5]], [[UNMASKEDLOAD5]]
; CHECK-NEXT:    store <8 x float> [[TMP6]], ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 40), align 4
; CHECK-NEXT:    [[UNMASKEDLOAD6:%.*]] = load <8 x float>, ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 48), align 4
; CHECK-NEXT:    [[TMP7:%.*]] = fmul <8 x float> [[UNMASKEDLOAD6]], [[UNMASKEDLOAD6]]
; CHECK-NEXT:    store <8 x float> [[TMP7]], ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 48), align 4
; CHECK-NEXT:    [[UNMASKEDLOAD7:%.*]] = load <8 x float>, ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 56), align 4
; CHECK-NEXT:    [[TMP8:%.*]] = fmul <8 x float> [[UNMASKEDLOAD7]], [[UNMASKEDLOAD7]]
; CHECK-NEXT:    store <8 x float> [[TMP8]], ptr getelementptr inbounds ([256 x float], ptr @a, i20 0, i20 56), align 4
; CHECK-NEXT:    ret void
;
  %constexpr = ptrtoint ptr @a to i64
  %constexpr1 = and i64 %constexpr, 31
  %constexpr2 = icmp eq i64 %constexpr1, 0
  call void @llvm.assume(i1 %constexpr2)
  store float 1.400000e+01, float* getelementptr inbounds ([256 x float], [256 x float]* @a, i64 0, i64 3), align 4
  store float 8.000000e+00, float* getelementptr inbounds ([256 x float], [256 x float]* @a, i64 0, i64 5), align 4
  %1 = load float, float* getelementptr inbounds ([256 x float], [256 x float]* @a, i64 0, i64 3), align 4
  store float %1, float* getelementptr inbounds ([256 x float], [256 x float]* @a, i64 0, i64 9), align 4
  br label %2

2:                                                ; preds = %5, %0
  %3 = phi i64 [ %16, %5 ], [ 0, %0 ]
  %4 = icmp slt i64 %3, 64
  br i1 %4, label %5, label %17

5:                                                ; preds = %2
  %6 = trunc i64 %3 to i32
  %7 = insertelement <8 x i32> undef, i32 %6, i32 0
  %8 = shufflevector <8 x i32> %7, <8 x i32> undef, <8 x i32> zeroinitializer
  %9 = add <8 x i32> %8, <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  %10 = icmp slt <8 x i32> %9, <i32 256, i32 256, i32 256, i32 256, i32 256, i32 256, i32 256, i32 256>
  %11 = getelementptr float, float* getelementptr inbounds ([256 x float], [256 x float]* @a, i64 0, i64 0), i64 %3
  %12 = bitcast float* %11 to <8 x float>*
  %13 = call <8 x float> @llvm.masked.load.v8f32.p0v8f32(<8 x float>* %12, i32 4, <8 x i1> %10, <8 x float> zeroinitializer)
  %14 = call <8 x float> @llvm.masked.load.v8f32.p0v8f32(<8 x float>* %12, i32 4, <8 x i1> %10, <8 x float> zeroinitializer)
  %15 = fmul <8 x float> %13, %14
  call void @llvm.masked.store.v8f32.p0v8f32(<8 x float> %15, <8 x float>* %12, i32 4, <8 x i1> %10)
  %16 = add i64 %3, 8
  br label %2

17:                                               ; preds = %2
  ret void
}

; Function Attrs: inaccessiblememonly nofree nosync nounwind willreturn
declare void @llvm.assume(i1 noundef) #0

; Function Attrs: argmemonly nofree nosync nounwind readonly willreturn
declare <8 x float> @llvm.masked.load.v8f32.p0v8f32(<8 x float>*, i32 immarg, <8 x i1>, <8 x float>) #1

; Function Attrs: argmemonly nofree nosync nounwind willreturn writeonly
declare void @llvm.masked.store.v8f32.p0v8f32(<8 x float>, <8 x float>*, i32 immarg, <8 x i1>) #2

attributes #0 = { inaccessiblememonly nofree nosync nounwind willreturn }
attributes #1 = { argmemonly nofree nosync nounwind readonly willreturn }
attributes #2 = { argmemonly nofree nosync nounwind willreturn writeonly }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
