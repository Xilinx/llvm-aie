; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --print-fixed-stack
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

; 128-bit vector types

define i32 @arg_v4int32(<4 x i32> %a1, <4 x i32> %a2, <4 x i32> %a3, <4 x i32> %a4,
  ; CHECK-LABEL: name: arg_v4int32
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -16, size: 16, alignment: 16, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $vh0, $vh1, $vh2, $vh3, $vh4, $vh5, $vh6, $vh7, $vl0, $vl1, $vl2, $vl3, $vl4, $vl5, $vl6, $vl7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<4 x s32>) = COPY $vl0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<4 x s32>) = COPY $vl1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<4 x s32>) = COPY $vl2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<4 x s32>) = COPY $vl3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(<4 x s32>) = COPY $vl4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(<4 x s32>) = COPY $vl5
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(<4 x s32>) = COPY $vl6
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(<4 x s32>) = COPY $vl7
  ; CHECK-NEXT:   [[COPY8:%[0-9]+]]:_(<4 x s32>) = COPY $vh0
  ; CHECK-NEXT:   [[COPY9:%[0-9]+]]:_(<4 x s32>) = COPY $vh1
  ; CHECK-NEXT:   [[COPY10:%[0-9]+]]:_(<4 x s32>) = COPY $vh2
  ; CHECK-NEXT:   [[COPY11:%[0-9]+]]:_(<4 x s32>) = COPY $vh3
  ; CHECK-NEXT:   [[COPY12:%[0-9]+]]:_(<4 x s32>) = COPY $vh4
  ; CHECK-NEXT:   [[COPY13:%[0-9]+]]:_(<4 x s32>) = COPY $vh5
  ; CHECK-NEXT:   [[COPY14:%[0-9]+]]:_(<4 x s32>) = COPY $vh6
  ; CHECK-NEXT:   [[COPY15:%[0-9]+]]:_(<4 x s32>) = COPY $vh7
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<4 x s32>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<4 x s32>) from %fixed-stack.0)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s32) = G_EXTRACT_VECTOR_ELT [[LOAD]](<4 x s32>), [[C]](s32)
  ; CHECK-NEXT:   $r0 = COPY [[EVEC]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
                              <4 x i32> %a5, <4 x i32> %a6, <4 x i32> %a7, <4 x i32> %a8,
                              <4 x i32> %a9, <4 x i32> %a10, <4 x i32> %a11, <4 x i32> %a12,
                              <4 x i32> %a13, <4 x i32> %a14, <4 x i32> %a15, <4 x i32> %a16,
                              <4 x i32> %a_stack) {
  %res = extractelement <4 x i32> %a_stack, i32 3
  ret i32 %res
}

define i16 @arg_v8int16(<8 x i16> %a1, <8 x i16> %a2, <8 x i16> %a3, <8 x i16> %a4,
  ; CHECK-LABEL: name: arg_v8int16
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -16, size: 16, alignment: 16, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $vh0, $vh1, $vh2, $vh3, $vh4, $vh5, $vh6, $vh7, $vl0, $vl1, $vl2, $vl3, $vl4, $vl5, $vl6, $vl7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<8 x s16>) = COPY $vl0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<8 x s16>) = COPY $vl1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<8 x s16>) = COPY $vl2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<8 x s16>) = COPY $vl3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(<8 x s16>) = COPY $vl4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(<8 x s16>) = COPY $vl5
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(<8 x s16>) = COPY $vl6
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(<8 x s16>) = COPY $vl7
  ; CHECK-NEXT:   [[COPY8:%[0-9]+]]:_(<8 x s16>) = COPY $vh0
  ; CHECK-NEXT:   [[COPY9:%[0-9]+]]:_(<8 x s16>) = COPY $vh1
  ; CHECK-NEXT:   [[COPY10:%[0-9]+]]:_(<8 x s16>) = COPY $vh2
  ; CHECK-NEXT:   [[COPY11:%[0-9]+]]:_(<8 x s16>) = COPY $vh3
  ; CHECK-NEXT:   [[COPY12:%[0-9]+]]:_(<8 x s16>) = COPY $vh4
  ; CHECK-NEXT:   [[COPY13:%[0-9]+]]:_(<8 x s16>) = COPY $vh5
  ; CHECK-NEXT:   [[COPY14:%[0-9]+]]:_(<8 x s16>) = COPY $vh6
  ; CHECK-NEXT:   [[COPY15:%[0-9]+]]:_(<8 x s16>) = COPY $vh7
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<8 x s16>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<8 x s16>) from %fixed-stack.0)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s16) = G_EXTRACT_VECTOR_ELT [[LOAD]](<8 x s16>), [[C]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[EVEC]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
                              <8 x i16> %a5, <8 x i16> %a6, <8 x i16> %a7, <8 x i16> %a8,
                              <8 x i16> %a9, <8 x i16> %a10, <8 x i16> %a11, <8 x i16> %a12,
                              <8 x i16> %a13, <8 x i16> %a14, <8 x i16> %a15, <8 x i16> %a16,
                              <8 x i16> %a_stack) {
  %res = extractelement <8 x i16> %a_stack, i32 3
  ret i16 %res
}

define i8 @arg_v16int8(<16 x i8> %a1, <16 x i8> %a2, <16 x i8> %a3, <16 x i8> %a4,
  ; CHECK-LABEL: name: arg_v16int8
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -16, size: 16, alignment: 16, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $vh0, $vh1, $vh2, $vh3, $vh4, $vh5, $vh6, $vh7, $vl0, $vl1, $vl2, $vl3, $vl4, $vl5, $vl6, $vl7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<16 x s8>) = COPY $vl0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<16 x s8>) = COPY $vl1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<16 x s8>) = COPY $vl2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<16 x s8>) = COPY $vl3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(<16 x s8>) = COPY $vl4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(<16 x s8>) = COPY $vl5
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(<16 x s8>) = COPY $vl6
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(<16 x s8>) = COPY $vl7
  ; CHECK-NEXT:   [[COPY8:%[0-9]+]]:_(<16 x s8>) = COPY $vh0
  ; CHECK-NEXT:   [[COPY9:%[0-9]+]]:_(<16 x s8>) = COPY $vh1
  ; CHECK-NEXT:   [[COPY10:%[0-9]+]]:_(<16 x s8>) = COPY $vh2
  ; CHECK-NEXT:   [[COPY11:%[0-9]+]]:_(<16 x s8>) = COPY $vh3
  ; CHECK-NEXT:   [[COPY12:%[0-9]+]]:_(<16 x s8>) = COPY $vh4
  ; CHECK-NEXT:   [[COPY13:%[0-9]+]]:_(<16 x s8>) = COPY $vh5
  ; CHECK-NEXT:   [[COPY14:%[0-9]+]]:_(<16 x s8>) = COPY $vh6
  ; CHECK-NEXT:   [[COPY15:%[0-9]+]]:_(<16 x s8>) = COPY $vh7
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<16 x s8>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<16 x s8>) from %fixed-stack.0)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s8) = G_EXTRACT_VECTOR_ELT [[LOAD]](<16 x s8>), [[C]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[EVEC]](s8)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
                              <16 x i8> %a5, <16 x i8> %a6, <16 x i8> %a7, <16 x i8> %a8,
                              <16 x i8> %a9, <16 x i8> %a10, <16 x i8> %a11, <16 x i8> %a12,
                              <16 x i8> %a13, <16 x i8> %a14, <16 x i8> %a15, <16 x i8> %a16,
                              <16 x i8> %a_stack) {
  %res = extractelement <16 x i8> %a_stack, i32 3
  ret i8 %res
}

; 256-bit vector types

define i64 @arg_v4int64(<4 x i64> %a1, <4 x i64> %a2, <4 x i64> %a3, <4 x i64> %a4,
  ; CHECK-LABEL: name: arg_v4int64
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -32, size: 32, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $wc0, $wc1, $wd0, $wd1, $wr0, $wr1, $wr2, $wr3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<4 x s64>) = COPY $wr0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<4 x s64>) = COPY $wr1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<4 x s64>) = COPY $wr2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<4 x s64>) = COPY $wr3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(<4 x s64>) = COPY $wc0
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(<4 x s64>) = COPY $wc1
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(<4 x s64>) = COPY $wd0
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(<4 x s64>) = COPY $wd1
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<4 x s64>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<4 x s64>) from %fixed-stack.0)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s64) = G_EXTRACT_VECTOR_ELT [[LOAD]](<4 x s64>), [[C]](s32)
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[EVEC]](s64)
  ; CHECK-NEXT:   $r0 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0, implicit $r1
                              <4 x i64> %a5, <4 x i64> %a6, <4 x i64> %a7, <4 x i64> %a8,
                              <4 x i64> %a_stack) {
  %res = extractelement <4 x i64> %a_stack, i32 3
  ret i64 %res
}

define i32 @arg_v8int32(<8 x i32> %a1, <8 x i32> %a2, <8 x i32> %a3, <8 x i32> %a4,
  ; CHECK-LABEL: name: arg_v8int32
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -32, size: 32, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $wc0, $wc1, $wd0, $wd1, $wr0, $wr1, $wr2, $wr3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<8 x s32>) = COPY $wr0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<8 x s32>) = COPY $wr1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<8 x s32>) = COPY $wr2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<8 x s32>) = COPY $wr3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(<8 x s32>) = COPY $wc0
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(<8 x s32>) = COPY $wc1
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(<8 x s32>) = COPY $wd0
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(<8 x s32>) = COPY $wd1
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<8 x s32>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<8 x s32>) from %fixed-stack.0)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s32) = G_EXTRACT_VECTOR_ELT [[LOAD]](<8 x s32>), [[C]](s32)
  ; CHECK-NEXT:   $r0 = COPY [[EVEC]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
                              <8 x i32> %a5, <8 x i32> %a6, <8 x i32> %a7, <8 x i32> %a8,
                              <8 x i32> %a_stack) {
  %res = extractelement <8 x i32> %a_stack, i32 3
  ret i32 %res
}

define i16 @arg_v16int16(<16 x i16> %a1, <16 x i16> %a2, <16 x i16> %a3, <16 x i16> %a4,
  ; CHECK-LABEL: name: arg_v16int16
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -32, size: 32, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $wc0, $wc1, $wd0, $wd1, $wr0, $wr1, $wr2, $wr3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<16 x s16>) = COPY $wr0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<16 x s16>) = COPY $wr1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<16 x s16>) = COPY $wr2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<16 x s16>) = COPY $wr3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(<16 x s16>) = COPY $wc0
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(<16 x s16>) = COPY $wc1
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(<16 x s16>) = COPY $wd0
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(<16 x s16>) = COPY $wd1
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<16 x s16>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<16 x s16>) from %fixed-stack.0)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s16) = G_EXTRACT_VECTOR_ELT [[LOAD]](<16 x s16>), [[C]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[EVEC]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
                                <16 x i16> %a5, <16 x i16> %a6, <16 x i16> %a7, <16 x i16> %a8,
                                <16 x i16> %a_stack) {
  %res = extractelement <16 x i16> %a_stack, i32 3
  ret i16 %res
}

define i8 @arg_v32int8(<32 x i8> %a1, <32 x i8> %a2, <32 x i8> %a3, <32 x i8> %a4,
  ; CHECK-LABEL: name: arg_v32int8
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -32, size: 32, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $wc0, $wc1, $wd0, $wd1, $wr0, $wr1, $wr2, $wr3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<32 x s8>) = COPY $wr0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<32 x s8>) = COPY $wr1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<32 x s8>) = COPY $wr2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<32 x s8>) = COPY $wr3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(<32 x s8>) = COPY $wc0
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(<32 x s8>) = COPY $wc1
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(<32 x s8>) = COPY $wd0
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(<32 x s8>) = COPY $wd1
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<32 x s8>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<32 x s8>) from %fixed-stack.0)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s8) = G_EXTRACT_VECTOR_ELT [[LOAD]](<32 x s8>), [[C]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[EVEC]](s8)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
                              <32 x i8> %a5, <32 x i8> %a6, <32 x i8> %a7, <32 x i8> %a8,
                              <32 x i8> %a_stack) {
  %res = extractelement <32 x i8> %a_stack, i32 3
  ret i8 %res
}

; 512-bit vector types

define i64 @arg_v8int64(<8 x i64> %a1, <8 x i64> %a2, <8 x i64> %a3, <8 x i64> %a4,
  ; CHECK-LABEL: name: arg_v8int64
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -64, size: 64, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $xa, $xb, $xc, $xd
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<8 x s64>) = COPY $xa
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<8 x s64>) = COPY $xb
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<8 x s64>) = COPY $xc
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<8 x s64>) = COPY $xd
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<8 x s64>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<8 x s64>) from %fixed-stack.0, align 32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s64) = G_EXTRACT_VECTOR_ELT [[LOAD]](<8 x s64>), [[C]](s32)
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[EVEC]](s64)
  ; CHECK-NEXT:   $r0 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0, implicit $r1
                              <8 x i64> %a_stack) {
  %res = extractelement <8 x i64> %a_stack, i32 3
  ret i64 %res
}

define i32 @arg_v16int32(<16 x i32> %a1, <16 x i32> %a2, <16 x i32> %a3, <16 x i32> %a4,
  ; CHECK-LABEL: name: arg_v16int32
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -64, size: 64, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $xa, $xb, $xc, $xd
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<16 x s32>) = COPY $xa
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<16 x s32>) = COPY $xb
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<16 x s32>) = COPY $xc
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<16 x s32>) = COPY $xd
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<16 x s32>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<16 x s32>) from %fixed-stack.0, align 32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s32) = G_EXTRACT_VECTOR_ELT [[LOAD]](<16 x s32>), [[C]](s32)
  ; CHECK-NEXT:   $r0 = COPY [[EVEC]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
                                <16 x i32> %a_stack) {
  %res = extractelement <16 x i32> %a_stack, i32 3
  ret i32 %res
}

define i16 @arg_v32int16(<32 x i16> %a1, <32 x i16> %a2, <32 x i16> %a3, <32 x i16> %a4,
  ; CHECK-LABEL: name: arg_v32int16
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -64, size: 64, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $xa, $xb, $xc, $xd
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<32 x s16>) = COPY $xa
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<32 x s16>) = COPY $xb
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<32 x s16>) = COPY $xc
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<32 x s16>) = COPY $xd
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<32 x s16>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<32 x s16>) from %fixed-stack.0, align 32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s16) = G_EXTRACT_VECTOR_ELT [[LOAD]](<32 x s16>), [[C]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[EVEC]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
                                <32 x i16> %a_stack) {
  %res = extractelement <32 x i16> %a_stack, i32 3
  ret i16 %res
}

define i8 @arg_v64int8(<64 x i8> %a1, <64 x i8> %a2, <64 x i8> %a3, <64 x i8> %a4,
  ; CHECK-LABEL: name: arg_v64int8
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -64, size: 64, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $xa, $xb, $xc, $xd
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<64 x s8>) = COPY $xa
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<64 x s8>) = COPY $xb
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(<64 x s8>) = COPY $xc
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(<64 x s8>) = COPY $xd
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<64 x s8>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<64 x s8>) from %fixed-stack.0, align 32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s8) = G_EXTRACT_VECTOR_ELT [[LOAD]](<64 x s8>), [[C]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[EVEC]](s8)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
                              <64 x i8> %a_stack) {
  %res = extractelement <64 x i8> %a_stack, i32 3
  ret i8 %res
}

; 1024-bit vector types

define i32 @arg_v32int32(<32 x i32> %a1, <32 x i32> %a_stack) {
  ; CHECK-LABEL: name: arg_v32int32
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -128, size: 128, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $ya
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<32 x s32>) = COPY $ya
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<32 x s32>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<32 x s32>) from %fixed-stack.0, align 32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s32) = G_EXTRACT_VECTOR_ELT [[LOAD]](<32 x s32>), [[C]](s32)
  ; CHECK-NEXT:   $r0 = COPY [[EVEC]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
  %res = extractelement <32 x i32> %a_stack, i32 3
  ret i32 %res
}

define i16 @arg_v64int16(<64 x i16> %a1, <64 x i16> %a_stack) {
  ; CHECK-LABEL: name: arg_v64int16
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -128, size: 128, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $ya
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<64 x s16>) = COPY $ya
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<64 x s16>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<64 x s16>) from %fixed-stack.0, align 32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s16) = G_EXTRACT_VECTOR_ELT [[LOAD]](<64 x s16>), [[C]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[EVEC]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
  %res = extractelement <64 x i16> %a_stack, i32 3
  ret i16 %res
}

define i8 @arg_v128int8(<128 x i8> %a1, <128 x i8> %a_stack) {
  ; CHECK-LABEL: name: arg_v128int8
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -128, size: 128, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $ya
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<128 x s8>) = COPY $ya
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<128 x s8>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<128 x s8>) from %fixed-stack.0, align 32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[EVEC:%[0-9]+]]:_(s8) = G_EXTRACT_VECTOR_ELT [[LOAD]](<128 x s8>), [[C]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[EVEC]](s8)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
  %res = extractelement <128 x i8> %a_stack, i32 3
  ret i8 %res
}

; The YA reg is used by the result type, and it overlaps with vlX and vhX regs.
; Therefore, %a1 cannot be passed in vl0
define <32 x i32> @retcc_reserved_vl(<4 x i32> %a1) {
  ; CHECK-LABEL: name: retcc_reserved_vl
  ; CHECK: fixedStack:
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $vl4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<4 x s32>) = COPY $vl4
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<32 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   $ya = COPY [[BUILD_VECTOR]](<32 x s32>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $ya
  ret <32 x i32> zeroinitializer
}

; The YA reg is used by the result type, and it overlaps with wrX regs.
; Therefore, %a1 cannot be passed in WR0
define <32 x i32> @retcc_reserved_wr(<8 x i32> %a1) {
  ; CHECK-LABEL: name: retcc_reserved_wr
  ; CHECK: fixedStack:
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $wc0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<8 x s32>) = COPY $wc0
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<32 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   $ya = COPY [[BUILD_VECTOR]](<32 x s32>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $ya
  ret <32 x i32> zeroinitializer
}

; The YA reg is used by the result type, and it overlaps with XA and XB regs.
; Therefore, %a1 cannot be passed in XA or XB.
define <32 x i32> @retcc_reserved_xa_xb(<16 x i32> %a1) {
  ; CHECK-LABEL: name: retcc_reserved_xa_xb
  ; CHECK: fixedStack:
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $xc
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<16 x s32>) = COPY $xc
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<32 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   $ya = COPY [[BUILD_VECTOR]](<32 x s32>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $ya
  ret <32 x i32> zeroinitializer
}

; The YA reg is used by the result type, and it overlaps with the YD reg
; Therefore, %a1 is passed on the stack.
define <32 x i32> @retcc_reserved_ya(<32 x i32> %a1) {
  ; CHECK-LABEL: name: retcc_reserved_ya
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -128, size: 128, alignment: 32, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<32 x s32>) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (<32 x s32>) from %fixed-stack.0, align 32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<32 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   $ya = COPY [[BUILD_VECTOR]](<32 x s32>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $ya
  ret <32 x i32> zeroinitializer
}
