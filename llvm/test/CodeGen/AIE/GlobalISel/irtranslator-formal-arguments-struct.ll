; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --print-fixed-stack
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

%struct.S4I = type { i32, i32, i32, i32 }
%struct.SLII = type { i64, i32 }
%struct.S4P = type { i32*, i32*, i32*, i32* }
%struct.S2I2P = type { i32, i32, i32*, i32* }

@g_ptr_32 = global i32 0

; Check that structs passed by value are used properly:
; extractvalue %struct.S4I %a, 3 should be in $r9
; extractvalue %struct.S4I %b, 3 should be in [sp, #-16]
define void @use_2S4I(%struct.S4I %a, %struct.S4I %b) {
  ; CHECK-LABEL: name: use_2S4I
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -16, size: 4, alignment: 16, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK:   - { id: 1, type: default, offset: -12, size: 4, alignment: 4, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK:   - { id: 2, type: default, offset: -8, size: 4, alignment: 8, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK:   - { id: 3, type: default, offset: -4, size: 4, alignment: 4, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r6, $r7, $r8, $r9
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r6
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r7
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s32) = COPY $r8
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r9
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.3
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s32) from %fixed-stack.3)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.2
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX1]](p0) :: (invariant load (s32) from %fixed-stack.2, align 8)
  ; CHECK-NEXT:   [[FRAME_INDEX2:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD2:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX2]](p0) :: (invariant load (s32) from %fixed-stack.1)
  ; CHECK-NEXT:   [[FRAME_INDEX3:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD3:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX3]](p0) :: (invariant load (s32) from %fixed-stack.0, align 16)
  ; CHECK-NEXT:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @g_ptr_32
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s32) = G_ADD [[COPY3]], [[LOAD3]]
  ; CHECK-NEXT:   G_STORE [[ADD]](s32), [[GV]](p0) :: (store (s32) into @g_ptr_32)
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  %a.3.extract = extractvalue %struct.S4I %a, 3
  %b.3.extract = extractvalue %struct.S4I %b, 3
  %res = add i32 %a.3.extract, %b.3.extract
  store i32 %res, i32* @g_ptr_32
  ret void
}

define void @pass_2S4P(%struct.S4P, %struct.S4P) {
  ; CHECK-LABEL: name: pass_2S4P
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -8, size: 3, alignment: 8, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK:   - { id: 1, type: default, offset: -4, size: 3, alignment: 4, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $p0, $p1, $p2, $p3, $p4, $p5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(p0) = COPY $p1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(p0) = COPY $p2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(p0) = COPY $p3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(p0) = COPY $p4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(p0) = COPY $p5
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(p0) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s20) from %fixed-stack.1, align 4)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(p0) = G_LOAD [[FRAME_INDEX1]](p0) :: (invariant load (s20) from %fixed-stack.0, align 8)
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  ret void
}

define void @pass_2S2I2P(%struct.S2I2P, %struct.S2I2P) {
  ; CHECK-LABEL: name: pass_2S2I2P
  ; CHECK: fixedStack:
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $p0, $p1, $p2, $p3, $r6, $r7, $r8, $r9
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r6
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r7
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(p0) = COPY $p1
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(s32) = COPY $r8
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(s32) = COPY $r9
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(p0) = COPY $p2
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(p0) = COPY $p3
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  ret void
}

; Pass a struct on the reg-stack boundary, it will be passed partly in
; registers, partly on the stack.
define void @use_IS4I(i32 %a, %struct.S4I %s) {
  ; CHECK-LABEL: name: use_IS4I
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -4, size: 4, alignment: 4, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r6, $r7, $r8, $r9
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r6
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r7
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s32) = COPY $r8
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r9
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s32) from %fixed-stack.0)
  ; CHECK-NEXT:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @g_ptr_32
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s32) = G_ADD [[COPY1]], [[LOAD]]
  ; CHECK-NEXT:   G_STORE [[ADD]](s32), [[GV]](p0) :: (store (s32) into @g_ptr_32)
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  %s.0.extract = extractvalue %struct.S4I %s, 0
  %s.3.extract = extractvalue %struct.S4I %s, 3
  %res = add i32 %s.0.extract, %s.3.extract
  store i32 %res, i32* @g_ptr_32
  ret void
}

; %struct.SLII crosses the register-stack boundary
; The long int isn't split between reg and stack, but moved entirely to the
; stack. The last element of the struct fits in the last free register, so
; it is moved there (not preserving the struct ordering).
define void @use_3I_SLII(i32 %a, i32 %b, i32 %c, %struct.SLII %s) {
  ; CHECK-LABEL: name: use_3I_SLII
  ; CHECK: fixedStack:
  ; CHECK:   - { id: 0, type: default, offset: -4, size: 4, alignment: 4, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK:   - { id: 1, type: default, offset: -8, size: 4, alignment: 8, stack-id: default,
  ; CHECK:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true,
  ; CHECK:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r6, $r7, $r8, $r9
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r6
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r7
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s32) = COPY $r8
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s32) from %fixed-stack.1, align 8)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX1]](p0) :: (invariant load (s32) from %fixed-stack.0)
  ; CHECK-NEXT:   [[MV:%[0-9]+]]:_(s64) = G_MERGE_VALUES [[LOAD]](s32), [[LOAD1]](s32)
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r9
  ; CHECK-NEXT:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @g_ptr_32
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s32) = G_TRUNC [[MV]](s64)
  ; CHECK-NEXT:   G_STORE [[TRUNC]](s32), [[GV]](p0) :: (store (s32) into @g_ptr_32)
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  %s.0.extract = extractvalue %struct.SLII %s, 0
  %s.1.extract = extractvalue %struct.SLII %s, 1
  %tmp = trunc i64 %s.0.extract to i32
  store i32 %tmp, i32* @g_ptr_32
  ret void
}

; (AIE1) r0,r6,r7,r8 are reserved by the result type.
;        Parameters are passed from r9
define %struct.S4I @retcc_reserved_GPRs(i32 %val) {
  ; CHECK-LABEL: name: retcc_reserved_GPRs
  ; CHECK: fixedStack:
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r9
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r9
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s32) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   $r0 = COPY [[COPY]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[COPY]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[COPY]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[COPY]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0, implicit $r6, implicit $r7, implicit $r8
  %s1 = insertvalue %struct.S4I undef, i32 %val, 0
  %s2 = insertvalue %struct.S4I %s1, i32 %val, 1
  %s3 = insertvalue %struct.S4I %s2, i32 %val, 2
  %s4 = insertvalue %struct.S4I %s3, i32 %val, 3
  ret %struct.S4I %s4
}
