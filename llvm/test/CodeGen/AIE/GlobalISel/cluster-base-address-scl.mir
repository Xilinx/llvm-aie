# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -mtriple aie2 -run-pass=aie-cluster-base-address --aie-chain-addr-scl-ldst --aie-chain-addr-vec-ldst=false %s -verify-machineinstrs -o - | FileCheck %s

---
name:            loads_and_stores_with_same_base_ptr_single_bb
body:             |
  bb.1.entry:
    liveins: $p0
    ; CHECK-LABEL: name: loads_and_stores_with_same_base_ptr_single_bb
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(p0) = COPY $p0
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s20) = G_CONSTANT i20 4
    ; CHECK-NEXT: [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C]](s20)
    ; CHECK-NEXT: [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD]](p0) :: (load (s32))
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 32
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s20) = G_CONSTANT i20 28
    ; CHECK-NEXT: [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD]], [[C2]](s20)
    ; CHECK-NEXT: [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD1]](p0) :: (load (s32))
    ; CHECK-NEXT: [[C3:%[0-9]+]]:_(s20) = G_CONSTANT i20 -24
    ; CHECK-NEXT: [[C4:%[0-9]+]]:_(s20) = G_CONSTANT i20 -56
    ; CHECK-NEXT: [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD1]], [[C4]](s20)
    ; CHECK-NEXT: [[LOAD2:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD2]](p0) :: (load (s32))
    ; CHECK-NEXT: G_STORE [[LOAD2]](s32), [[PTR_ADD2]](p0) :: (store (s32))
    ; CHECK-NEXT: [[C5:%[0-9]+]]:_(s20) = G_CONSTANT i20 128
    ; CHECK-NEXT: [[C6:%[0-9]+]]:_(s20) = G_CONSTANT i20 152
    ; CHECK-NEXT: [[PTR_ADD3:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD2]], [[C6]](s20)
    %0:_(p0) = COPY $p0
    %1:_(s20) = G_CONSTANT i20 4
    %2:_(p0) = G_PTR_ADD %0:_, %1:_(s20)
    %3:_(s32) = G_LOAD %2:_(p0) :: (load (s32), align 4)
    %4:_(s20) = G_CONSTANT i20 32
    %5:_(p0) = G_PTR_ADD %0:_, %4:_(s20)
    %6:_(s32) = G_LOAD %5:_(p0) :: (load (s32), align 4)
    %7:_(s20) = G_CONSTANT i20 -24
    %8:_(p0) = G_PTR_ADD %0:_, %7:_(s20)
    %9:_(s32) = G_LOAD %8:_(p0) :: (load (s32), align 4)
    G_STORE %9:_(s32), %8:_(p0) :: (store (s32), align 4)
    %10:_(s20) = G_CONSTANT i20 128
    %11:_(p0) = G_PTR_ADD %0:_, %10:_(s20)

...

# In this example we test loads and stores having 2 separate base ptrs.
---
name:            loads_stores_with_multiple_base_ptrs_single_bb
body:             |
  bb.1.entry:
    liveins: $p0, $p1
    ; CHECK-LABEL: name: loads_stores_with_multiple_base_ptrs_single_bb
    ; CHECK: liveins: $p0, $p1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(p0) = COPY $p0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(p0) = COPY $p1
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s20) = G_CONSTANT i20 4
    ; CHECK-NEXT: [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C]](s20)
    ; CHECK-NEXT: [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[COPY]](p0) :: (load (s32))
    ; CHECK-NEXT: G_STORE [[LOAD]](s32), [[COPY1]](p0) :: (store (s32))
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 8
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s20) = G_CONSTANT i20 8
    ; CHECK-NEXT: [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C2]](s20)
    ; CHECK-NEXT: [[C3:%[0-9]+]]:_(s20) = G_CONSTANT i20 -28
    ; CHECK-NEXT: [[C4:%[0-9]+]]:_(s20) = G_CONSTANT i20 -28
    ; CHECK-NEXT: [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C4]](s20)
    ; CHECK-NEXT: [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD]](p0) :: (load (s32))
    ; CHECK-NEXT: G_STORE [[LOAD1]](s32), [[PTR_ADD1]](p0) :: (store (s32))
    ; CHECK-NEXT: [[C5:%[0-9]+]]:_(s20) = G_CONSTANT i20 -36
    ; CHECK-NEXT: [[C6:%[0-9]+]]:_(s20) = G_CONSTANT i20 -44
    ; CHECK-NEXT: [[PTR_ADD3:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD1]], [[C6]](s20)
    ; CHECK-NEXT: [[C7:%[0-9]+]]:_(s20) = G_CONSTANT i20 24
    ; CHECK-NEXT: [[C8:%[0-9]+]]:_(s20) = G_CONSTANT i20 20
    ; CHECK-NEXT: [[PTR_ADD4:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD]], [[C8]](s20)
    %0:_(p0) = COPY $p0
    %1:_(p0) = COPY $p1
    %2:_(s20) = G_CONSTANT i20 4
    %3:_(p0) = G_PTR_ADD %0:_, %2:_(s20)
    %4:_(s32) = G_LOAD %0:_(p0) :: (load (s32), align 4)
    G_STORE %4:_(s32), %1:_(p0) :: (store (s32), align 4)
    %5:_(s20) = G_CONSTANT i20 8
    %6:_(p0) = G_PTR_ADD %1:_, %5:_(s20)
    %7:_(s20) = G_CONSTANT i20 -28
    %8:_(p0) = G_PTR_ADD %0:_, %7:_(s20)
    ; G_LOAD has base ptr %0
    %9:_(s32) = G_LOAD %3:_(p0) :: (load (s32), align 4)
    ; G_STORE has base ptr %1
    G_STORE %9:_(s32), %6:_(p0) :: (store (s32), align 4)
    %10:_(s20) = G_CONSTANT i20 -36
    %11:_(p0) = G_PTR_ADD %1:_, %10:_(s20)
    %12:_(s20) = G_CONSTANT i20 24
    %13:_(p0) = G_PTR_ADD %0:_, %12:_(s20)
...

# Here we test offsets having multiple uses other than just ptr adds
# If another use is found, we create a new G_CONSTANT and
# update the corresponding ptr add accordingly.
---
name:            offsets_having_multiple_uses_single_bb
body:             |
  bb.1.entry:
    liveins: $p0
    ; CHECK-LABEL: name: offsets_having_multiple_uses_single_bb
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(p0) = COPY $p0
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s20) = G_CONSTANT i20 4
    ; CHECK-NEXT: [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C]](s20)
    ; CHECK-NEXT: [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD]](p0) :: (load (s32))
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 12
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s20) = G_CONSTANT i20 8
    ; CHECK-NEXT: [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD]], [[C2]](s20)
    ; CHECK-NEXT: [[C3:%[0-9]+]]:_(s20) = G_CONSTANT i20 8
    ; CHECK-NEXT: [[ADD:%[0-9]+]]:_(s20) = G_ADD [[C1]], [[C3]]
    ; CHECK-NEXT: [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD1]](p0) :: (load (s32))
    ; CHECK-NEXT: [[C4:%[0-9]+]]:_(s20) = G_CONSTANT i20 32
    ; CHECK-NEXT: [[C5:%[0-9]+]]:_(s20) = G_CONSTANT i20 20
    ; CHECK-NEXT: [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD1]], [[C5]](s20)
    %0:_(p0) = COPY $p0
    %1:_(s20) = G_CONSTANT i20 4
    %2:_(p0) = G_PTR_ADD %0:_, %1:_(s20)
    %3:_(s32) = G_LOAD %2:_(p0) :: (load (s32), align 4)
    %4:_(s20) = G_CONSTANT i20 12
    ; This is the first use of the %4
    %5:_(p0) = G_PTR_ADD %0:_, %4:_(s20)
    %6:_(s20) = G_CONSTANT i20 8
    ; This is the second use of the %4
    %7:_(s20) = G_ADD %4:_(s20), %6:_(s20)
    %8:_(s32) = G_LOAD %5:_(p0) :: (load (s32), align 4)
    %9:_(s20) = G_CONSTANT i20 32
    %10:_(p0) = G_PTR_ADD %0:_, %9:_(s20)
...

# In this example we have multiple loads [having same base ptr] between
# 2 ptr adds. In this case the ptr add will be modified according to the
# immediately preceding load. Same with stores.
---
name:            multiple_loads_between_ptradds_single_bb
body:             |
  bb.1.entry:
    liveins: $p0
    ; CHECK-LABEL: name: multiple_loads_between_ptradds_single_bb
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(p0) = COPY $p0
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s20) = G_CONSTANT i20 4
    ; CHECK-NEXT: [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C]](s20)
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 128
    ; CHECK-NEXT: [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
    ; CHECK-NEXT: [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD]](p0) :: (load (s32))
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
    ; CHECK-NEXT: [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
    ; CHECK-NEXT: [[ADD:%[0-9]+]]:_(s32) = G_ADD [[C2]], [[C3]]
    ; CHECK-NEXT: [[LOAD1:%[0-9]+]]:_(<32 x s16>) = G_LOAD [[PTR_ADD]](p0) :: (load (<32 x s16>))
    ; CHECK-NEXT: [[LOAD2:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD1]](p0) :: (load (s32))
    ; CHECK-NEXT: [[C4:%[0-9]+]]:_(s20) = G_CONSTANT i20 232
    ; CHECK-NEXT: [[C5:%[0-9]+]]:_(s20) = G_CONSTANT i20 104
    ; CHECK-NEXT: [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD1]], [[C5]](s20)
    ; CHECK-NEXT: [[LOAD3:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD2]](p0) :: (load (s32))
    ; CHECK-NEXT: [[C6:%[0-9]+]]:_(s20) = G_CONSTANT i20 116
    ; CHECK-NEXT: [[C7:%[0-9]+]]:_(s20) = G_CONSTANT i20 -116
    ; CHECK-NEXT: [[PTR_ADD3:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD2]], [[C7]](s20)
    %0:_(p0) = COPY $p0
    %1:_(s20) = G_CONSTANT i20 4
    %2:_(p0) = G_PTR_ADD %0:_, %1:_(s20)
    %3:_(s20) = G_CONSTANT i20 128
    %4:_(p0) = G_PTR_ADD %0:_, %3:_(s20)
    %5:_(s32) = G_LOAD %2:_(p0) :: (load (s32))
    %6:_(s32) = G_CONSTANT i32 0
    %7:_(s32) = G_CONSTANT i32 1
    %8:_(s32) = G_ADD %6:_, %7:_
    %9:_(<32 x s16>) = G_LOAD %2:_(p0) :: (load (<32 x s16>))
    %10:_(s32) = G_LOAD %4:_(p0) :: (load (s32))
    %11:_(s20) = G_CONSTANT i20 232
    ; This ptradd will change according to %10
    %12:_(p0) = G_PTR_ADD %0:_, %11:_(s20)
    %13:_(s32) = G_LOAD %12:_(p0) :: (load (s32))
    %14:_(s20) = G_CONSTANT i20 116
    %15:_(p0) = G_PTR_ADD %0:_, %14:_(s20)
...

# Here we have multiple ptradds between 2 loads or stores.
# In this case the immediately succeeding ptr add to the load
# or store will change, if there is no existing use of the base ptr after that.
# Rest will remain unaffected.
---
name:            multiple_ptradds_between_loads_or_stores_single_bb
body:             |
  bb.1.entry:
    liveins: $p0
    ; CHECK-LABEL: name: multiple_ptradds_between_loads_or_stores_single_bb
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(p0) = COPY $p0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(p0) = COPY $p1
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s20) = G_CONSTANT i20 4
    ; CHECK-NEXT: [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C]](s20)
    ; CHECK-NEXT: [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[COPY]](p0) :: (load (s32))
    ; CHECK-NEXT: G_STORE [[LOAD]](s32), [[COPY1]](p0) :: (store (s32))
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 8
    ; CHECK-NEXT: [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C1]](s20)
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s20) = G_CONSTANT i20 12
    ; CHECK-NEXT: [[C3:%[0-9]+]]:_(s20) = G_CONSTANT i20 12
    ; CHECK-NEXT: [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C3]](s20)
    ; CHECK-NEXT: [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD]](p0) :: (load (s32))
    ; CHECK-NEXT: G_STORE [[LOAD1]](s32), [[PTR_ADD1]](p0) :: (store (s32))
    ; CHECK-NEXT: [[C4:%[0-9]+]]:_(s20) = G_CONSTANT i20 16
    ; CHECK-NEXT: [[PTR_ADD3:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C4]](s20)
    ; CHECK-NEXT: [[C5:%[0-9]+]]:_(s20) = G_CONSTANT i20 24
    ; CHECK-NEXT: [[PTR_ADD4:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C5]](s20)
    ; CHECK-NEXT: [[C6:%[0-9]+]]:_(s20) = G_CONSTANT i20 32
    ; CHECK-NEXT: [[C7:%[0-9]+]]:_(s20) = G_CONSTANT i20 28
    ; CHECK-NEXT: [[PTR_ADD5:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD]], [[C7]](s20)
    %0:_(p0) = COPY $p0
    %1:_(p0) = COPY $p1
    %2:_(s20) = G_CONSTANT i20 4
    %3:_(p0) = G_PTR_ADD %0:_, %2:_(s20)
    %4:_(s32) = G_LOAD %0:_(p0) :: (load (s32), align 4)
    G_STORE %4:_(s32), %1:_(p0) :: (store (s32), align 4)
    %5:_(s20) = G_CONSTANT i20 8
    %6:_(p0) = G_PTR_ADD %1:_, %5:_(s20)
    %7:_(s20) = G_CONSTANT i20 12
    %8:_(p0) = G_PTR_ADD %0:_, %7:_(s20)
    %9:_(s32) = G_LOAD %3:_(p0) :: (load (s32), align 4)
    G_STORE %9:_(s32), %6:_(p0) :: (store (s32), align 4)
    %10:_(s20) = G_CONSTANT i20 16
    ; This ptradd will not change.
    ; There is a use of %1 later.
    %11:_(p0) = G_PTR_ADD %1:_, %10:_(s20)
    %12:_(s20) = G_CONSTANT i20 24
    ; This ptradd will not change.
    %13:_(p0) = G_PTR_ADD %1:_, %12:_(s20)
    %14:_(s20) = G_CONSTANT i20 32
    %15:_(p0) = G_PTR_ADD %0:_, %14:_(s20)
...

# Here we test loads and stores across multiple BBs.
# In case a base register is found in the successor BB,
# we skip chaining that ptr add since it will create an extra copy.
# This test also introduces a self-loop for bb.1 to check whether the
# chaining opportunities are not missed in the current MBB.
---
name:            loads_stores_2BBs
body:             |
  ; CHECK-LABEL: name: loads_stores_2BBs
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $p3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p3
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s20) = G_CONSTANT i20 5
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C2]](s20)
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD]](p0) :: (dereferenceable load (s32))
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s32) = G_ADD [[LOAD]], [[C]]
  ; CHECK-NEXT:   G_STORE [[ADD]](s32), [[PTR_ADD]](p0) :: (store (s32))
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s20) = G_CONSTANT i20 4
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C3]](s20)
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD1]](p0) :: (dereferenceable load (s32))
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 255
  ; CHECK-NEXT:   [[AND:%[0-9]+]]:_(s32) = G_AND [[LOAD1]], [[C4]]
  ; CHECK-NEXT:   G_BR %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[C5:%[0-9]+]]:_(s20) = G_CONSTANT i20 19
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C5]](s20)
  ; CHECK-NEXT:   G_STORE [[C1]](s32), [[PTR_ADD2]](p0) :: (store (s32))
  ; CHECK-NEXT:   [[C6:%[0-9]+]]:_(s20) = G_CONSTANT i20 20
  ; CHECK-NEXT:   [[C7:%[0-9]+]]:_(s20) = G_CONSTANT i20 1
  ; CHECK-NEXT:   [[PTR_ADD3:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD2]], [[C7]](s20)
  ; CHECK-NEXT:   G_STORE [[C1]](s32), [[PTR_ADD3]](p0) :: (store (s32))
  ; CHECK-NEXT:   [[C8:%[0-9]+]]:_(s20) = G_CONSTANT i20 12
  ; CHECK-NEXT:   [[C9:%[0-9]+]]:_(s20) = G_CONSTANT i20 -8
  ; CHECK-NEXT:   [[PTR_ADD4:%[0-9]+]]:_(p0) = G_PTR_ADD [[PTR_ADD3]], [[C9]](s20)
  ; CHECK-NEXT:   G_STORE [[C1]](s32), [[PTR_ADD4]](p0) :: (store (s32))
  ; CHECK-NEXT:   G_BR %bb.1
  bb.0.entry:
    liveins: $p3
    %0:_(p0) = COPY $p3
    %1:_(s32) = G_CONSTANT i32 1
    %2:_(s32) = G_CONSTANT i32 0
    %3:_(s20) = G_CONSTANT i20 5
    %4:_(p0) = G_PTR_ADD %0:_, %3:_(s20)
    %5:_(s32) = G_LOAD %4:_(p0) :: (dereferenceable load (s32))
    %6:_(s32) = G_ADD %5:_, %1:_
    G_STORE %6:_(s32), %4:_(p0) :: (store (s32))
    %7:_(s20) = G_CONSTANT i20 4
    ; This ptr add will not change since %0 has use in bb.1
    %8:_(p0) = G_PTR_ADD %0:_, %7:_(s20)
    %9:_(s32) = G_LOAD %8:_(p0) :: (dereferenceable load (s32))
    %10:_(s32) = G_CONSTANT i32 255
    %11:_(s32) = G_AND %9:_, %10:_
    G_BR %bb.1

  bb.1:
    %12:_(s20) = G_CONSTANT i20 19
    %13:_(p0) = G_PTR_ADD %0:_, %12:_(s20)
    G_STORE %2:_(s32), %13:_(p0) :: (store (s32))
    %14:_(s20) = G_CONSTANT i20 20
    %15:_(p0) = G_PTR_ADD %0:_, %14:_(s20)
    G_STORE %2:_(s32), %15:_(p0) :: (store (s32))
    %16:_(s20) = G_CONSTANT i20 12
    %17:_(p0) = G_PTR_ADD %0:_, %16:_(s20)
    G_STORE %2:_(s32), %17:_(p0) :: (store (s32))
    G_BR %bb.1
...
