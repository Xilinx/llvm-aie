; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

declare void @trivial_callee()
define void @test_trivial_call() {
  ; CHECK-LABEL: name: test_trivial_call
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   JAL @trivial_callee, csr_aie1, implicit-def $lr
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @trivial_callee()
  ret void
}

declare void @callee_i32(i32 %a)
define void @test_call_i32() {
  ; CHECK-LABEL: name: test_call_i32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   JAL @callee_i32, csr_aie1, implicit-def $lr, implicit $r6
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_i32(i32 0)
  ret void
}

define void @test_indirect_call(void()* %func) {
  ; CHECK-LABEL: name: test_indirect_call
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:mcb(p0) = COPY $p0
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   JAL_IND [[COPY]](p0), csr_aie1, implicit-def $lr
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void %func()
  ret void
}

declare void @take_i8(i8)
define void @test_abi_exts_call_i8(i8* %addr) {
  ; CHECK-LABEL: name: test_abi_exts_call_i8
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s8) = G_LOAD [[COPY]](p0) :: (load (s8) from %ir.addr)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[LOAD]](s8)
  ; CHECK-NEXT:   $r6 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   JAL @take_i8, csr_aie1, implicit-def $lr, implicit $r6
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[SEXT:%[0-9]+]]:_(s32) = G_SEXT [[LOAD]](s8)
  ; CHECK-NEXT:   $r6 = COPY [[SEXT]](s32)
  ; CHECK-NEXT:   JAL @take_i8, csr_aie1, implicit-def $lr, implicit $r6
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[LOAD]](s8)
  ; CHECK-NEXT:   $r6 = COPY [[ZEXT]](s32)
  ; CHECK-NEXT:   JAL @take_i8, csr_aie1, implicit-def $lr, implicit $r6
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  %val = load i8, i8* %addr
  call void @take_i8(i8 %val)
  call void @take_i8(i8 signext %val)
  call void @take_i8(i8 zeroext %val)
  ret void
}

declare void @take_i16(i16)
define void @test_abi_exts_call_i16(i16* %addr) {
  ; CHECK-LABEL: name: test_abi_exts_call_i16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s16) = G_LOAD [[COPY]](p0) :: (load (s16) from %ir.addr)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[LOAD]](s16)
  ; CHECK-NEXT:   $r6 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   JAL @take_i16, csr_aie1, implicit-def $lr, implicit $r6
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[SEXT:%[0-9]+]]:_(s32) = G_SEXT [[LOAD]](s16)
  ; CHECK-NEXT:   $r6 = COPY [[SEXT]](s32)
  ; CHECK-NEXT:   JAL @take_i16, csr_aie1, implicit-def $lr, implicit $r6
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[LOAD]](s16)
  ; CHECK-NEXT:   $r6 = COPY [[ZEXT]](s32)
  ; CHECK-NEXT:   JAL @take_i16, csr_aie1, implicit-def $lr, implicit $r6
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  %val = load i16, i16* %addr
  call void @take_i16(i16 %val)
  call void @take_i16(i16 signext %val)
  call void @take_i16(i16 zeroext %val)
  ret void
}

declare void @multiple_args_callee(i32, i64)
define void @test_multiple_args(i64 %in) {
  ; CHECK-LABEL: name: test_multiple_args
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r6, $r7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r6
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r7
  ; CHECK-NEXT:   [[MV:%[0-9]+]]:_(s64) = G_MERGE_VALUES [[COPY]](s32), [[COPY1]](s32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 42
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[MV]](s64)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   JAL @multiple_args_callee, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @multiple_args_callee(i32 42, i64 %in)
  ret void
}

declare void @test_stack_slots_i8(i64 %r6r7, i64 %r8r9, i8)
define void @test_call_stack_i8() {
  ; CHECK-LABEL: name: test_call_stack_i8
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s64) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s8) = G_CONSTANT i8 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[UV2:%[0-9]+]]:_(s32), [[UV3:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[C]](s8)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[ANYEXT]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r6 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[UV2]](s32)
  ; CHECK-NEXT:   $r9 = COPY [[UV3]](s32)
  ; CHECK-NEXT:   JAL @test_stack_slots_i8, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV4:%[0-9]+]]:_(s32), [[UV5:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[UV6:%[0-9]+]]:_(s32), [[UV7:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[SEXT:%[0-9]+]]:_(s32) = G_SEXT [[C]](s8)
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C2]](s32)
  ; CHECK-NEXT:   G_STORE [[SEXT]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r6 = COPY [[UV4]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[UV5]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[UV6]](s32)
  ; CHECK-NEXT:   $r9 = COPY [[UV7]](s32)
  ; CHECK-NEXT:   JAL @test_stack_slots_i8, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV8:%[0-9]+]]:_(s32), [[UV9:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[UV10:%[0-9]+]]:_(s32), [[UV11:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[C]](s8)
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY2]], [[C3]](s32)
  ; CHECK-NEXT:   G_STORE [[ZEXT]](s32), [[PTR_ADD2]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r6 = COPY [[UV8]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[UV9]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[UV10]](s32)
  ; CHECK-NEXT:   $r9 = COPY [[UV11]](s32)
  ; CHECK-NEXT:   JAL @test_stack_slots_i8, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_i8(i64 undef, i64 undef, i8 0)
  call void @test_stack_slots_i8(i64 undef, i64 undef, i8 signext 0)
  call void @test_stack_slots_i8(i64 undef, i64 undef, i8 zeroext 0)
  ret void
}


declare void @test_stack_slots_i16(i64 %r6r7, i64 %r8r9, i16)
define void @test_call_stack_i16() {
  ; CHECK-LABEL: name: test_call_stack_i16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s64) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[UV2:%[0-9]+]]:_(s32), [[UV3:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[C]](s16)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[ANYEXT]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r6 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[UV2]](s32)
  ; CHECK-NEXT:   $r9 = COPY [[UV3]](s32)
  ; CHECK-NEXT:   JAL @test_stack_slots_i16, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV4:%[0-9]+]]:_(s32), [[UV5:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[UV6:%[0-9]+]]:_(s32), [[UV7:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[SEXT:%[0-9]+]]:_(s32) = G_SEXT [[C]](s16)
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C2]](s32)
  ; CHECK-NEXT:   G_STORE [[SEXT]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r6 = COPY [[UV4]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[UV5]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[UV6]](s32)
  ; CHECK-NEXT:   $r9 = COPY [[UV7]](s32)
  ; CHECK-NEXT:   JAL @test_stack_slots_i16, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV8:%[0-9]+]]:_(s32), [[UV9:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[UV10:%[0-9]+]]:_(s32), [[UV11:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[C]](s16)
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY2]], [[C3]](s32)
  ; CHECK-NEXT:   G_STORE [[ZEXT]](s32), [[PTR_ADD2]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r6 = COPY [[UV8]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[UV9]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[UV10]](s32)
  ; CHECK-NEXT:   $r9 = COPY [[UV11]](s32)
  ; CHECK-NEXT:   JAL @test_stack_slots_i16, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_i16(i64 undef, i64 undef, i16 0)
  call void @test_stack_slots_i16(i64 undef, i64 undef, i16 signext 0)
  call void @test_stack_slots_i16(i64 undef, i64 undef, i16 zeroext 0)
  ret void
}

declare void @test_stack_slots_i32(i64 %r6r7, i64 %r8r9, i32)
define void @test_call_stack_i32() {
  ; CHECK-LABEL: name: test_call_stack_i32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s64) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[UV2:%[0-9]+]]:_(s32), [[UV3:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[C]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r6 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[UV2]](s32)
  ; CHECK-NEXT:   $r9 = COPY [[UV3]](s32)
  ; CHECK-NEXT:   JAL @test_stack_slots_i32, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_i32(i64 undef, i64 undef, i32 0)
  ret void
}

declare void @test_stack_slots_i64(i64 %r6r7, i64 %r8r9, i64)
define void @test_call_stack_i64() {
  ; CHECK-LABEL: name: test_call_stack_i64
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s64) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[UV2:%[0-9]+]]:_(s32), [[UV3:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[UV4:%[0-9]+]]:_(s32), [[UV5:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C]](s64)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -8
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[UV4]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 8)
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C2]](s32)
  ; CHECK-NEXT:   G_STORE [[UV5]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r6 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[UV2]](s32)
  ; CHECK-NEXT:   $r9 = COPY [[UV3]](s32)
  ; CHECK-NEXT:   JAL @test_stack_slots_i64, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_i64(i64 undef, i64 undef, i64 0)
  ret void
}

declare void @test_stack_slots_ptr(i32* %ptr1, i32* %ptr2, i32* %ptr3,
                                   i32* %ptr4, i32* %ptr5, i32* %ptr6,
                                   i32* %ptr_stack)
define void @test_call_stack_ptr() {
  ; CHECK-LABEL: name: test_call_stack_ptr
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[C]](p0), [[PTR_ADD]](p0) :: (store (p0) into stack - 4, align 4, basealign 32)
  ; CHECK-NEXT:   $p0 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p1 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p2 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p3 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p4 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p5 = COPY [[C]](p0)
  ; CHECK-NEXT:   JAL @test_stack_slots_ptr, csr_aie1, implicit-def $lr, implicit $p0, implicit $p1, implicit $p2, implicit $p3, implicit $p4, implicit $p5
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_ptr(i32* null, i32* null, i32* null,
                                  i32* null, i32* null, i32* null,
                                  i32* null)
  ret void
}

declare void @take_i1(i1)
define void @test_abi_exts_call_i1(i1* %addr) {
  ; CHECK-LABEL: name: test_abi_exts_call_i1
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s1) = G_LOAD [[COPY]](p0) :: (load (s1) from %ir.addr)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[LOAD]](s1)
  ; CHECK-NEXT:   $r6 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   JAL @take_i1, csr_aie1, implicit-def $lr, implicit $r6
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[SEXT:%[0-9]+]]:_(s32) = G_SEXT [[LOAD]](s1)
  ; CHECK-NEXT:   $r6 = COPY [[SEXT]](s32)
  ; CHECK-NEXT:   JAL @take_i1, csr_aie1, implicit-def $lr, implicit $r6
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[LOAD]](s1)
  ; CHECK-NEXT:   $r6 = COPY [[ZEXT]](s32)
  ; CHECK-NEXT:   JAL @take_i1, csr_aie1, implicit-def $lr, implicit $r6
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  %val = load i1, i1* %addr
  call void @take_i1(i1 %val)
  call void @take_i1(i1 signext %val)
  call void @take_i1(i1 zeroext %val)
  ret void
}

declare void @test_stack_slots_i1(i64 %r6r7, i64 %r8r9, i1)
define void @test_call_stack_i1() {
  ; CHECK-LABEL: name: test_call_stack_i1
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s64) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s1) = G_CONSTANT i1 false
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[UV2:%[0-9]+]]:_(s32), [[UV3:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[DEF]](s64)
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[C]](s1)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[ZEXT]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r6 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[UV2]](s32)
  ; CHECK-NEXT:   $r9 = COPY [[UV3]](s32)
  ; CHECK-NEXT:   JAL @test_stack_slots_i1, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_i1(i64 undef, i64 undef, i1 zeroext false)
  ret void
}

; %stack crosses the Stack-Reg boundary (for AIE1), it should go on the stack.
; %r9 can be passed "out-of-order" in the remaining r9 GPR.
declare void @cross_stack_reg_boundary(i32 %r6, i32 %r7, i32 %r8, i64 %stack, i32 %r9)
define void @test_cross_stack_reg_boundary() {
  ; CHECK-LABEL: name: test_cross_stack_reg_boundary
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 2
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s64) = G_CONSTANT i64 4
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 5
  ; CHECK-NEXT:   ADJCALLSTACKUP 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C3]](s64)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C5:%[0-9]+]]:_(s32) = G_CONSTANT i32 -8
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C5]](s32)
  ; CHECK-NEXT:   G_STORE [[UV]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 8)
  ; CHECK-NEXT:   [[C6:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C6]](s32)
  ; CHECK-NEXT:   G_STORE [[UV1]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C1]](s32)
  ; CHECK-NEXT:   $r8 = COPY [[C2]](s32)
  ; CHECK-NEXT:   $r9 = COPY [[C4]](s32)
  ; CHECK-NEXT:   JAL @cross_stack_reg_boundary, csr_aie1, implicit-def $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @cross_stack_reg_boundary(i32 1, i32 2, i32 3, i64 4, i32 5)
  ret void
}

; r0 and r1 are reserved by the RetCC
; (AIE1) Parameters are still passed from r6
declare i64 @retcc_reserved_GPRs(i32 %r6)
define void @test_retcc_reserved_GPRs() {
  ; CHECK-LABEL: name: test_retcc_reserved_GPRs
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   JAL @retcc_reserved_GPRs, csr_aie1, implicit-def $lr, implicit $r6, implicit-def $r0, implicit-def $r1
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[MV:%[0-9]+]]:_(s64) = G_MERGE_VALUES [[COPY]](s32), [[COPY1]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call i64 @retcc_reserved_GPRs(i32 1)
  ret void
}

; p0 is reserved by the RetCC
; Parameters are now passed from p1
declare i32* @retcc_reserved_PTRs(i32* %p1)
define void @test_retcc_reserved_PTRs() {
  ; CHECK-LABEL: name: test_retcc_reserved_PTRs
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $p1 = COPY [[C]](p0)
  ; CHECK-NEXT:   JAL @retcc_reserved_PTRs, csr_aie1, implicit-def $lr, implicit $p1, implicit-def $p0
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call i32* @retcc_reserved_PTRs(i32* null)
  ret void
}
