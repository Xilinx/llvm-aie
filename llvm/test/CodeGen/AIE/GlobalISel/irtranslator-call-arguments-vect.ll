; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

; 128-bit vector types

declare void @callee_v4int32(<4 x i32>, <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32>,
                             <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32>,
                             <4 x i32>)
define void @call_v4int32() {
  ; CHECK-LABEL: name: call_v4int32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<4 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -16
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<4 x s32>), [[PTR_ADD]](p0) :: (store (<4 x s32>) into stack - 16, basealign 32)
  ; CHECK-NEXT:   $vl0 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vl1 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vl2 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vl3 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vl4 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vl5 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vl6 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vl7 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vh0 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vh1 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vh2 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vh3 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vh4 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vh5 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vh6 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   $vh7 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   JAL @callee_v4int32, csr_aie1, implicit-def $lr, implicit $vl0, implicit $vl1, implicit $vl2, implicit $vl3, implicit $vl4, implicit $vl5, implicit $vl6, implicit $vl7, implicit $vh0, implicit $vh1, implicit $vh2, implicit $vh3, implicit $vh4, implicit $vh5, implicit $vh6, implicit $vh7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v4int32(<4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer,
                            <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer, <4 x i32> zeroinitializer,
                            <4 x i32> zeroinitializer)
  ret void
}

declare void @callee_v8int16(<8 x i16>, <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16>,
                             <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16>,
                             <8 x i16>)
define void @call_v8int16() {
  ; CHECK-LABEL: name: call_v8int16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<8 x s16>) = G_BUILD_VECTOR [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16)
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -16
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<8 x s16>), [[PTR_ADD]](p0) :: (store (<8 x s16>) into stack - 16, basealign 32)
  ; CHECK-NEXT:   $vl0 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vl1 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vl2 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vl3 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vl4 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vl5 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vl6 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vl7 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vh0 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vh1 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vh2 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vh3 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vh4 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vh5 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vh6 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   $vh7 = COPY [[BUILD_VECTOR]](<8 x s16>)
  ; CHECK-NEXT:   JAL @callee_v8int16, csr_aie1, implicit-def $lr, implicit $vl0, implicit $vl1, implicit $vl2, implicit $vl3, implicit $vl4, implicit $vl5, implicit $vl6, implicit $vl7, implicit $vh0, implicit $vh1, implicit $vh2, implicit $vh3, implicit $vh4, implicit $vh5, implicit $vh6, implicit $vh7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v8int16(<8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer,
                            <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer, <8 x i16> zeroinitializer,
                            <8 x i16> zeroinitializer)
  ret void
}

declare void @callee_v16int8(<16 x i8>, <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8>,
                             <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8>,
                             <16 x i8>)
define void @call_v16int8() {
  ; CHECK-LABEL: name: call_v16int8
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s8) = G_CONSTANT i8 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<16 x s8>) = G_BUILD_VECTOR [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8)
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -16
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<16 x s8>), [[PTR_ADD]](p0) :: (store (<16 x s8>) into stack - 16, basealign 32)
  ; CHECK-NEXT:   $vl0 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vl1 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vl2 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vl3 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vl4 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vl5 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vl6 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vl7 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vh0 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vh1 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vh2 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vh3 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vh4 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vh5 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vh6 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   $vh7 = COPY [[BUILD_VECTOR]](<16 x s8>)
  ; CHECK-NEXT:   JAL @callee_v16int8, csr_aie1, implicit-def $lr, implicit $vl0, implicit $vl1, implicit $vl2, implicit $vl3, implicit $vl4, implicit $vl5, implicit $vl6, implicit $vl7, implicit $vh0, implicit $vh1, implicit $vh2, implicit $vh3, implicit $vh4, implicit $vh5, implicit $vh6, implicit $vh7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v16int8(<16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer,
                            <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer,
                            <16 x i8> zeroinitializer)
  ret void
}

; 256-bit vector types

declare void @callee_v4int64(<4 x i64>, <4 x i64>, <4 x i64>, <4 x i64>, <4 x i64>, <4 x i64>, <4 x i64>, <4 x i64>,
                             <4 x i64>)
define void @call_v4int64() {
  ; CHECK-LABEL: name: call_v4int64
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<4 x s64>) = G_BUILD_VECTOR [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64)
  ; CHECK-NEXT:   ADJCALLSTACKUP 32, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -32
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<4 x s64>), [[PTR_ADD]](p0) :: (store (<4 x s64>) into stack - 32)
  ; CHECK-NEXT:   $wr0 = COPY [[BUILD_VECTOR]](<4 x s64>)
  ; CHECK-NEXT:   $wr1 = COPY [[BUILD_VECTOR]](<4 x s64>)
  ; CHECK-NEXT:   $wr2 = COPY [[BUILD_VECTOR]](<4 x s64>)
  ; CHECK-NEXT:   $wr3 = COPY [[BUILD_VECTOR]](<4 x s64>)
  ; CHECK-NEXT:   $wc0 = COPY [[BUILD_VECTOR]](<4 x s64>)
  ; CHECK-NEXT:   $wc1 = COPY [[BUILD_VECTOR]](<4 x s64>)
  ; CHECK-NEXT:   $wd0 = COPY [[BUILD_VECTOR]](<4 x s64>)
  ; CHECK-NEXT:   $wd1 = COPY [[BUILD_VECTOR]](<4 x s64>)
  ; CHECK-NEXT:   JAL @callee_v4int64, csr_aie1, implicit-def $lr, implicit $wr0, implicit $wr1, implicit $wr2, implicit $wr3, implicit $wc0, implicit $wc1, implicit $wd0, implicit $wd1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 32, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v4int64(<4 x i64> zeroinitializer, <4 x i64> zeroinitializer, <4 x i64> zeroinitializer, <4 x i64> zeroinitializer, <4 x i64> zeroinitializer, <4 x i64> zeroinitializer, <4 x i64> zeroinitializer, <4 x i64> zeroinitializer,
                            <4 x i64> zeroinitializer)
  ret void
}

declare void @callee_v8int32(<8 x i32>, <8 x i32>, <8 x i32>, <8 x i32>, <8 x i32>, <8 x i32>, <8 x i32>, <8 x i32>,
                             <8 x i32>)
define void @call_v8int32() {
  ; CHECK-LABEL: name: call_v8int32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<8 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKUP 32, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -32
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<8 x s32>), [[PTR_ADD]](p0) :: (store (<8 x s32>) into stack - 32)
  ; CHECK-NEXT:   $wr0 = COPY [[BUILD_VECTOR]](<8 x s32>)
  ; CHECK-NEXT:   $wr1 = COPY [[BUILD_VECTOR]](<8 x s32>)
  ; CHECK-NEXT:   $wr2 = COPY [[BUILD_VECTOR]](<8 x s32>)
  ; CHECK-NEXT:   $wr3 = COPY [[BUILD_VECTOR]](<8 x s32>)
  ; CHECK-NEXT:   $wc0 = COPY [[BUILD_VECTOR]](<8 x s32>)
  ; CHECK-NEXT:   $wc1 = COPY [[BUILD_VECTOR]](<8 x s32>)
  ; CHECK-NEXT:   $wd0 = COPY [[BUILD_VECTOR]](<8 x s32>)
  ; CHECK-NEXT:   $wd1 = COPY [[BUILD_VECTOR]](<8 x s32>)
  ; CHECK-NEXT:   JAL @callee_v8int32, csr_aie1, implicit-def $lr, implicit $wr0, implicit $wr1, implicit $wr2, implicit $wr3, implicit $wc0, implicit $wc1, implicit $wd0, implicit $wd1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 32, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v8int32(<8 x i32> zeroinitializer, <8 x i32> zeroinitializer, <8 x i32> zeroinitializer, <8 x i32> zeroinitializer, <8 x i32> zeroinitializer, <8 x i32> zeroinitializer, <8 x i32> zeroinitializer, <8 x i32> zeroinitializer,
                            <8 x i32> zeroinitializer)
  ret void
}

declare void @callee_v16int16(<16 x i16>, <16 x i16>, <16 x i16>, <16 x i16>, <16 x i16>, <16 x i16>, <16 x i16>, <16 x i16>,
                              <16 x i16>)
define void @call_v16int16() {
  ; CHECK-LABEL: name: call_v16int16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<16 x s16>) = G_BUILD_VECTOR [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16)
  ; CHECK-NEXT:   ADJCALLSTACKUP 32, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -32
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<16 x s16>), [[PTR_ADD]](p0) :: (store (<16 x s16>) into stack - 32)
  ; CHECK-NEXT:   $wr0 = COPY [[BUILD_VECTOR]](<16 x s16>)
  ; CHECK-NEXT:   $wr1 = COPY [[BUILD_VECTOR]](<16 x s16>)
  ; CHECK-NEXT:   $wr2 = COPY [[BUILD_VECTOR]](<16 x s16>)
  ; CHECK-NEXT:   $wr3 = COPY [[BUILD_VECTOR]](<16 x s16>)
  ; CHECK-NEXT:   $wc0 = COPY [[BUILD_VECTOR]](<16 x s16>)
  ; CHECK-NEXT:   $wc1 = COPY [[BUILD_VECTOR]](<16 x s16>)
  ; CHECK-NEXT:   $wd0 = COPY [[BUILD_VECTOR]](<16 x s16>)
  ; CHECK-NEXT:   $wd1 = COPY [[BUILD_VECTOR]](<16 x s16>)
  ; CHECK-NEXT:   JAL @callee_v16int16, csr_aie1, implicit-def $lr, implicit $wr0, implicit $wr1, implicit $wr2, implicit $wr3, implicit $wc0, implicit $wc1, implicit $wd0, implicit $wd1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 32, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v16int16(<16 x i16> zeroinitializer, <16 x i16> zeroinitializer, <16 x i16> zeroinitializer, <16 x i16> zeroinitializer, <16 x i16> zeroinitializer, <16 x i16> zeroinitializer, <16 x i16> zeroinitializer, <16 x i16> zeroinitializer,
                             <16 x i16> zeroinitializer)
  ret void
}

declare void @callee_v32int8(<32 x i8>, <32 x i8>, <32 x i8>, <32 x i8>, <32 x i8>, <32 x i8>, <32 x i8>, <32 x i8>,
                             <32 x i8>)
define void @call_v32int8() {
  ; CHECK-LABEL: name: call_v32int8
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s8) = G_CONSTANT i8 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<32 x s8>) = G_BUILD_VECTOR [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8)
  ; CHECK-NEXT:   ADJCALLSTACKUP 32, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -32
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<32 x s8>), [[PTR_ADD]](p0) :: (store (<32 x s8>) into stack - 32)
  ; CHECK-NEXT:   $wr0 = COPY [[BUILD_VECTOR]](<32 x s8>)
  ; CHECK-NEXT:   $wr1 = COPY [[BUILD_VECTOR]](<32 x s8>)
  ; CHECK-NEXT:   $wr2 = COPY [[BUILD_VECTOR]](<32 x s8>)
  ; CHECK-NEXT:   $wr3 = COPY [[BUILD_VECTOR]](<32 x s8>)
  ; CHECK-NEXT:   $wc0 = COPY [[BUILD_VECTOR]](<32 x s8>)
  ; CHECK-NEXT:   $wc1 = COPY [[BUILD_VECTOR]](<32 x s8>)
  ; CHECK-NEXT:   $wd0 = COPY [[BUILD_VECTOR]](<32 x s8>)
  ; CHECK-NEXT:   $wd1 = COPY [[BUILD_VECTOR]](<32 x s8>)
  ; CHECK-NEXT:   JAL @callee_v32int8, csr_aie1, implicit-def $lr, implicit $wr0, implicit $wr1, implicit $wr2, implicit $wr3, implicit $wc0, implicit $wc1, implicit $wd0, implicit $wd1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 32, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v32int8(<32 x i8> zeroinitializer, <32 x i8> zeroinitializer, <32 x i8> zeroinitializer, <32 x i8> zeroinitializer, <32 x i8> zeroinitializer, <32 x i8> zeroinitializer, <32 x i8> zeroinitializer, <32 x i8> zeroinitializer,
                            <32 x i8> zeroinitializer)
  ret void
}

; 512-bit vector types

declare void @callee_v8int64(<8 x i64>, <8 x i64>, <8 x i64>, <8 x i64>,
                             <8 x i64>)
define void @call_v8int64() {
  ; CHECK-LABEL: name: call_v8int64
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<8 x s64>) = G_BUILD_VECTOR [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64)
  ; CHECK-NEXT:   ADJCALLSTACKUP 64, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -64
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<8 x s64>), [[PTR_ADD]](p0) :: (store (<8 x s64>) into stack - 64, align 32)
  ; CHECK-NEXT:   $xa = COPY [[BUILD_VECTOR]](<8 x s64>)
  ; CHECK-NEXT:   $xb = COPY [[BUILD_VECTOR]](<8 x s64>)
  ; CHECK-NEXT:   $xc = COPY [[BUILD_VECTOR]](<8 x s64>)
  ; CHECK-NEXT:   $xd = COPY [[BUILD_VECTOR]](<8 x s64>)
  ; CHECK-NEXT:   JAL @callee_v8int64, csr_aie1, implicit-def $lr, implicit $xa, implicit $xb, implicit $xc, implicit $xd
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 64, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v8int64(<8 x i64> zeroinitializer, <8 x i64> zeroinitializer, <8 x i64> zeroinitializer, <8 x i64> zeroinitializer,
                            <8 x i64> zeroinitializer)
  ret void
}

declare void @callee_v16int32(<16 x i32>, <16 x i32>, <16 x i32>, <16 x i32>,
                              <16 x i32>)
define void @call_v16int32() {
  ; CHECK-LABEL: name: call_v16int32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<16 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKUP 64, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -64
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<16 x s32>), [[PTR_ADD]](p0) :: (store (<16 x s32>) into stack - 64, align 32)
  ; CHECK-NEXT:   $xa = COPY [[BUILD_VECTOR]](<16 x s32>)
  ; CHECK-NEXT:   $xb = COPY [[BUILD_VECTOR]](<16 x s32>)
  ; CHECK-NEXT:   $xc = COPY [[BUILD_VECTOR]](<16 x s32>)
  ; CHECK-NEXT:   $xd = COPY [[BUILD_VECTOR]](<16 x s32>)
  ; CHECK-NEXT:   JAL @callee_v16int32, csr_aie1, implicit-def $lr, implicit $xa, implicit $xb, implicit $xc, implicit $xd
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 64, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v16int32(<16 x i32> zeroinitializer, <16 x i32> zeroinitializer, <16 x i32> zeroinitializer, <16 x i32> zeroinitializer,
                             <16 x i32> zeroinitializer)
  ret void
}

declare void @callee_v32int16(<32 x i16>, <32 x i16>, <32 x i16>, <32 x i16>,
                              <32 x i16>)
define void @call_v32int16() {
  ; CHECK-LABEL: name: call_v32int16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<32 x s16>) = G_BUILD_VECTOR [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16)
  ; CHECK-NEXT:   ADJCALLSTACKUP 64, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -64
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<32 x s16>), [[PTR_ADD]](p0) :: (store (<32 x s16>) into stack - 64, align 32)
  ; CHECK-NEXT:   $xa = COPY [[BUILD_VECTOR]](<32 x s16>)
  ; CHECK-NEXT:   $xb = COPY [[BUILD_VECTOR]](<32 x s16>)
  ; CHECK-NEXT:   $xc = COPY [[BUILD_VECTOR]](<32 x s16>)
  ; CHECK-NEXT:   $xd = COPY [[BUILD_VECTOR]](<32 x s16>)
  ; CHECK-NEXT:   JAL @callee_v32int16, csr_aie1, implicit-def $lr, implicit $xa, implicit $xb, implicit $xc, implicit $xd
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 64, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v32int16(<32 x i16> zeroinitializer, <32 x i16> zeroinitializer, <32 x i16> zeroinitializer, <32 x i16> zeroinitializer,
                             <32 x i16> zeroinitializer)
  ret void
}

declare void @callee_v64int8(<64 x i8>, <64 x i8>, <64 x i8>, <64 x i8>,
                             <64 x i8>)
define void @call_v64int8() {
  ; CHECK-LABEL: name: call_v64int8
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s8) = G_CONSTANT i8 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<64 x s8>) = G_BUILD_VECTOR [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8)
  ; CHECK-NEXT:   ADJCALLSTACKUP 64, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -64
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<64 x s8>), [[PTR_ADD]](p0) :: (store (<64 x s8>) into stack - 64, align 32)
  ; CHECK-NEXT:   $xa = COPY [[BUILD_VECTOR]](<64 x s8>)
  ; CHECK-NEXT:   $xb = COPY [[BUILD_VECTOR]](<64 x s8>)
  ; CHECK-NEXT:   $xc = COPY [[BUILD_VECTOR]](<64 x s8>)
  ; CHECK-NEXT:   $xd = COPY [[BUILD_VECTOR]](<64 x s8>)
  ; CHECK-NEXT:   JAL @callee_v64int8, csr_aie1, implicit-def $lr, implicit $xa, implicit $xb, implicit $xc, implicit $xd
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 64, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v64int8(<64 x i8> zeroinitializer, <64 x i8> zeroinitializer, <64 x i8> zeroinitializer, <64 x i8> zeroinitializer,
                            <64 x i8> zeroinitializer)
  ret void
}

; 1024-bit vector types

declare void @callee_v32int32(<32 x i32>, <32 x i32>)
define void @call_v32int32() {
  ; CHECK-LABEL: name: call_v32int32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<32 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKUP 128, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -128
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<32 x s32>), [[PTR_ADD]](p0) :: (store (<32 x s32>) into stack - 128, align 32)
  ; CHECK-NEXT:   $ya = COPY [[BUILD_VECTOR]](<32 x s32>)
  ; CHECK-NEXT:   JAL @callee_v32int32, csr_aie1, implicit-def $lr, implicit $ya
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 128, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v32int32(<32 x i32> zeroinitializer, <32 x i32> zeroinitializer)
  ret void
}

declare void @callee_v64int16(<64 x i16>, <64 x i16>)
define void @call_v64int16() {
  ; CHECK-LABEL: name: call_v64int16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<64 x s16>) = G_BUILD_VECTOR [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16), [[C]](s16)
  ; CHECK-NEXT:   ADJCALLSTACKUP 128, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -128
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<64 x s16>), [[PTR_ADD]](p0) :: (store (<64 x s16>) into stack - 128, align 32)
  ; CHECK-NEXT:   $ya = COPY [[BUILD_VECTOR]](<64 x s16>)
  ; CHECK-NEXT:   JAL @callee_v64int16, csr_aie1, implicit-def $lr, implicit $ya
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 128, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v64int16(<64 x i16> zeroinitializer, <64 x i16> zeroinitializer)
  ret void
}

declare void @callee_v128int8(<128 x i8>, <128 x i8>)
define void @call_v128int8() {
  ; CHECK-LABEL: name: call_v128int8
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s8) = G_CONSTANT i8 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<128 x s8>) = G_BUILD_VECTOR [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8)
  ; CHECK-NEXT:   ADJCALLSTACKUP 128, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -128
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<128 x s8>), [[PTR_ADD]](p0) :: (store (<128 x s8>) into stack - 128, align 32)
  ; CHECK-NEXT:   $ya = COPY [[BUILD_VECTOR]](<128 x s8>)
  ; CHECK-NEXT:   JAL @callee_v128int8, csr_aie1, implicit-def $lr, implicit $ya
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 128, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v128int8(<128 x i8> zeroinitializer, <128 x i8> zeroinitializer)
  ret void
}

; The YA reg is used by the result type, and it overlaps with vlX and vhX regs.
; Therefore, %a1 cannot be passed in vl0
declare <32 x i32> @retcc_reserved_vl(<4 x i32> %a1)
define void @call_retcc_reserved_vl() {
  ; CHECK-LABEL: name: call_retcc_reserved_vl
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<4 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $vl4 = COPY [[BUILD_VECTOR]](<4 x s32>)
  ; CHECK-NEXT:   JAL @retcc_reserved_vl, csr_aie1, implicit-def $lr, implicit $vl4, implicit-def $ya
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<32 x s32>) = COPY $ya
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call <32 x i32> @retcc_reserved_vl(<4 x i32> zeroinitializer)
  ret void
}

; The YA reg is used by the result type, and it overlaps with wrX regs.
; Therefore, %a1 cannot be passed in WR0
declare <32 x i32> @retcc_reserved_wr(<8 x i32> %a1)
define void @call_retcc_reserved_wr() {
  ; CHECK-LABEL: name: call_retcc_reserved_wr
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<8 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $wc0 = COPY [[BUILD_VECTOR]](<8 x s32>)
  ; CHECK-NEXT:   JAL @retcc_reserved_wr, csr_aie1, implicit-def $lr, implicit $wc0, implicit-def $ya
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<32 x s32>) = COPY $ya
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call <32 x i32> @retcc_reserved_wr(<8 x i32> zeroinitializer)
  ret void
}

; The YA reg is used by the result type, and it overlaps with XA and XB regs.
; Therefore, %a1 cannot be passed in XA or XB.
declare <32 x i32> @retcc_reserved_xa_xb(<16 x i32> %a1)
define void @call_retcc_reserved_xa_xb() {
  ; CHECK-LABEL: name: call_retcc_reserved_xa_xb
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<16 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $xc = COPY [[BUILD_VECTOR]](<16 x s32>)
  ; CHECK-NEXT:   JAL @retcc_reserved_xa_xb, csr_aie1, implicit-def $lr, implicit $xc, implicit-def $ya
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<32 x s32>) = COPY $ya
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call <32 x i32> @retcc_reserved_xa_xb(<16 x i32> zeroinitializer)
  ret void
}

; The YA reg is used by the result type, and it overlaps with the YD reg
; Therefore, %a1 is passed on the stack.
declare <32 x i32> @retcc_reserved_ya(<32 x i32> %a1)
define void @call_retcc_reserved_ya() {
  ; CHECK-LABEL: name: call_retcc_reserved_ya
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<32 x s32>) = G_BUILD_VECTOR [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32), [[C]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKUP 128, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 -128
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s20)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<32 x s32>), [[PTR_ADD]](p0) :: (store (<32 x s32>) into stack - 128, align 32)
  ; CHECK-NEXT:   JAL @retcc_reserved_ya, csr_aie1, implicit-def $lr, implicit-def $ya
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(<32 x s32>) = COPY $ya
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 128, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call <32 x i32> @retcc_reserved_ya(<32 x i32> zeroinitializer)
  ret void
}
