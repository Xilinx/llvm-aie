; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 -verify-machineinstrs < %s \
; RUN:   | FileCheck %s

%struct.S3IP = type { i32, i32, i32, i32* }

; Pass structs containing integers and pointers
define void @call_pass_2S3IP() {
; CHECK-LABEL: call_pass_2S3IP:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.u20 r12, #6
; CHECK-NEXT:    st.spil lr, [sp, #-32]
; CHECK-NEXT:    st.spil r12, [sp, #-4]
; CHECK-NEXT:    mov.u20 r12, #7
; CHECK-NEXT:    st.spil r12, [sp, #-8]
; CHECK-NEXT:    mov r12, sp
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    mov p1, r12
; CHECK-NEXT:    padda [p0], #-28
; CHECK-NEXT:    padda [p1], #-24
; CHECK-NEXT:    mov.u20 r6, #1
; CHECK-NEXT:    mov.u20 r7, #2
; CHECK-NEXT:    mov.u20 r8, #3
; CHECK-NEXT:    mov.u20 r9, #5
; CHECK-NEXT:    jal pass_2S3IP
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %loc1 = alloca i32, align 4
  %loc2 = alloca i32, align 4
  %.fca.3.insert9 = insertvalue %struct.S3IP { i32 1, i32 2, i32 3, i32* undef }, i32* %loc1, 3
  %.fca.3.insert = insertvalue %struct.S3IP { i32 5, i32 6, i32 7, i32* undef }, i32* %loc2, 3
  call void @pass_2S3IP(%struct.S3IP %.fca.3.insert9, %struct.S3IP %.fca.3.insert)
  ret void
}

; Check that structs passed by value are used properly:
; extractvalue %struct.S3IP %a.coerce, 2 should be in $r8
; extractvalue %struct.S3IP %a.coerce, 3 should be in $p0
; extractvalue %struct.S3IP %b.coerce, 2 should be in [sp, #-8]
; extractvalue %struct.S3IP %b.coerce, 3 should be in $p1
define void @use_2S3IP(%struct.S3IP %a.coerce, %struct.S3IP %b.coerce) {
; CHECK-LABEL: use_2S3IP:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    lda.spil r13, [sp, #-8]
; CHECK-NEXT:    st r8, [p0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    st r13, [p1]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %a.coerce.fca.2.extract = extractvalue %struct.S3IP %a.coerce, 2
  %a.coerce.fca.3.extract = extractvalue %struct.S3IP %a.coerce, 3
  %b.coerce.fca.2.extract = extractvalue %struct.S3IP %b.coerce, 2
  %b.coerce.fca.3.extract = extractvalue %struct.S3IP %b.coerce, 3
  store i32 %a.coerce.fca.2.extract, i32* %a.coerce.fca.3.extract, align 4
  store i32 %b.coerce.fca.2.extract, i32* %b.coerce.fca.3.extract, align 4
  ret void
}

declare void @pass_2S3IP(%struct.S3IP, %struct.S3IP)
