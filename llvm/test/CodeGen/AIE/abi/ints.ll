; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 -verify-machineinstrs < %s \
; RUN:   | FileCheck %s

declare void @pass_smallints(i8 signext %a, i8 signext %b, i16 signext %c, i32 %d, i8 signext %e, i8 signext %f, i16 signext %g, i32 %h)

; Pass small integers, they should still occupy a full register
; Integers on the stack also occupy a full 32-bits slot
define void @call_pass_smallints(i32 %v) {
; CHECK-LABEL: call_pass_smallints:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.u20 r12, #5
; CHECK-NEXT:    st.spil lr, [sp, #-32]
; CHECK-NEXT:    st.spil r12, [sp, #-4]
; CHECK-NEXT:    mov.u20 r12, #6
; CHECK-NEXT:    st.spil r12, [sp, #-8]
; CHECK-NEXT:    mov.u20 r12, #7
; CHECK-NEXT:    st.spil r12, [sp, #-12]
; CHECK-NEXT:    mov.u20 r12, #8
; CHECK-NEXT:    st.spil r12, [sp, #-16]
; CHECK-NEXT:    add r12, r6, #1
; CHECK-NEXT:    se.8 r6, r12
; CHECK-NEXT:    mov.u20 r7, #2
; CHECK-NEXT:    mov.u20 r8, #3
; CHECK-NEXT:    mov.u20 r9, #4
; CHECK-NEXT:    jal pass_smallints
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %v.conv = trunc i32 %v to i8
  %v.add = add i8 %v.conv, 1
  call void @pass_smallints(i8 %v.add, i8 2, i16 3, i32 4, i8 5, i8 6, i16 7, i32 8)
  ret void
}

define signext i8 @use_smallints(i8 signext %a, i8 signext %b, i16 signext %c, i32 %d, i8 signext %e, i8 signext %f, i16 signext %g, i32 %h) {
; CHECK-LABEL: use_smallints:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    lda.spil r12, [sp, #-8]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r12, r7, r12
; CHECK-NEXT:    se.8 r0, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %res = add i8 %b, %f
  ret i8 %res
}

declare void @pass_largeints(i32 %a, i64 %b, i64 %c, i64 %d, i32 %e, i32 %f)

; Check what happens when passing large integers, in particular when one does
; not fit entirely in the remaining registers, but one of the following smaller
; integers does.
; The 64-bits numbers correspond to:
; 2+((int64_t)20<<32) = 85899345922
; 3+((int64_t)30<<32) = 128849018883
; 4+((int64_t)40<<32) = 171798691844
define void @call_pass_largeints() {
; CHECK-LABEL: call_pass_largeints:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.u20 r12, #3
; CHECK-NEXT:    st.spil lr, [sp, #-32]
; CHECK-NEXT:    st.spil r12, [sp, #-8]
; CHECK-NEXT:    mov.u20 r12, #30
; CHECK-NEXT:    st.spil r12, [sp, #-4]
; CHECK-NEXT:    mov.u20 r12, #4
; CHECK-NEXT:    st.spil r12, [sp, #-16]
; CHECK-NEXT:    mov.u20 r12, #40
; CHECK-NEXT:    st.spil r12, [sp, #-12]
; CHECK-NEXT:    mov.u20 r12, #6
; CHECK-NEXT:    mov.u20 r6, #1
; CHECK-NEXT:    mov.u20 r7, #2
; CHECK-NEXT:    mov.u20 r8, #20
; CHECK-NEXT:    mov.u20 r9, #5
; CHECK-NEXT:    st.spil r12, [sp, #-20]
; CHECK-NEXT:    jal pass_largeints
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  call void @pass_largeints(i32 1, i64 85899345922, i64 128849018883, i64 171798691844, i32 5, i32 6)
  ret void
}

define i64 @use_largeints(i32 %a, i64 %b, i64 %c, i64 %d, i32 %e, i32 %f) {
; CHECK-LABEL: use_largeints:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 r12, #31
; CHECK-NEXT:    mov.u20 r13, #0
; CHECK-NEXT:    sub r12, r13, r12
; CHECK-NEXT:    mov r13, sp
; CHECK-NEXT:    mov p0, r13
; CHECK-NEXT:    padda [p0], #-12
; CHECK-NEXT:    mov r14, sp
; CHECK-NEXT:    lda r13, [p0]
; CHECK-NEXT:    mov p0, r14
; CHECK-NEXT:    padda [p0], #-4
; CHECK-NEXT:    lda.spil r5, [sp, #-8]
; CHECK-NEXT:    lda r14, [p0]
; CHECK-NEXT:    ashl r12, r9, r12
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r13, r14, r13
; CHECK-NEXT:    lda.spil r14, [sp, #-16]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r14, r5, r14
; CHECK-NEXT:    ltu r5, r14, r5
; CHECK-NEXT:    add r13, r13, r5
; CHECK-NEXT:    add r0, r14, r9
; CHECK-NEXT:    add r12, r13, r12
; CHECK-NEXT:    ltu r13, r0, r14
; CHECK-NEXT:    add r1, r12, r13
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %res = add i64 %c, %d
  %tmp = sext i32 %e to i64
  %res2 = add i64 %res, %tmp
  ret i64 %res2
}
