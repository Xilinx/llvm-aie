; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 -verify-machineinstrs < %s \
; RUN:   | FileCheck %s

%struct.S2I = type { i32, i32 }
%struct.S4xI = type { [4 x i32] }
%struct.S4I = type { i32, i32, i32, i32 }
%struct.SLII = type { i64, i32 }
%struct.S_ints = type { i8, i8, i16, i32 }

declare void @pass_S4I(%struct.S4I, %struct.S4I)

; Pass structs only containing integers
; The first struct should be passed in $r6-$r9
; The second one in [SP-4, SP-20[
define void @call_pass_S4I() {
; CHECK-LABEL: call_pass_S4I:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.u20 r12, #5
; CHECK-NEXT:    st.spil lr, [sp, #-32]
; CHECK-NEXT:    st.spil r12, [sp, #-4]
; CHECK-NEXT:    mov.u20 r12, #6
; CHECK-NEXT:    st.spil r12, [sp, #-8]
; CHECK-NEXT:    mov.u20 r12, #7
; CHECK-NEXT:    st.spil r12, [sp, #-12]
; CHECK-NEXT:    mov.u20 r12, #8
; CHECK-NEXT:    mov.u20 r6, #1
; CHECK-NEXT:    mov.u20 r7, #2
; CHECK-NEXT:    mov.u20 r8, #3
; CHECK-NEXT:    mov.u20 r9, #4
; CHECK-NEXT:    st.spil r12, [sp, #-16]
; CHECK-NEXT:    jal pass_S4I
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  call void @pass_S4I(%struct.S4I { i32 1, i32 2, i32 3, i32 4 }, %struct.S4I { i32 5, i32 6, i32 7, i32 8 }) #5
  ret void
}

; Check that structs passed by value are used properly:
; extractvalue %struct.S4I %a, 3 should be in $r9
; extractvalue %struct.S4I %b, 3 should be in [sp, #-16]
define i32 @use_2S4I(%struct.S4I %a, %struct.S4I %b) {
; CHECK-LABEL: use_2S4I:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    lda.spil r12, [sp, #-16]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r0, r9, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %a.3.extract = extractvalue %struct.S4I %a, 3
  %b.3.extract = extractvalue %struct.S4I %b, 3
  %res = add i32 %a.3.extract, %b.3.extract
  ret i32 %res
}

declare void @pass_3I_S2I_I(i32, i32, i32, %struct.S2I, i32)

; %struct.S2I crosses the register-stack boundary
; 1,2,3,4 -> $r6-$r9
; 5,6 -> [SP-4, SP-12[
define void @call_pass_3I_S2I_I() {
; CHECK-LABEL: call_pass_3I_S2I_I:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.u20 r12, #5
; CHECK-NEXT:    st.spil lr, [sp, #-32]
; CHECK-NEXT:    st.spil r12, [sp, #-4]
; CHECK-NEXT:    mov.u20 r12, #6
; CHECK-NEXT:    mov.u20 r6, #1
; CHECK-NEXT:    mov.u20 r7, #2
; CHECK-NEXT:    mov.u20 r8, #3
; CHECK-NEXT:    mov.u20 r9, #4
; CHECK-NEXT:    st.spil r12, [sp, #-8]
; CHECK-NEXT:    jal pass_3I_S2I_I
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  call void @pass_3I_S2I_I(i32 1, i32 2, i32 3, %struct.S2I { i32 4, i32 5 }, i32 6)
  ret void
}

define i32 @use_3I_S2I_I(i32 %a, i32 %b, i32 %c, %struct.S2I %s, i32 %d) {
; CHECK-LABEL: use_3I_S2I_I:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    lda.spil r12, [sp, #-8]
; CHECK-NEXT:    lda.spil r13, [sp, #-4]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r12, r8, r12
; CHECK-NEXT:    add r13, r9, r13
; CHECK-NEXT:    add r0, r13, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %s.0.extract = extractvalue %struct.S2I %s, 0
  %s.1.extract = extractvalue %struct.S2I %s, 1
  %res = add i32 %s.0.extract, %s.1.extract
  %res1 = add i32 %c, %d
  %res2 = add i32 %res, %res1
  ret i32 %res2
}

declare void @pass_3I_SLII(i32, i32, i32, %struct.SLII)

; %struct.S2I crosses the register-stack boundary
; 1,2,3,5 -> $r6-$r9
; (i64)4 -> [SP-4, SP-12[
define void @call_pass_3I_SLII() {
; CHECK-LABEL: call_pass_3I_SLII:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.u20 r12, #4
; CHECK-NEXT:    st.spil lr, [sp, #-32]
; CHECK-NEXT:    st.spil r12, [sp, #-8]
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    mov.u20 r6, #1
; CHECK-NEXT:    mov.u20 r7, #2
; CHECK-NEXT:    mov.u20 r8, #3
; CHECK-NEXT:    mov.u20 r9, #5
; CHECK-NEXT:    st.spil r12, [sp, #-4]
; CHECK-NEXT:    jal pass_3I_SLII
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  call void @pass_3I_SLII(i32 1, i32 2, i32 3, %struct.SLII { i64 4, i32 5 })
  ret void
}

declare void @pass_smallints(%struct.S_ints %a, %struct.S_ints %b)

; Pass small integers in a strut, they should still occupy a full register
; Integers on the stack also occupy a full 32-bits slot
define void @call_pass_smallints(i32 %v) {
; CHECK-LABEL: call_pass_smallints:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.u20 r12, #5
; CHECK-NEXT:    st.spil lr, [sp, #-32]
; CHECK-NEXT:    st.spil r12, [sp, #-4]
; CHECK-NEXT:    mov.u20 r12, #6
; CHECK-NEXT:    st.spil r12, [sp, #-8]
; CHECK-NEXT:    mov.u20 r12, #7
; CHECK-NEXT:    st.spil r12, [sp, #-12]
; CHECK-NEXT:    mov.u20 r12, #8
; CHECK-NEXT:    add r6, r6, #1
; CHECK-NEXT:    mov.u20 r7, #2
; CHECK-NEXT:    mov.u20 r8, #3
; CHECK-NEXT:    mov.u20 r9, #4
; CHECK-NEXT:    st.spil r12, [sp, #-16]
; CHECK-NEXT:    jal pass_smallints
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %v.conv = trunc i32 %v to i8
  %v.add = add i8 %v.conv, 1
  %a.insert = insertvalue %struct.S_ints {i8 undef, i8 2, i16 3, i32 4}, i8 %v.add, 0
  call void @pass_smallints(%struct.S_ints %a.insert, %struct.S_ints {i8 5, i8 6, i16 7, i32 8})
  ret void
}

define signext i8 @use_smallints(%struct.S_ints %a, %struct.S_ints %b) {
; CHECK-LABEL: use_smallints:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov r12, sp
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    padda [p0], #-8
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.s8 r0, [p0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r12, r7, r0
; CHECK-NEXT:    se.8 r0, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %a.1.extract = extractvalue %struct.S_ints %a, 1
  %b.1.extract = extractvalue %struct.S_ints %b, 1
  %res = add i8 %a.1.extract, %b.1.extract
  ret i8 %res
}
