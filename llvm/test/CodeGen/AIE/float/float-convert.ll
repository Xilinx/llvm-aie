; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 -verify-machineinstrs < %s \
; RUN:   | FileCheck %s

define i32 @fp_to_sint(float %a) nounwind {
; CHECK-LABEL: fp_to_sint:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.spil lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    jal __fixsfsi
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %1 = fptosi float %a to i32
  ret i32 %1
}

define float @sint_to_fp(i32 %a) nounwind {
; CHECK-LABEL: sint_to_fp:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    mov s2, r12
; CHECK-NEXT:    mov r0, r6.FX2FLT, s2
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %1 = sitofp i32 %a to float
  ret float %1
}

define i32 @fp_to_uint(float %a) nounwind {
; CHECK-LABEL: fp_to_uint:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.spil lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    jal __fixunssfsi
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %1 = fptoui float %a to i32
  ret i32 %1
}

define float @uint_to_fp(i32 %a) nounwind {
; CHECK-LABEL: uint_to_fp:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.spil lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    jal __floatunsisf
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %1 = uitofp i32 %a to float
  ret float %1
}

declare i32 @llvm.lrint.i32.f32(float %Val)
define i32 @lrintf(float %a) nounwind {
; CHECK-LABEL: lrintf:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    mov     s3, r12
; CHECK-NEXT:    mov     r0, r6.FLT2FX, s3
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %1 = tail call i32 @llvm.lrint.i32.f32(float %a)
  ret i32 %1
}
