; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 < %s | FileCheck %s

; Just check GlobalISel does not crash
; We have to exclude functions with floats because they are not yet supported.
; RUN: llvm-extract --delete --rfunc=D --rfunc=F %s \
; RUN:   | llc -mtriple=aie -global-isel

define void @call_pass_I_va_2I() {
; CHECK-LABEL: call_pass_I_va_2I:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.u20 r12, #2
; CHECK-NEXT:    st.spil lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    st.spil r12, [sp, #-4]
; CHECK-NEXT:    mov.u20 r12, #3
; CHECK-NEXT:    mov.u20 r6, #1
; CHECK-NEXT:    st.spil r12, [sp, #-8]
; CHECK-NEXT:    jal pass_I_va_2I
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  call void (i32, ...) @pass_I_va_2I(i32 1, i32 2, i32 3)
  ret void
}

declare void @pass_I_va_2I(i32, ...)

define i32 @use_I_va_2I(i32 %a, ...) {
; CHECK-LABEL: use_I_va_2I:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.s12 cs0, #-8
; CHECK-NEXT:    mov r12, sp
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    padda [p0], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r12, [p0, cs0]
; CHECK-NEXT:    mov.s12 cs0, #-4
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r13, [p0, cs0]
; CHECK-NEXT:    padda [p0], #-8
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.spil p0, [sp, #-28]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r13, r13, r6
; CHECK-NEXT:    add r0, r13, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %args = alloca i8*, align 4
  %0 = bitcast i8** %args to i8*
  call void @llvm.va_start(i8* nonnull %0)
  %1 = va_arg i8** %args, i32
  %add = add nsw i32 %1, %a
  %2 = va_arg i8** %args, i32
  %add3 = add nsw i32 %add, %2
  call void @llvm.va_end(i8* nonnull %0)
  ret i32 %add3
}

declare void @llvm.va_start(i8*)
declare void @llvm.va_end(i8*)

; 214748364805 is 5 + 50<<32
define void @call_pass_3LI_va_SILI() {
; CHECK-LABEL: call_pass_3LI_va_SILI:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    padda [sp], #64
; CHECK-NEXT:    mov.u20 r12, #3
; CHECK-NEXT:    st.spil lr, [sp, #-64] // 4-byte Folded Spill
; CHECK-NEXT:    st.spil r12, [sp, #-8]
; CHECK-NEXT:    mov.u20 r7, #0
; CHECK-NEXT:    mov.u20 r12, #4
; CHECK-NEXT:    st.spil r7, [sp, #-4]
; CHECK-NEXT:    st.spil r12, [sp, #-36]
; CHECK-NEXT:    mov.u20 r12, #5
; CHECK-NEXT:    st.spil r12, [sp, #-44]
; CHECK-NEXT:    mov.u20 r12, #50
; CHECK-NEXT:    mov.u20 r6, #1
; CHECK-NEXT:    mov.u20 r8, #2
; CHECK-NEXT:    mov r9, r7
; CHECK-NEXT:    st.spil r12, [sp, #-40]
; CHECK-NEXT:    jal pass_3LI_va_SILI
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-64] // 4-byte Folded Reload
; CHECK-NEXT:    padda [sp], #-64
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  call void (i64, i64, i64, ...) @pass_3LI_va_SILI(i64 1, i64 2, i64 3, i16 4, i64 214748364805)
  ret void
}

declare void @pass_3LI_va_SILI(i64, i64, i64, ...)

define i32 @use_3LI_va_SILI(i64 %a, i64 %b, i64 %c, ...) {
; CHECK-LABEL: use_3LI_va_SILI:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.s12 m0, #-64
; CHECK-NEXT:    mov r12, sp
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    mov.s12 cs0, #-12
; CHECK-NEXT:    padda [p0], m0
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r12, [p0, cs0]
; CHECK-NEXT:    mov.s12 cs0, #-4
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.s16 r0, [p0, cs0]
; CHECK-NEXT:    padda [p0], #-12
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.spil p0, [sp, #-32]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r0, r0, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %args = alloca i8*, align 4
  %0 = bitcast i8** %args to i8*
  call void @llvm.va_start(i8* nonnull %0)
  %1 = va_arg i8** %args, i16
  %tmp1 = sext i16 %1 to i32
  %2 = va_arg i8** %args, i64
  %tmp2 = trunc i64 %2 to i32
  %add = add nsw i32 %tmp1, %tmp2
  call void @llvm.va_end(i8* nonnull %0)
  ret i32 %add
}

; f64/double should be 32-bits aligned, verify that when passing
; int-double-int-double vaargs, their addresses are respectively SP-4, SP-12,
; SP-16, and SP-24
define void @call_pass_I_va_IDID() {
; CHECK-LABEL: call_pass_I_va_IDID:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.u20 r13, #524288
; CHECK-NEXT:    mov.u20 r12, #2
; CHECK-NEXT:    st.spil lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    st.spil r12, [sp, #-4]
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    movt.s12 r13, #1024
; CHECK-NEXT:    st.spil r12, [sp, #-12]
; CHECK-NEXT:    st.spil r13, [sp, #-8]
; CHECK-NEXT:    mov.u20 r13, #4
; CHECK-NEXT:    st.spil r13, [sp, #-16]
; CHECK-NEXT:    st.spil r12, [sp, #-24]
; CHECK-NEXT:    mov.u20 r12, #262144
; CHECK-NEXT:    movt.s12 r12, #1025
; CHECK-NEXT:    mov.u20 r6, #1
; CHECK-NEXT:    st.spil r12, [sp, #-20]
; CHECK-NEXT:    jal pass_I_va_IDID
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  call void (i32, ...) @pass_I_va_IDID(i32 1, i32 2, double 3., i32 4, double 5.)
  ret void
}

declare void @pass_I_va_IDID(i32, ...)

; f64/double should be 32-bits aligned on the stack, not 64-bits aligned.
; Verify that when retrieving, int-double vaargs, the "double" vaarg has
; an address of SP-12(-32).
define double @use_I_va_ID(i32 %a, ...) {
; CHECK-LABEL: use_I_va_ID:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.s12 cs0, #-8
; CHECK-NEXT:    mov r12, sp
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    padda [p0], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov p1, p0
; CHECK-NEXT:    padda [p1], #-12
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.spil p1, [sp, #-28]
; CHECK-NEXT:    lda r1, [p0, cs0]
; CHECK-NEXT:    mov.s12 cs0, #-12
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    lda r0, [p0, cs0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %args = alloca i8*, align 4
  %0 = bitcast i8** %args to i8*
  call void @llvm.va_start(i8* nonnull %0)
  %1 = va_arg i8** %args, i32
  %2 = va_arg i8** %args, double
  call void @llvm.va_end(i8* nonnull %0)
  ret double %2
}

; f64/double should be 32-bits aligned on the stack, not 64-bits aligned.
; Verify that when retrieving a "double" vaarg, it has an address of SP-8(-32).
define double @use_I_va_D(i32 %a, ...) {
; CHECK-LABEL: use_I_va_D:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.s12 cs0, #-4
; CHECK-NEXT:    mov r12, sp
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    padda [p0], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov p1, p0
; CHECK-NEXT:    padda [p1], #-8
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.spil p1, [sp, #-28]
; CHECK-NEXT:    lda r1, [p0, cs0]
; CHECK-NEXT:    mov.s12 cs0, #-8
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    lda r0, [p0, cs0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %args = alloca i8*, align 4
  %0 = bitcast i8** %args to i8*
  call void @llvm.va_start(i8* nonnull %0)
  %1 = va_arg i8** %args, double
  call void @llvm.va_end(i8* nonnull %0)
  ret double %1
}

; The C standard automatically promotes float varargs to double.
; LLVM IR has no such requirement, so we can still test that passing floats
; works as expected.
define void @call_pass_I_va_F() {
; CHECK-LABEL: call_pass_I_va_F:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.u20 r6, #1
; CHECK-NEXT:    movt.s12 r12, #1024
; CHECK-NEXT:    st.spil lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    st.spil r12, [sp, #-4]
; CHECK-NEXT:    jal pass_I_va_F
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  call void (i32, ...) @pass_I_va_F(i32 1, float 2.)
  ret void
}

declare void @pass_I_va_F(i32, ...)

define float @use_I_va_F(i32 %a, ...) {
; CHECK-LABEL: use_I_va_F:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.s12 cs0, #-4
; CHECK-NEXT:    mov r12, sp
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    padda [p0], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov p1, p0
; CHECK-NEXT:    padda [p1], #-4
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.spil p1, [sp, #-28]
; CHECK-NEXT:    lda r0, [p0, cs0]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %args = alloca i8*, align 4
  %0 = bitcast i8** %args to i8*
  call void @llvm.va_start(i8* nonnull %0)
  %1 = va_arg i8** %args, float
  call void @llvm.va_end(i8* nonnull %0)
  ret float %1
}
