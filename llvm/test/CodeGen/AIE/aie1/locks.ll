; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 < %s | FileCheck %s

target triple = "aie"

define i32 @test(i32 inreg %a) local_unnamed_addr {
; CHECK-LABEL: test:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 r0, #1
; CHECK-NEXT:    acq #17, #1, r0
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    acq r6, #1, r12
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    rel #17, #1, r0
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    rel r6, #1, r12
; CHECK:         ret lr
entry:
  tail call void @llvm.aie.lock.acquire.reg(i32 17, i32 1)
  tail call void @llvm.aie.lock.acquire.reg(i32 %a, i32 0)
  tail call void @llvm.aie.lock.release.reg(i32 17, i32 1)
  tail call void @llvm.aie.lock.release.reg(i32 %a, i32 0)
  ret i32 1
}

define i32 @testStoreToLock(i32 inreg %a, i32* nocapture %p) local_unnamed_addr {
; CHECK-LABEL: testStoreToLock:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:        st      r6, [p0]
; CHECK-NEXT:        mov.u20 r0, #1
; CHECK-NEXT:        nop
; CHECK-NEXT:        nop
; CHECK-NEXT:        nop
; CHECK-NEXT:        rel     #17, #1, r6
entry:
  store i32 %a, i32* %p, align 4
  tail call void @llvm.aie.lock.release.reg(i32 17, i32 %a)
  ret i32 1
}
define i32 @testLockToLoad(i32 inreg %a, i32* nocapture %p) local_unnamed_addr {
; CHECK-LABEL: testLockToLoad:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:         acq     #17, #1, r6
; CHECK-NEXT:         nop
; CHECK-NEXT:         nop
; CHECK-NEXT:         nop
; CHECK-NEXT:         nop
; CHECK-NEXT:         lda     r0, [p0]
entry:
  tail call void @llvm.aie.lock.acquire.reg(i32 17, i32 %a)
  %r = load i32, i32* %p, align 4
  ret i32 %r
}

; Function Attrs: nounwind
declare void @llvm.aie.lock.acquire.reg(i32, i32)

; Function Attrs: nounwind
declare void @llvm.aie.lock.release.reg(i32, i32)
