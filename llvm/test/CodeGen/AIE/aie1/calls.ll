; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --stop-after=prologepilog < %s | FileCheck %s

declare i32 @external_function(i32)

define i32 @test_call_external(i32 %a) nounwind {
  ; CHECK-LABEL: name: test_call_external
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r6
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   frame-setup PADDA_sp_imm 32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_PTR killed $lr, -32, implicit $sp :: (store (s32) into %stack.0)
  ; CHECK-NEXT:   JAL @external_function, csr_aie1, implicit-def dead $lr, implicit $r6, implicit-def $sp, implicit-def $r0
  ; CHECK-NEXT:   $lr = LR_LOAD -32, implicit-def $r15, implicit $sp :: (load (s32) from %stack.0)
  ; CHECK-NEXT:   frame-destroy PADDA_sp_imm -32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
  %1 = call i32 @external_function(i32 %a)
  ret i32 %1
}

declare dso_local i32 @dso_local_function(i32)

define i32 @test_call_dso_local(i32 %a) nounwind {
  ; CHECK-LABEL: name: test_call_dso_local
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r6
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   frame-setup PADDA_sp_imm 32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_PTR killed $lr, -32, implicit $sp :: (store (s32) into %stack.0)
  ; CHECK-NEXT:   JAL @dso_local_function, csr_aie1, implicit-def dead $lr, implicit $r6, implicit-def $sp, implicit-def $r0
  ; CHECK-NEXT:   $lr = LR_LOAD -32, implicit-def $r15, implicit $sp :: (load (s32) from %stack.0)
  ; CHECK-NEXT:   frame-destroy PADDA_sp_imm -32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
  %1 = call i32 @dso_local_function(i32 %a)
  ret i32 %1
}

define i32 @defined_function(i32 %a) nounwind {
  ; CHECK-LABEL: name: defined_function
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r6
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $r0 = ADDI killed renamable $r6, 1
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
  %1 = add i32 %a, 1
  ret i32 %1
}

define i32 @test_call_defined(i32 %a) nounwind {
  ; CHECK-LABEL: name: test_call_defined
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r6
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   frame-setup PADDA_sp_imm 32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_PTR killed $lr, -32, implicit $sp :: (store (s32) into %stack.0)
  ; CHECK-NEXT:   JAL @defined_function, csr_aie1, implicit-def dead $lr, implicit $r6, implicit-def $sp, implicit-def $r0
  ; CHECK-NEXT:   $lr = LR_LOAD -32, implicit-def $r15, implicit $sp :: (load (s32) from %stack.0)
  ; CHECK-NEXT:   frame-destroy PADDA_sp_imm -32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
  %1 = call i32 @defined_function(i32 %a)
  ret i32 %1
}

; FIXME: we don't select indirect calls yet.
; define i32 @test_call_indirect(i32 (i32)* %a, i32 %b) nounwind {
;   %1 = call i32 %a(i32 %b)
;   ret i32 %1
; }

; Ensure that calls to fastcc functions aren't rejected. Such calls may be
; introduced when compiling with optimisation.
define fastcc i32 @fastcc_function(i32 %a, i32 %b) nounwind {
  ; CHECK-LABEL: name: fastcc_function
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r6, $r7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $r0 = ADD killed renamable $r6, killed renamable $r7
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
 %1 = add i32 %a, %b
 ret i32 %1
}

define i32 @test_call_fastcc(i32 %a, i32 %b) nounwind {
  ; CHECK-LABEL: name: test_call_fastcc
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r6, $r7, $r10
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   frame-setup PADDA_sp_imm 32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_PTR killed $lr, -28, implicit $sp :: (store (s32) into %stack.0)
  ; CHECK-NEXT:   ST_SPIL_GPR killed $r10, -32, implicit $sp :: (store (s32) into %stack.1)
  ; CHECK-NEXT:   renamable $r10 = COPY $r6
  ; CHECK-NEXT:   JAL @fastcc_function, csr_aie1, implicit-def dead $lr, implicit $r6, implicit $r7, implicit-def $sp, implicit-def dead $r0
  ; CHECK-NEXT:   $r0 = COPY killed renamable $r10
  ; CHECK-NEXT:   $r10 = LDA_SPIL_GPR -32, implicit $sp :: (load (s32) from %stack.1)
  ; CHECK-NEXT:   $lr = LR_LOAD -28, implicit-def $r15, implicit $sp :: (load (s32) from %stack.0)
  ; CHECK-NEXT:   frame-destroy PADDA_sp_imm -32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit killed $r0
  %1 = call fastcc i32 @fastcc_function(i32 %a, i32 %b)
  ret i32 %a
}

declare i32 @external_many_args(i32, i32, i32, <2 x i32>, i32, float, i32, <2 x i32>) nounwind

define i32 @test_call_external_many_args(i32 %a, float %b, <2 x i32> %c) nounwind {
  ; CHECK-LABEL: name: test_call_external_many_args
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r6, $r7, $r8, $r9, $r10
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   frame-setup PADDA_sp_imm 32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_PTR killed $lr, -28, implicit $sp :: (store (s32) into %stack.0)
  ; CHECK-NEXT:   ST_SPIL_GPR killed $r10, -32, implicit $sp :: (store (s32) into %stack.1)
  ; CHECK-NEXT:   renamable $r10 = COPY $r6
  ; CHECK-NEXT:   renamable $cl1 = COPY $r8, implicit-def $c1
  ; CHECK-NEXT:   renamable $ch1 = COPY $r9, implicit killed $c1, implicit-def $c1
  ; CHECK-NEXT:   ST_SPIL_GPR $r9, -4, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_GPR $r6, -8, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_GPR killed renamable $r7, -12, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_GPR $r6, -16, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_GPR renamable $cl1, -20, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_GPR $r9, -24, implicit $sp
  ; CHECK-NEXT:   $r7 = COPY $r6
  ; CHECK-NEXT:   $r8 = COPY $r6
  ; CHECK-NEXT:   $r9 = COPY renamable $cl1, implicit killed $c1
  ; CHECK-NEXT:   JAL @external_many_args, csr_aie1, implicit-def dead $lr, implicit $r6, implicit $r7, implicit $r8, implicit $r9, implicit-def $sp, implicit-def dead $r0
  ; CHECK-NEXT:   $r0 = COPY killed renamable $r10
  ; CHECK-NEXT:   $r10 = LDA_SPIL_GPR -32, implicit $sp :: (load (s32) from %stack.1)
  ; CHECK-NEXT:   $lr = LR_LOAD -28, implicit-def $r15, implicit $sp :: (load (s32) from %stack.0)
  ; CHECK-NEXT:   frame-destroy PADDA_sp_imm -32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit killed $r0
  %1 = call i32 @external_many_args(i32 %a, i32 %a, i32 %a, <2 x i32> %c,
                                    i32 %a, float %b, i32 %a, <2 x i32> %c)
  ret i32 %a
}

define i32 @defined_many_args(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 %j) nounwind {
  ; CHECK-LABEL: name: defined_many_args
  ; CHECK: bb.0 (%ir-block.9):
  ; CHECK-NEXT:   renamable $r12 = LDA_SPIL_GPR -24, implicit $sp :: (load (s32) from %fixed-stack.0, align 8)
  ; CHECK-NEXT:   renamable $r0 = ADDI killed renamable $r12, 1
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
  %added = add i32 %j, 1
  ret i32 %added
}

define i32 @test_call_defined_many_args(i32 %a) nounwind {
  ; CHECK-LABEL: name: test_call_defined_many_args
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r6
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   frame-setup PADDA_sp_imm 32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_PTR killed $lr, -32, implicit $sp :: (store (s32) into %stack.0)
  ; CHECK-NEXT:   ST_SPIL_GPR renamable $r6, -4, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_GPR renamable $r6, -8, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_GPR renamable $r6, -12, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_GPR renamable $r6, -16, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_GPR renamable $r6, -20, implicit $sp
  ; CHECK-NEXT:   ST_SPIL_GPR renamable $r6, -24, implicit $sp
  ; CHECK-NEXT:   $r7 = COPY renamable $r6
  ; CHECK-NEXT:   $r8 = COPY renamable $r6
  ; CHECK-NEXT:   $r9 = COPY renamable $r6
  ; CHECK-NEXT:   JAL @defined_many_args, csr_aie1, implicit-def dead $lr, implicit $r6, implicit killed $r7, implicit killed $r8, implicit killed $r9, implicit-def $sp, implicit-def $r0
  ; CHECK-NEXT:   $lr = LR_LOAD -32, implicit-def $r15, implicit $sp :: (load (s32) from %stack.0)
  ; CHECK-NEXT:   frame-destroy PADDA_sp_imm -32, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
  %1 = call i32 @defined_many_args(i32 %a, i32 %a, i32 %a, i32 %a, i32 %a,
                                   i32 %a, i32 %a, i32 %a, i32 %a, i32 %a)
  ret i32 %1
}
