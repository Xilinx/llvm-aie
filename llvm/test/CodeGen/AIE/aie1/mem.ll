; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 -verify-machineinstrs < %s \
; RUN:   | FileCheck %s

; Check indexed and unindexed, sext, zext and anyext loads

define i32 @lbit(i1 *%a) nounwind {
; CHECK-LABEL: lbit:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #1
; CHECK-NEXT:    lda.s8 r0, [p0]
; CHECK-NEXT:    lda.u8 r0, [p0, cs0]
; CHECK:         ret lr
  %1 = getelementptr i1, i1* %a, i32 1
  %2 = load i1, i1* %1
  %3 = zext i1 %2 to i32
  ; the unused load will produce an anyext for selection
  %4 = load volatile i1, i1* %a
  ret i32 %3
}

define i32 @lb(i8 *%a) nounwind {
; CHECK-LABEL: lb:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #1
; CHECK-NEXT:    lda.s8 r0, [p0]
; CHECK-NEXT:    lda.s8 r0, [p0, cs0]
; CHECK:         ret lr
  %1 = getelementptr i8, i8* %a, i32 1
  %2 = load i8, i8* %1
  %3 = sext i8 %2 to i32
  ; the unused load will produce an anyext for selection
  %4 = load volatile i8, i8* %a
  ret i32 %3
}

define <8 x i1> @lv8(<8 x i1> *%a) nounwind {
; CHECK-LABEL: lv8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #1
; CHECK-NEXT:    lda.u8 r0, [p0]
; CHECK-NEXT:    lda.u8 r0, [p0, cs0]
; CHECK:         ret lr
  %1 = getelementptr <8 x i1>, <8 x i1>* %a, i32 1
  %2 = load <8 x i1>, <8 x i1>* %1
  ; the unused load will produce an anyext for selection
  %3 = load volatile <8 x i1>, <8 x i1>* %a
  ret <8 x i1> %2
}

define <16 x i1> @lv16(<16 x i1> *%a) nounwind {
; CHECK-LABEL: lv16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #2
; CHECK-NEXT:    lda.u16 r0, [p0]
; CHECK-NEXT:    lda.u16 r0, [p0, cs0]
; CHECK:         ret lr
  %1 = getelementptr <16 x i1>, <16 x i1>* %a, i32 1
  %2 = load <16 x i1>, <16 x i1>* %1
  ; the unused load will produce an anyext for selection
  %3 = load volatile <16 x i1>, <16 x i1>* %a
  ret <16 x i1> %2
}

define i32 @lh(i16 *%a) nounwind {
; CHECK-LABEL: lh:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #4
; CHECK-NEXT:    lda.s16 r0, [p0]
; CHECK-NEXT:    lda.s16 r0, [p0, cs0]
; CHECK:         ret lr
  %1 = getelementptr i16, i16* %a, i32 2
  %2 = load i16, i16* %1
  %3 = sext i16 %2 to i32
  ; the unused load will produce an anyext for selection
  %4 = load volatile i16, i16* %a
  ret i32 %3
}

define i20 @lp(i32 *%a) nounwind {
; CHECK-LABEL: lp:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #8
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r12, [p0, cs0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov p0, r12
; CHECK:         ret lr
  %1 = getelementptr i32, i32* %a, i32 2
  %2 = load i32, i32* %1
  %3 = trunc i32 %2 to i20
  ret i20 %3
}

define i20 @lp2(i16 *%a) nounwind {
; CHECK-LABEL: lp2:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #4
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u16 r0, [p0, cs0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov p0, r0
; CHECK:         ret lr
  %1 = getelementptr i16, i16* %a, i32 2
  %2 = load i16, i16* %1
  %3 = zext i16 %2 to i20
  ret i20 %3
}

define i32 @lw(i32 *%a) nounwind {
; CHECK-LABEL: lw:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #12
; CHECK-NEXT:    lda r12, [p0]
; CHECK-NEXT:    lda r0, [p0, cs0]
; CHECK:         ret lr
  %1 = getelementptr i32, i32* %a, i32 3
  %2 = load i32, i32* %1
  %3 = load volatile i32, i32* %a
  ret i32 %2
}

define i32 @lbu(i8 *%a) nounwind {
; CHECK-LABEL: lbu:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #4
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u8 r0, [p0, cs0]
; CHECK-NEXT:    lda.u8 r1, [p0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r0, r0, r1
; CHECK:         ret lr
  %1 = getelementptr i8, i8* %a, i32 4
  %2 = load i8, i8* %1
  %3 = zext i8 %2 to i32
  %4 = load volatile i8, i8* %a
  %5 = zext i8 %4 to i32
  %6 = add i32 %3, %5
  ret i32 %6
}

define i32 @lhu(i16 *%a) nounwind {
; CHECK-LABEL: lhu:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #10
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u16 r0, [p0, cs0]
; CHECK-NEXT:    lda.u16 r1, [p0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r0, r0, r1
; CHECK:         ret lr
  %1 = getelementptr i16, i16* %a, i32 5
  %2 = load i16, i16* %1
  %3 = zext i16 %2 to i32
  %4 = load volatile i16, i16* %a
  %5 = zext i16 %4 to i32
  %6 = add i32 %3, %5
  ret i32 %6
}

; Check indexed and unindexed stores

define void @sbit(i1 *%a, i1 %b) nounwind {
; CHECK-LABEL: sbit:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #6
; CHECK-NEXT:    mov.u20 r13, #1
; CHECK-NEXT:    and r13, r6, r13
; CHECK-NEXT:    st.s8 r13, [p0, cs0]
; CHECK-NEXT:    st.s8 r13, [p0]
; CHECK:         ret lr
  store i1 %b, i1* %a
  %1 = getelementptr i1, i1* %a, i32 6
  store i1 %b, i1* %1
  ret void
}

define void @sb(i8 *%a, i8 %b) nounwind {
; CHECK-LABEL: sb:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #6
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.s8 r6, [p0, cs0]
; CHECK-NEXT:    st.s8 r6, [p0]
; CHECK:         ret lr
  store i8 %b, i8* %a
  %1 = getelementptr i8, i8* %a, i32 6
  store i8 %b, i8* %1
  ret void
}

define void @sv8(<8 x i1> *%a, <8 x i1> %b) nounwind {
; CHECK-LABEL: sv8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #6
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.s8 r6, [p0, cs0]
; CHECK-NEXT:    st.s8 r6, [p0]
; CHECK:         ret lr
  store <8 x i1> %b, <8 x i1>* %a
  %1 = getelementptr <8 x i1>, <8 x i1>* %a, i32 6
  store <8 x i1> %b, <8 x i1>* %1
  ret void
}

define void @sv16(<16 x i1> *%a, <16 x i1> %b) nounwind {
; CHECK-LABEL: sv16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #12
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.s16 r6, [p0, cs0]
; CHECK-NEXT:    st.s16 r6, [p0]
; CHECK:         ret lr
  store <16 x i1> %b, <16 x i1>* %a
  %1 = getelementptr <16 x i1>, <16 x i1>* %a, i32 6
  store <16 x i1> %b, <16 x i1>* %1
  ret void
}

define void @sh(i16 *%a, i16 %b) nounwind {
; CHECK-LABEL: sh:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #14
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.s16 r6, [p0, cs0]
; CHECK-NEXT:    st.s16 r6, [p0]
; CHECK:         ret lr
  store i16 %b, i16* %a
  %1 = getelementptr i16, i16* %a, i32 7
  store i16 %b, i16* %1
  ret void
}

define void @sw(i32 *%a, i32 %b) nounwind {
; CHECK-LABEL: sw:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #32
; CHECK-NEXT:    nop
; CHECK-NEXT:    st r6, [p0, cs0]
; CHECK-NEXT:    st r6, [p0]
; CHECK:         ret lr
  store i32 %b, i32* %a
  %1 = getelementptr i32, i32* %a, i32 8
  store i32 %b, i32* %1
  ret void
}

; Check load and store to an i1 location
define i32 @load_sext_zext_anyext_i1(i1 *%a) nounwind {
; CHECK-LABEL: load_sext_zext_anyext_i1:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #1
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u8 r0, [p0, cs0]
; CHECK-NEXT:    mov.s12 cs0, #2
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u8 r1, [p0, cs0]
; CHECK-NEXT:    lda.s8 r2, [p0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    sub r0, r1, r0
; CHECK:         ret lr

  ; sextload i1
  %1 = getelementptr i1, i1* %a, i32 1
  %2 = load i1, i1* %1
  %3 = sext i1 %2 to i32
  ; zextload i1
  %4 = getelementptr i1, i1* %a, i32 2
  %5 = load i1, i1* %4
  %6 = zext i1 %5 to i32
  %7 = add i32 %3, %6
  ; extload i1 (anyext). Produced as the load is unused.
  %8 = load volatile i1, i1* %a
  ret i32 %7
}

define i16 @load_sext_zext_anyext_i1_i16(i1 *%a) nounwind {
; CHECK-LABEL: load_sext_zext_anyext_i1_i16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #1
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u8 r0, [p0, cs0]
; CHECK-NEXT:    mov.s12 cs0, #2
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u8 r1, [p0, cs0]
; CHECK-NEXT:    lda.s8 r2, [p0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    sub r0, r1, r0
; CHECK:         ret lr

  ; sextload i1
  %1 = getelementptr i1, i1* %a, i32 1
  %2 = load i1, i1* %1
  %3 = sext i1 %2 to i16
  ; zextload i1
  %4 = getelementptr i1, i1* %a, i32 2
  %5 = load i1, i1* %4
  %6 = zext i1 %5 to i16
  %7 = add i16 %3, %6
  ; extload i1 (anyext). Produced as the load is unused.
  %8 = load volatile i1, i1* %a
  ret i16 %7
}

define i20 @load_sext_zext_anyext_i1_i20(i1 *%a) nounwind {
; CHECK-LABEL: load_sext_zext_anyext_i1_i20:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s12 cs0, #1
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u8 r0, [p0, cs0]
; CHECK-NEXT:    mov.s12 cs0, #2
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u8 r1, [p0, cs0]
; CHECK-NEXT:    lda.s8 r2, [p0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    sub     r12, r1, r0
; CHECK-NEXT:    mov     p0, r12
; CHECK:         ret lr

  ; sextload i1
  %1 = getelementptr i1, i1* %a, i32 1
  %2 = load i1, i1* %1
  %3 = sext i1 %2 to i20
  ; zextload i1
  %4 = getelementptr i1, i1* %a, i32 2
  %5 = load i1, i1* %4
  %6 = zext i1 %5 to i20
  %7 = add i20 %3, %6
  ; extload i1 (anyext). Produced as the load is unused.
  %8 = load volatile i1, i1* %a
  ret i20 %7
}

; Check load and store to a global
@G = dso_local global i32 0

define i32 @lw_sw_global(i32 %a) nounwind {
; CHECK-LABEL: lw_sw_global:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.u20 p0, #G
; CHECK-NEXT:    lda r0, [p0]
; CHECK-NEXT:    st r6, [p0]
; CHECK-NEXT:    mov.u20 p0, #(G+36)
; CHECK-NEXT:    lda r12, [p0]
; CHECK-NEXT:    st r6, [p0]
; CHECK:         ret lr
  %1 = load volatile i32, i32* @G
  store i32 %a, i32* @G
  %2 = getelementptr i32, i32* @G, i32 9
  %3 = load volatile i32, i32* %2
  store i32 %a, i32* %2
  ret i32 %1
}

; Ensure that 1 is added to the high 20 bits if bit 11 of the low part is 1
define i32 @lw_sw_constant(i32 %a) nounwind {
; CHECK-LABEL: lw_sw_constant:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov.s20 r12, #-147729
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    lda r0, [p0]
; CHECK-NEXT:    st r6, [p0]
; CHECK:         ret lr
  %1 = inttoptr i32 3735928559 to i32*
  %2 = load volatile i32, i32* %1
  store i32 %a, i32* %1
  ret i32 %2
}

define i8 @mixed_stores(i8 *%a, i8 %b, i32 *%c, i32 %d) nounwind {
; CHECK-LABEL: mixed_stores:
; CHECK:       // %bb.0:
; CHECK-NEXT:     st.s8   r6, [p0]
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     st      r7, [p1]
; CHECK-NEXT:     st.s8   r6, [p0]
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     lda.s8  r0, [p0]
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     nop
; CHECK-NEXT:     ret lr
; CHECK-NEXT:     nop                                     // Delay Slot 5
; CHECK-NEXT:     nop                                     // Delay Slot 4
; CHECK-NEXT:     nop                                     // Delay Slot 3
; CHECK-NEXT:     nop                                     // Delay Slot 2
; CHECK-NEXT:     nop                                     // Delay Slot 1
  store i8 %b, i8* %a
  store i32 %d, i32* %c
  store i8 %b, i8* %a
  %1 = load volatile i8, i8* %a ; Might alias previous store
  ret i8 %1
}
