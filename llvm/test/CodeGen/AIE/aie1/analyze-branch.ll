; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 < %s \
; RUN:   | FileCheck %s --check-prefix=OPT

; RUN: llc -mtriple=aie --issue-limit=1  -tail-merge-size=5 < %s \
; RUN:   | FileCheck %s --check-prefix=NO_OPT

; This test checks that LLVM can do basic stripping and reapplying of branches
; to basic blocks.  In some cases, this would result in branch targets not having
; labels.

declare void @test_true()
declare void @test_false()

; !0 corresponds to a branch being taken, !1 to not being takne.
!0 = !{!"branch_weights", i32 64, i32 4}
!1 = !{!"branch_weights", i32 4, i32 64}

define void @test_bcc_fallthrough_taken(i32 %in) nounwind {
; OPT-LABEL: test_bcc_fallthrough_taken:
; OPT:         .p2align 4
; OPT-NEXT:  // %bb.0:
; OPT-NEXT:    mov.u20 r12, #42
; OPT-NEXT:    padda [sp], #32
; OPT-NEXT:    ne r12, r6, r12
; OPT-NEXT:    st.spil lr, [sp, #-32] // 4-byte Folded Spill
; OPT-NEXT:    bnez r12, .LBB0_3
; OPT-NEXT:    nop // Delay Slot 5
; OPT-NEXT:    nop // Delay Slot 4
; OPT-NEXT:    nop // Delay Slot 3
; OPT-NEXT:    nop // Delay Slot 2
; OPT-NEXT:    nop // Delay Slot 1
; OPT-NEXT:  .LBB0_1: // %true
; OPT-NEXT:    // Label of block must be emitted
; OPT-NEXT:    jal test_true
; OPT-NEXT:    nop // Delay Slot 5
; OPT-NEXT:    nop // Delay Slot 4
; OPT-NEXT:    nop // Delay Slot 3
; OPT-NEXT:    nop // Delay Slot 2
; OPT-NEXT:    nop // Delay Slot 1
; OPT-NEXT:    .p2align 4
; OPT-NEXT:  .LBB0_2: // %true
; OPT-NEXT:    // Label of block must be emitted
; OPT-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; OPT-NEXT:    padda [sp], #-32
; OPT-NEXT:    nop
; OPT-NEXT:    nop
; OPT-NEXT:    nop
; OPT-NEXT:    nop
; OPT-NEXT:    nop
; OPT-NEXT:    nop
; OPT-NEXT:    ret lr
; OPT-NEXT:    nop // Delay Slot 5
; OPT-NEXT:    nop // Delay Slot 4
; OPT-NEXT:    nop // Delay Slot 3
; OPT-NEXT:    nop // Delay Slot 2
; OPT-NEXT:    nop // Delay Slot 1
; OPT-NEXT:    .p2align 4
; OPT-NEXT:  .LBB0_3: // %false
; OPT-NEXT:    // Label of block must be emitted
; OPT-NEXT:    jal test_false
; OPT-NEXT:    nop // Delay Slot 5
; OPT-NEXT:    nop // Delay Slot 4
; OPT-NEXT:    nop // Delay Slot 3
; OPT-NEXT:    nop // Delay Slot 2
; OPT-NEXT:    nop // Delay Slot 1
; OPT-NEXT:    j .LBB0_2
; OPT-NEXT:    nop // Delay Slot 5
; OPT-NEXT:    nop // Delay Slot 4
; OPT-NEXT:    nop // Delay Slot 3
; OPT-NEXT:    nop // Delay Slot 2
; OPT-NEXT:    nop // Delay Slot 1
;
; NO_OPT-LABEL: test_bcc_fallthrough_taken:
; NO_OPT:         .p2align 4
; NO_OPT-NEXT:  // %bb.0:
; NO_OPT-NEXT:    mov.u20 r12, #42
; NO_OPT-NEXT:    padda [sp], #32
; NO_OPT-NEXT:    ne r12, r6, r12
; NO_OPT-NEXT:    st.spil lr, [sp, #-32] // 4-byte Folded Spill
; NO_OPT-NEXT:    bnez r12, .LBB0_2
; NO_OPT-NEXT:    nop // Delay Slot 5
; NO_OPT-NEXT:    nop // Delay Slot 4
; NO_OPT-NEXT:    nop // Delay Slot 3
; NO_OPT-NEXT:    nop // Delay Slot 2
; NO_OPT-NEXT:    nop // Delay Slot 1
; NO_OPT-NEXT:  .LBB0_1: // %true
; NO_OPT-NEXT:    // Label of block must be emitted
; NO_OPT-NEXT:    jal test_true
; NO_OPT-NEXT:    nop // Delay Slot 5
; NO_OPT-NEXT:    nop // Delay Slot 4
; NO_OPT-NEXT:    nop // Delay Slot 3
; NO_OPT-NEXT:    nop // Delay Slot 2
; NO_OPT-NEXT:    nop // Delay Slot 1
; NO_OPT-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; NO_OPT-NEXT:    padda [sp], #-32
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    ret lr
; NO_OPT-NEXT:    nop // Delay Slot 5
; NO_OPT-NEXT:    nop // Delay Slot 4
; NO_OPT-NEXT:    nop // Delay Slot 3
; NO_OPT-NEXT:    nop // Delay Slot 2
; NO_OPT-NEXT:    nop // Delay Slot 1
; NO_OPT-NEXT:    .p2align 4
; NO_OPT-NEXT:  .LBB0_2: // %false
; NO_OPT-NEXT:    // Label of block must be emitted
; NO_OPT-NEXT:    jal test_false
; NO_OPT-NEXT:    nop // Delay Slot 5
; NO_OPT-NEXT:    nop // Delay Slot 4
; NO_OPT-NEXT:    nop // Delay Slot 3
; NO_OPT-NEXT:    nop // Delay Slot 2
; NO_OPT-NEXT:    nop // Delay Slot 1
; NO_OPT-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; NO_OPT-NEXT:    padda [sp], #-32
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    ret lr
; NO_OPT-NEXT:    nop // Delay Slot 5
; NO_OPT-NEXT:    nop // Delay Slot 4
; NO_OPT-NEXT:    nop // Delay Slot 3
; NO_OPT-NEXT:    nop // Delay Slot 2
; NO_OPT-NEXT:    nop // Delay Slot 1
  %tst = icmp eq i32 %in, 42
  br i1 %tst, label %true, label %false, !prof !0

; Expected layout order is: Entry, TrueBlock, FalseBlock
; Entry->TrueBlock is the common path, which should be taken whenever the
; conditional branch is false.

true:
  call void @test_true()
  ret void

false:
  call void @test_false()
  ret void
}

define void @test_bcc_fallthrough_nottaken(i32 %in) nounwind {
; OPT-LABEL: test_bcc_fallthrough_nottaken:
; OPT:         .p2align 4
; OPT-NEXT:  // %bb.0:
; OPT-NEXT:    mov.u20 r12, #42
; OPT-NEXT:    padda [sp], #32
; OPT-NEXT:    ne r12, r6, r12
; OPT-NEXT:    st.spil lr, [sp, #-32] // 4-byte Folded Spill
; OPT-NEXT:    beqz r12, .LBB1_3
; OPT-NEXT:    nop // Delay Slot 5
; OPT-NEXT:    nop // Delay Slot 4
; OPT-NEXT:    nop // Delay Slot 3
; OPT-NEXT:    nop // Delay Slot 2
; OPT-NEXT:    nop // Delay Slot 1
; OPT-NEXT:  .LBB1_1: // %false
; OPT-NEXT:    // Label of block must be emitted
; OPT-NEXT:    jal test_false
; OPT-NEXT:    nop // Delay Slot 5
; OPT-NEXT:    nop // Delay Slot 4
; OPT-NEXT:    nop // Delay Slot 3
; OPT-NEXT:    nop // Delay Slot 2
; OPT-NEXT:    nop // Delay Slot 1
; OPT-NEXT:    .p2align 4
; OPT-NEXT:  .LBB1_2: // %true
; OPT-NEXT:    // Label of block must be emitted
; OPT-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; OPT-NEXT:    padda [sp], #-32
; OPT-NEXT:    nop
; OPT-NEXT:    nop
; OPT-NEXT:    nop
; OPT-NEXT:    nop
; OPT-NEXT:    nop
; OPT-NEXT:    nop
; OPT-NEXT:    ret lr
; OPT-NEXT:    nop // Delay Slot 5
; OPT-NEXT:    nop // Delay Slot 4
; OPT-NEXT:    nop // Delay Slot 3
; OPT-NEXT:    nop // Delay Slot 2
; OPT-NEXT:    nop // Delay Slot 1
; OPT-NEXT:    .p2align 4
; OPT-NEXT:  .LBB1_3: // %true
; OPT-NEXT:    // Label of block must be emitted
; OPT-NEXT:    jal test_true
; OPT-NEXT:    nop // Delay Slot 5
; OPT-NEXT:    nop // Delay Slot 4
; OPT-NEXT:    nop // Delay Slot 3
; OPT-NEXT:    nop // Delay Slot 2
; OPT-NEXT:    nop // Delay Slot 1
; OPT-NEXT:    j .LBB1_2
; OPT-NEXT:    nop // Delay Slot 5
; OPT-NEXT:    nop // Delay Slot 4
; OPT-NEXT:    nop // Delay Slot 3
; OPT-NEXT:    nop // Delay Slot 2
; OPT-NEXT:    nop // Delay Slot 1
;
; NO_OPT-LABEL: test_bcc_fallthrough_nottaken:
; NO_OPT:         .p2align 4
; NO_OPT-NEXT:  // %bb.0:
; NO_OPT-NEXT:    mov.u20 r12, #42
; NO_OPT-NEXT:    padda [sp], #32
; NO_OPT-NEXT:    ne r12, r6, r12
; NO_OPT-NEXT:    st.spil lr, [sp, #-32] // 4-byte Folded Spill
; NO_OPT-NEXT:    beqz r12, .LBB1_2
; NO_OPT-NEXT:    nop // Delay Slot 5
; NO_OPT-NEXT:    nop // Delay Slot 4
; NO_OPT-NEXT:    nop // Delay Slot 3
; NO_OPT-NEXT:    nop // Delay Slot 2
; NO_OPT-NEXT:    nop // Delay Slot 1
; NO_OPT-NEXT:  .LBB1_1: // %false
; NO_OPT-NEXT:    // Label of block must be emitted
; NO_OPT-NEXT:    jal test_false
; NO_OPT-NEXT:    nop // Delay Slot 5
; NO_OPT-NEXT:    nop // Delay Slot 4
; NO_OPT-NEXT:    nop // Delay Slot 3
; NO_OPT-NEXT:    nop // Delay Slot 2
; NO_OPT-NEXT:    nop // Delay Slot 1
; NO_OPT-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; NO_OPT-NEXT:    padda [sp], #-32
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    ret lr
; NO_OPT-NEXT:    nop // Delay Slot 5
; NO_OPT-NEXT:    nop // Delay Slot 4
; NO_OPT-NEXT:    nop // Delay Slot 3
; NO_OPT-NEXT:    nop // Delay Slot 2
; NO_OPT-NEXT:    nop // Delay Slot 1
; NO_OPT-NEXT:    .p2align 4
; NO_OPT-NEXT:  .LBB1_2: // %true
; NO_OPT-NEXT:    // Label of block must be emitted
; NO_OPT-NEXT:    jal test_true
; NO_OPT-NEXT:    nop // Delay Slot 5
; NO_OPT-NEXT:    nop // Delay Slot 4
; NO_OPT-NEXT:    nop // Delay Slot 3
; NO_OPT-NEXT:    nop // Delay Slot 2
; NO_OPT-NEXT:    nop // Delay Slot 1
; NO_OPT-NEXT:    ldb lr, [sp, #-32] // 4-byte Folded Reload
; NO_OPT-NEXT:    padda [sp], #-32
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    nop
; NO_OPT-NEXT:    ret lr
; NO_OPT-NEXT:    nop // Delay Slot 5
; NO_OPT-NEXT:    nop // Delay Slot 4
; NO_OPT-NEXT:    nop // Delay Slot 3
; NO_OPT-NEXT:    nop // Delay Slot 2
; NO_OPT-NEXT:    nop // Delay Slot 1
  %tst = icmp eq i32 %in, 42
  br i1 %tst, label %true, label %false, !prof !1

; Expected layout order is: Entry, FalseBlock, TrueBlock
; Entry->FalseBlock is the common path, which should be taken whenever the
; conditional branch is false

true:
  call void @test_true()
  ret void

false:
  call void @test_false()
  ret void
}

; TODO: how can we expand the coverage of the branch analysis functions?
