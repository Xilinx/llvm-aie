; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 < %s \
; RUN:   | FileCheck %s
; RUN: llc -mtriple=aie --issue-limit=1 -verify-machineinstrs < %s \
; RUN:   | FileCheck %s

; Register-immediate instructions.
define i32 @addi(i32 %a) nounwind {
; CHECK-LABEL: addi:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    add r0, r6, #1
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %1 = add i20 %ta, 1
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @slti (i32 %a) nounwind {
; CHECK-LABEL: slti:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #2
; CHECK-NEXT:    movt.s12 r6, #0
; CHECK-NEXT:    movt.s12 r12, #0
; CHECK-NEXT:    ltu r0, r6, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %1 = icmp slt i20 %ta, 2
  %r = zext i1 %1 to i32
  ret i32 %r
}

define i32 @sltiu (i32 %a) nounwind {
; CHECK-LABEL: sltiu:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #3
; CHECK-NEXT:    ltu r0, r6, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %1 = icmp ult i20 %ta, 3
  %r = zext i1 %1 to i32
  ret i32 %r
}

define i32 @xori (i32 %a) nounwind {
; CHECK-LABEL: xori:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #4
; CHECK-NEXT:    xor r0, r6, r12
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %1 = xor i20 %ta, 4
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @ori (i32 %a) nounwind {
; CHECK-LABEL: ori:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #5
; CHECK-NEXT:    or r0, r6, r12
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %1 = or i20 %ta, 5
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @andi (i32 %a) nounwind {
; CHECK-LABEL: andi:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #6
; CHECK-NEXT:    and r0, r6, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %1 = and i20 %ta, 6
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @slli (i32 %a) nounwind {
; CHECK-LABEL: slli:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #7
; CHECK-NEXT:    lshl r0, r6, r12
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %1 = shl i20 %ta, 7
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @srli (i32 %a) nounwind {
; CHECK-LABEL: srli:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r13, #8
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    sub r12, r12, r13
; CHECK-NEXT:    lshl r0, r6, r12
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %1 = lshr i20 %ta, 8
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @srai (i32 %a) nounwind {
; CHECK-LABEL: srai:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #12
; CHECK-NEXT:    mov.u20 r14, #9
; CHECK-NEXT:    lshl r13, r12, r6
; CHECK-NEXT:    add r12, r12, r14
; CHECK-NEXT:    mov.u20 r14, #0
; CHECK-NEXT:    sub r12, r14, r12
; CHECK-NEXT:    ashl r0, r13, r12
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %1 = ashr i20 %ta, 9
  %r = zext i20 %1 to i32
  ret i32 %r
}
; Register-register instructions
define i32 @add (i32 %a, i32 %b) nounwind {
; CHECK-LABEL: add:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    add r0, r6, r7
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %tb = trunc i32 %b to i20
  %1 = add i20 %ta, %tb
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @sub (i32 %a, i32 %b) nounwind {
; CHECK-LABEL: sub:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    sub r0, r6, r7
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %tb = trunc i32 %b to i20
  %1 = sub i20 %ta, %tb
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @sll (i32 %a, i32 %b) nounwind {
; CHECK-LABEL: sll:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    lshl r0, r6, r7
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %tb = trunc i32 %b to i20
  %1 = shl i20 %ta, %tb
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @slt (i32 %a, i32 %b) nounwind {
; CHECK-LABEL: slt:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    movt.s12 r7, #0
; CHECK-NEXT:    movt.s12 r6, #0
; CHECK-NEXT:    ltu r0, r6, r7
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %tb = trunc i32 %b to i20
  %1 = icmp slt i20 %ta, %tb
  %r = zext i1 %1 to i32
  ret i32 %r
}

define i32 @sltu (i32 %a, i32 %b) nounwind {
; CHECK-LABEL: sltu:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ltu r0, r6, r7
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %tb = trunc i32 %b to i20
  %1 = icmp ult i20 %ta, %tb
  %r = zext i1 %1 to i32
  ret i32 %r
}

define i32 @xor (i32 %a, i32 %b) nounwind {
; CHECK-LABEL: xor:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    xor r12, r6, r7
; CHECK-NEXT:    mov.u20 r13, #1048575
; CHECK-NEXT:    and r0, r12, r13
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %tb = trunc i32 %b to i20
  %1 = xor i20 %ta, %tb
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @srl (i32 %a, i32 %b) nounwind {
; CHECK-LABEL: srl:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    sub r12, r12, r7
; CHECK-NEXT:    lshl r0, r6, r12
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %tb = trunc i32 %b to i20
  %1 = lshr i20 %ta, %tb
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @sra (i32 %a, i32 %b) nounwind {
; CHECK-LABEL: sra:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #12
; CHECK-NEXT:    lshl r13, r12, r6
; CHECK-NEXT:    add r12, r12, r7
; CHECK-NEXT:    mov.u20 r14, #0
; CHECK-NEXT:    sub r12, r14, r12
; CHECK-NEXT:    ashl r0, r13, r12
; CHECK-NEXT:    movt.s12 r0, #0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %tb = trunc i32 %b to i20
  %1 = ashr i20 %ta, %tb
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @or (i32 %a, i32 %b) nounwind {
; CHECK-LABEL: or:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    or r12, r6, r7
; CHECK-NEXT:    mov.u20 r13, #1048575
; CHECK-NEXT:    and r0, r12, r13
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %tb = trunc i32 %b to i20
  %1 = or i20 %ta, %tb
  %r = zext i20 %1 to i32
  ret i32 %r
}

define i32 @and (i32 %a, i32 %b) nounwind {
; CHECK-LABEL: and:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    and r12, r6, r7
; CHECK-NEXT:    mov.u20 r13, #1048575
; CHECK-NEXT:    and r0, r12, r13
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %ta = trunc i32 %a to i20
  %tb = trunc i32 %b to i20
  %1 = and i20 %ta, %tb
  %r = zext i20 %1 to i32
  ret i32 %r
}
