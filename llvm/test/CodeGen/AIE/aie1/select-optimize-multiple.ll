; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 < %s | FileCheck %s
; RUN: llc -mtriple=aie --issue-limit=1 -verify-machineinstrs < %s \
; RUN:  |  FileCheck %s
; RUN: llc -O2 -mtriple=aie --issue-limit=1 < %s | FileCheck %s
; RUN: llc -O2 -mtriple=aie --issue-limit=1 -verify-machineinstrs < %s \
; RUN:   | FileCheck %s


define i32 @selectcc32(i32 signext %a, i32 %b, i32 %c) nounwind {
; CHECK-LABEL: selectcc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 r12, #123
; CHECK-NEXT:    eq r0, r6, r12
; CHECK-NEXT:    ite_nez r0, r7, r8, r0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cmp = icmp eq i32 %a, 123
  %cond = select i1 %cmp, i32 %b, i32 %c
  ret i32 %cond
}


define i16 @selectcc16(i16 signext %a, i16 %b, i16 %c) nounwind {
; CHECK-LABEL: selectcc16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 r12, #123
; CHECK-NEXT:    eq r0, r6, r12
; CHECK-NEXT:    ite_nez r0, r7, r8, r0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cmp = icmp eq i16 %a, 123
  %cond = select i1 %cmp, i16 %b, i16 %c
  ret i16 %cond
}

define i8 @selectcc8(i8 signext %a, i8 %b, i8 %c) nounwind {
; CHECK-LABEL: selectcc8:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 r12, #123
; CHECK-NEXT:    eq r0, r6, r12
; CHECK-NEXT:    ite_nez r0, r7, r8, r0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cmp = icmp eq i8 %a, 123
  %cond = select i1 %cmp, i8 %b, i8 %c
  ret i8 %cond
}

; Unusual sign extension for pointers

define i32 * @maxptr(i32 *%a, i32 *%b) nounwind {
; CHECK-LABEL: maxptr:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov r12, p1
; CHECK-NEXT:    mov r13, p0
; CHECK-NEXT:    eq r0, r13, r12
; CHECK-NEXT:    ite_nez r12, r13, r12, r0
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cmp = icmp eq i32 * %a, %b
  %cond = select i1 %cmp, i32 *%a, i32 *%b
  ret i32 *%cond
}

; Selects of wide values are split into two selects, which can easily cause
; unnecessary control flow. Here we check some cases where we can currently
; emit a sequence of selects with shared control flow.

define i64 @cmovcc64(i32 signext %a, i64 %b, i64 %c) nounwind {
; CHECK-LABEL: cmovcc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov r13, sp
; CHECK-NEXT:    mov p0, r13
; CHECK-NEXT:    mov.u20 r12, #123
; CHECK-NEXT:    padda [p0], #-4
; CHECK-NEXT:    eq r0, r6, r12
; CHECK-NEXT:    lda.spil r12, [sp, #-8]
; CHECK-NEXT:    lda r13, [p0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ite_nez r12, r7, r12, r0
; CHECK-NEXT:    ite_nez r1, r8, r13, r0
; CHECK-NEXT:    mov r0, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cmp = icmp eq i32 %a, 123
  %cond = select i1 %cmp, i64 %b, i64 %c
  ret i64 %cond
}

define i32 @selectccfloat(i32 %a, i32 %b, float %c, float %d) nounwind {
; CHECK-LABEL: selectccfloat:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 cl0, #0
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    movt.s12 cl0, #3
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    vshl0.32 wr2, r9
; CHECK-NEXT:    vshl0.32 wr0, r8
; CHECK-NEXT:    vfpmac wr2, r0, wr2, ya, r15, cl1, wc0, #0, cl1, #1, cl0
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r0, r0[#0]
; CHECK-NEXT:    ite_nez r0, r6, r7, r0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cmp = fcmp ogt float %c, %d
  %cond = select i1 %cmp, i32 %a, i32 %b
  ret i32 %cond
}

define float @selectcci32(i32 %a, i32 %b, float %c, float %d) nounwind {
; CHECK-LABEL: selectcci32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    eq r0, r6, r7
; CHECK-NEXT:    ite_nez r0, r8, r9, r0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cmp = icmp eq i32 %a, %b
  %cond = select i1 %cmp, float %c, float %d
  ret float %cond
}
; define i128 @cmovcc128(i64 signext %a, i128 %b, i128 %c) nounwind {

; entry:
;   %cmp = icmp eq i64 %a, 123
;   %cond = select i1 %cmp, i128 %b, i128 %c
;   ret i128 %cond
; }

define i64 @cmov64(i1 zeroext %a, i64 %b, i64 %c) nounwind {
; CHECK-LABEL: cmov64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov r13, sp
; CHECK-NEXT:    mov p0, r13
; CHECK-NEXT:    padda [p0], #-4
; CHECK-NEXT:    lda.spil r12, [sp, #-8]
; CHECK-NEXT:    lda r13, [p0]
; CHECK-NEXT:    mov r0, r6
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ite_nez r12, r7, r12, r0
; CHECK-NEXT:    ite_nez r1, r8, r13, r0
; CHECK-NEXT:    mov r0, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cond = select i1 %a, i64 %b, i64 %c
  ret i64 %cond
}

; define i128 @cmov128(i1 %a, i128 %b, i128 %c) nounwind {

; entry:
;   %cond = select i1 %a, i128 %b, i128 %c
;   ret i128 %cond
; }

define float @cmovfloat(i1 zeroext %a, float %b, float %c, float %d, float %e) nounwind {
; CHECK-LABEL: cmovfloat:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    lda.spil r13, [sp, #-4]
; CHECK-NEXT:    mov r0, r6
; CHECK-NEXT:    mov.u20 cl0, #0
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    ite_nez r12, r7, r8, r0
; CHECK-NEXT:    movt.s12 cl0, #11
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    ite_nez r13, r9, r13, r0
; CHECK-NEXT:    vshl0.32 wr2, r12
; CHECK-NEXT:    vshl0.32 wr0, r13
; CHECK-NEXT:    vfpmac wr2, r0, wr2, ya, r15, cl1, wc0, #0, cl1, #0, cl0
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    vext.32 r0, vl2[#0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cond1 = select i1 %a, float %b, float %c
  %cond2 = select i1 %a, float %d, float %e
  %ret = fadd float %cond1, %cond2
  ret float %ret
}

define double @cmovdouble(i1 zeroext %a, double %b, double %c) nounwind {
; CHECK-LABEL: cmovdouble:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov r13, sp
; CHECK-NEXT:    mov p0, r13
; CHECK-NEXT:    padda [p0], #-4
; CHECK-NEXT:    lda.spil r12, [sp, #-8]
; CHECK-NEXT:    lda r13, [p0]
; CHECK-NEXT:    mov r0, r6
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ite_nez r12, r7, r12, r0
; CHECK-NEXT:    ite_nez r1, r8, r13, r0
; CHECK-NEXT:    mov r0, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cond = select i1 %a, double %b, double %c
  ret double %cond
}

; Check that selects with dependencies on previous ones aren't incorrectly
; optimized.

define i32 @cmovccdep(i32 signext %a, i32 %b, i32 %c, i32 %d) nounwind {
; CHECK-LABEL: cmovccdep:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 r12, #123
; CHECK-NEXT:    eq r0, r6, r12
; CHECK-NEXT:    ite_nez r12, r7, r8, r0
; CHECK-NEXT:    ite_nez r13, r12, r9, r0
; CHECK-NEXT:    add r0, r12, r13
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cmp = icmp eq i32 %a, 123
  %cond1 = select i1 %cmp, i32 %b, i32 %c
  %cond2 = select i1 %cmp, i32 %cond1, i32 %d
  %ret = add i32 %cond1, %cond2
  ret i32 %ret
}

; Check that selects with different conditions aren't incorrectly optimized.

define i32 @cmovdiffcc(i1 zeroext %a, i1 zeroext %b, i32 %c, i32 %d, i32 %e, i32 %f) nounwind {
; CHECK-LABEL: cmovdiffcc:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    nop
; CHECK-NEXT:    st.spil r7, [sp, #-28] // 4-byte Folded Spill
; CHECK-NEXT:    lda.spil r12, [sp, #-40]
; CHECK-NEXT:    lda.spil r0, [sp, #-28] // 4-byte Folded Reload
; CHECK-NEXT:    st.spil r6, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    lda.spil r13, [sp, #-36]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ite_nez r12, r9, r12, r0
; CHECK-NEXT:    lda.spil r0, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ite_nez r13, r8, r13, r0
; CHECK-NEXT:    add r0, r13, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cond1 = select i1 %a, i32 %c, i32 %e
  %cond2 = select i1 %b, i32 %d, i32 %f
  %ret = add i32 %cond1, %cond2
  ret i32 %ret
}

; Check that selects with frame indexes are handled properly

define i32 @selectframeindex(i1 zeroext %a, i1 zeroext %b, i32 %c, i32 %d, i32 %e, i32 %f) nounwind {
; CHECK-LABEL: selectframeindex:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    mov.s12 m0, #-40
; CHECK-NEXT:    st.spil r7, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    lda.spil r0, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    mov r12, sp
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    padda [p0], m0
; CHECK-NEXT:    mov p1, r12
; CHECK-NEXT:    mov.s12 m0, #-36
; CHECK-NEXT:    padda [p1], m0
; CHECK-NEXT:    mov r13, p0
; CHECK-NEXT:    mov r12, p1
; CHECK-NEXT:    ite_nez r12, r12, r13, r0
; CHECK-NEXT:    st.spil r6, [sp, #-28] // 4-byte Folded Spill
; CHECK-NEXT:    lda.spil r0, [sp, #-28] // 4-byte Folded Reload
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    lda r12, [p0]
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ite_nez r13, r8, r9, r0
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r0, r13, r12
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cond1 = select i1 %a, i32 %c, i32 %d
  %cond2 = select i1 %b, i32 %e, i32 %f
  %ret = add i32 %cond1, %cond2
  ret i32 %ret
}
