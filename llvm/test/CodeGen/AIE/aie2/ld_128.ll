; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2 --issue-limit=1 %s -o - | FileCheck %s
define dso_local noundef <8 x i32> @test1() {
; CHECK-LABEL: test1:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    paddb [sp], #32; nopx
; CHECK-NEXT:    lda q0, [sp, #-32]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wl0, q0 // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 1
entry:
  %a = alloca <4 x i32>, align 16
  %a.0.a.0.a.0.a.0. = load volatile <4 x i32>, ptr %a, align 16
  %0 = tail call <8 x i32> @llvm.aie2.get.I256.I128(<4 x i32> %a.0.a.0.a.0.a.0.)
  ret <8 x i32> %0
}

define dso_local noundef <8 x i32> @test2() {
; CHECK-LABEL: test2:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova p0, #0; nopb ; nopxm ; nops
; CHECK-NEXT:    vlda.128 wl0, [p0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = load <4 x i32>, ptr null, align 16
  %1 = tail call <8 x i32> @llvm.aie2.get.I256.I128(<4 x i32> %0)
  ret <8 x i32> %1
}
@b = external dso_local global [4 x i32], align 16
define dso_local noundef <8 x i32> @test3() {
; CHECK-LABEL: test3:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #32; nopxm ; nops
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    lda q0, [p0, #480]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wl0, q0 // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 1
entry:
  %temp = alloca <4 x i32>, align 16
  %temp1 = getelementptr inbounds i16, ptr %temp, i20 240
  %0 = load volatile <4 x i32>, ptr %temp1, align 16
  %1 = tail call <8 x i32> @llvm.aie2.get.I256.I128(<4 x i32> %0)
  ret <8 x i32> %1
}

define dso_local noundef <8 x i32> @test4() {
; CHECK-LABEL: test4:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    paddb [sp], #32; nopa ; nops ; nopxm ; nopv
; CHECK-NEXT:    mova dj0, #512
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    vldb.128 wl0, [p0, dj0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 1
entry:
  %temp = alloca <4 x i32>, align 16
  %temp1 = getelementptr inbounds i16, ptr %temp, i20 256
  %0 = load volatile <4 x i32>, ptr %temp1, align 16
  %1 = tail call <8 x i32> @llvm.aie2.get.I256.I128(<4 x i32> %0)
  ret <8 x i32> %1
}

declare <8 x i32> @llvm.aie2.get.I256.I128(<4 x i32>)
