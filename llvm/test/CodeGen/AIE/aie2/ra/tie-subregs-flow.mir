# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -O2 -mtriple=aie2 %topdown-single -verify-machineinstrs \
# RUN:    -start-before=phi-node-elimination -stop-before=aie-finalize-mi-bundles \
# RUN:    %s -o - | FileCheck %s
# Just make sure we don't crash on this.
# RUN: llc -O0 -mtriple=aie2 %topdown-single -verify-machineinstrs \
# RUN:    -start-before=phi-node-elimination -stop-before=aie-finalize-mi-bundles %s -o -

---
name:            test_single_padd
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $r0, $r1, $r2, $r3, $p0, $m0
    ; CHECK-LABEL: name: test_single_padd
    ; CHECK: liveins: $m0, $p0, $r0, $r1, $r2, $r3
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: RET implicit $lr
    ; CHECK-NEXT: $m1 = MOV_mv_scl killed $r0
    ; CHECK-NEXT: $dn1 = MOV_mv_scl killed $r1
    ; CHECK-NEXT: $dj1 = MOV_mv_scl killed $r2
    ; CHECK-NEXT: $dc1 = MOV_mv_scl killed $r3
    ; CHECK-NEXT: $p0, dead $dc1 = PADDA_2D killed $p0, killed $d1
    ; CHECK-NEXT: DelayedSchedBarrier implicit killed renamable $p0, implicit killed $m0
    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:ep = COPY $p0

    ; ISel code for %20(p0), %30(i20) = G_INTRINSIC(add_2d_byte) %4, %0, %1, %2, %3
    %10:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count
    %20:ep, %30:edc = PADDA_2D %4, %10

    PseudoRET implicit $lr, implicit %20, implicit $m0
...

---
name:            test_single_padd_simp
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $r0, $r1, $r2, $r3, $p0, $m0
    ; CHECK-LABEL: name: test_single_padd_simp
    ; CHECK: liveins: $m0, $p0, $r0, $r1, $r2, $r3
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: RET implicit $lr
    ; CHECK-NEXT: $m1 = MOV_mv_scl killed $r0
    ; CHECK-NEXT: $dn1 = MOV_mv_scl killed $r1
    ; CHECK-NEXT: $dj1 = MOV_mv_scl killed $r2
    ; CHECK-NEXT: $dc1 = MOV_mv_scl killed $r3
    ; CHECK-NEXT: $p0, dead $dc1 = PADDA_2D killed $p0, killed $d1
    ; CHECK-NEXT: DelayedSchedBarrier implicit killed renamable $p0, implicit killed $m0
    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:ep = COPY $p0

    undef %5.sub_mod:ed = COPY %0
    %5.sub_dim_size:ed = COPY %1
    %5.sub_dim_stride:ed = COPY %2
    %5.sub_dim_count:ed = COPY %3

    %6:ed = COPY %5
    %20:ep, %6.sub_dim_count:ed = PADDA_2D %4, %6

    PseudoRET implicit $lr, implicit %20, implicit $m0
...

---
name:            test_2_padd
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $r0, $r1, $r2, $r3, $p0, $p1, $m0
    ; CHECK-LABEL: name: test_2_padd
    ; CHECK: liveins: $m0, $p0, $p1, $r0, $r1, $r2, $r3
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $m1 = MOV_mv_scl killed $r0
    ; CHECK-NEXT: RET implicit $lr
    ; CHECK-NEXT: $dn1 = MOV_mv_scl killed $r1
    ; CHECK-NEXT: $dj1 = MOV_mv_scl killed $r2
    ; CHECK-NEXT: $dc1 = MOV_mv_scl killed $r3
    ; CHECK-NEXT: $p0, $dc1 = PADDA_2D killed $p0, $d1
    ; CHECK-NEXT: $p0, dead $dc1 = PADDA_2D killed $p0, killed $d1
    ; CHECK-NEXT: DelayedSchedBarrier implicit killed renamable $p0, implicit killed $m0
    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:ep = COPY $p0
    %5:ep = COPY $p1

    ; ISel code for: %20(p0), %12(i20) = G_INTRINSIC(add_2d_byte) %4, %0, %1, %2, %3
    %10:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count
    %20:ep, %12:edc = PADDA_2D %4, %10

    ; ISel code for: %40(p0), %32(i20) = G_INTRINSIC(add_2d_byte) %20, %0, %1, %2, %12
    %30:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %12, %subreg.sub_dim_count
    %40:ep, %32:edc = PADDA_2D %20, %30

    ; Return the twice-incremented pointer.
    PseudoRET implicit $lr, implicit %40, implicit $m0
...

---
name:            test_3_padd
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $r0, $r1, $r2, $r3, $p0, $p1, $m0
    ; CHECK-LABEL: name: test_3_padd
    ; CHECK: liveins: $m0, $p0, $p1, $r0, $r1, $r2, $r3
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $m1 = MOV_mv_scl $r0
    ; CHECK-NEXT: $dn1 = MOV_mv_scl $r1
    ; CHECK-NEXT: $dj1 = MOV_mv_scl $r2
    ; CHECK-NEXT: $dc1 = MOV_mv_scl $r3
    ; CHECK-NEXT: $dc2 = MOV_mv_scl killed $r3
    ; CHECK-NEXT: $dn2 = MOV_mv_scl killed $r1
    ; CHECK-NEXT: $dj2 = MOV_mv_scl killed $r2
    ; CHECK-NEXT: RET implicit $lr
    ; CHECK-NEXT: $m2 = MOV_mv_scl killed $r0
    ; CHECK-NEXT: $p0, $dc2 = PADDA_2D killed $p0, killed $d2
    ; CHECK-NEXT: $p1, dead $dc1 = PADDA_2D killed $p1, $d1
    ; CHECK-NEXT: $dc1 = MOV_mv_scl killed $dc2
    ; CHECK-NEXT: $p0, dead $dc1 = PADDA_2D killed $p0, killed $d1
    ; CHECK-NEXT: DelayedSchedBarrier implicit killed renamable $p1, implicit killed renamable $p0, implicit killed $m0
    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:ep = COPY $p0
    %5:ep = COPY $p1

    ; ISel code for: %200(p0), %300(i20) = G_INTRINSIC(add_2d_byte) %4, %0, %1, %2, %3
    %100:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count
    %200:ep, %300:edc = PADDA_2D %4, %100

    ; ISel code for: %201(p0), %301(i20) = G_INTRINSIC(add_2d_byte) %5, %0, %1, %2, %3
    %101:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count
    %201:ep, %301:edc = PADDA_2D %5, %101

    ; ISel code for: %202(p0), %302(i20) = G_INTRINSIC(add_2d_byte) %200, %0, %1, %2, %300
    %102:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %300, %subreg.sub_dim_count
    %202:ep, %302:edc = PADDA_2D %200, %102

    ; Return the pointers.
    PseudoRET implicit $lr, implicit %201, implicit %202, implicit $m0
...

---
name:            test_4_padd_scarce
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $p0, $p1, $m0, $d2 , $d3 , $d4 , $d5 , $d6 , $d7
    ; CHECK-LABEL: name: test_4_padd_scarce
    ; CHECK: liveins: $d2, $d3, $d4, $d5, $d6, $d7, $m0, $p0, $p1, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: frame-setup PADDB_sp_imm 32, implicit-def $sp, implicit $sp
    ; CHECK-NEXT: $m1 = MOV_mv_scl killed $r4
    ; CHECK-NEXT: ST_dms_spill killed $m1, -32, implicit $sp :: (store (s32) into %stack.0)
    ; CHECK-NEXT: $dc1 = MOV_mv_scl $r3
    ; CHECK-NEXT: $dn1 = MOV_mv_scl $r1
    ; CHECK-NEXT: $dj1 = MOV_mv_scl $r2
    ; CHECK-NEXT: $m1 = MOV_mv_scl $r0
    ; CHECK-NEXT: $p0, dead $dc1 = PADDA_2D killed $p0, killed $d1
    ; CHECK-NEXT: $m1 = LDA_dms_spill -32, implicit $sp :: (load (s32) from %stack.0)
    ; CHECK-NEXT: $m7 = MOV_mv_scl killed $r0
    ; CHECK-NEXT: $dn7 = MOV_mv_scl killed $r1
    ; CHECK-NEXT: $dj7 = MOV_mv_scl killed $r2
    ; CHECK-NEXT: $dc7 = MOV_mv_scl killed $r3
    ; CHECK-NEXT: $p2 = MOV_mv_scl $p1
    ; CHECK-NEXT: dead $p2, $dc7 = PADDA_2D killed $p2, $d7
    ; CHECK-NEXT: frame-destroy PADDB_sp_imm -32, implicit-def $sp, implicit $sp
    ; CHECK-NEXT: RET implicit $lr
    ; CHECK-NEXT: $dn1 = MOV_mv_scl killed $r5
    ; CHECK-NEXT: $dj1 = MOV_mv_scl killed $r6
    ; CHECK-NEXT: $p0, dead $dc7 = PADDA_2D killed $p0, killed $d7
    ; CHECK-NEXT: $dc1 = MOV_mv_scl killed $r7
    ; CHECK-NEXT: $p1, dead $dc1 = PADDA_2D killed $p1, killed $d1
    ; CHECK-NEXT: DelayedSchedBarrier implicit killed renamable $p0, implicit killed renamable $p1, implicit killed $m0, implicit killed $d2, implicit killed $d3, implicit killed $d4, implicit killed $d5, implicit killed $d6
    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:ep = COPY $p0
    %5:ep = COPY $p1
    %6:em =  COPY $r4
    %7:edn = COPY $r5
    %8:edj = COPY $r6
    %9:edc = COPY $r7

    ; ISel code for: %200(p0), %300(i20) = G_INTRINSIC(add_2d_byte) %4, %0, %1, %2, %3
    %100:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count
    %200:ep, %300:edc = PADDA_2D %4, %100

    ; ISel code for: %201(p0), %301(i20) = G_INTRINSIC(add_2d_byte) %5, %0, %1, %2, %3
    %101:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count
    %201:ep, %301:edc = PADDA_2D %5, %101

    ; ISel code for: %202(p0), %302(i20) = G_INTRINSIC(add_2d_byte) %5, %6, %7, %8, %9
    %102:ed = REG_SEQUENCE %6, %subreg.sub_mod, %7, %subreg.sub_dim_size, %8, %subreg.sub_dim_stride, %9, %subreg.sub_dim_count
    %202:ep, %302:edc = PADDA_2D %5, %102

    ; ISel code for: %203(p0), %303(i20) = G_INTRINSIC(add_2d_byte) %200, %0, %1, %2, %300
    %103:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %301, %subreg.sub_dim_count
    %203:ep, %303:edc = PADDA_2D %200, %103

    ; Return the twice-incremented pointer.
    PseudoRET implicit $lr, implicit %203, implicit %202, implicit $m0, implicit $d2 , implicit $d3 , implicit $d4 , implicit $d5 , implicit $d6
...

---
name:            test_4chain_padd_scarce
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $p0, $p1, $m0, $d2 , $d3 , $d4 , $d5 , $d6 , $d7
    ; CHECK-LABEL: name: test_4chain_padd_scarce
    ; CHECK: liveins: $d2, $d3, $d4, $d5, $d6, $d7, $m0, $p0, $p1, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $m1 = MOV_mv_scl $r0
    ; CHECK-NEXT: $dn1 = MOV_mv_scl $r1
    ; CHECK-NEXT: $dj1 = MOV_mv_scl $r2
    ; CHECK-NEXT: $dc1 = MOV_mv_scl killed $r3
    ; CHECK-NEXT: $dc7 = MOV_mv_scl killed $r7
    ; CHECK-NEXT: $m7 = MOV_mv_scl killed $r0
    ; CHECK-NEXT: $dn7 = MOV_mv_scl killed $r1
    ; CHECK-NEXT: $dj7 = MOV_mv_scl killed $r2
    ; CHECK-NEXT: RET implicit $lr
    ; CHECK-NEXT: $p0, $dc1 = PADDA_2D killed $p0, $d1
    ; CHECK-NEXT: $p1, $dc7 = PADDA_2D killed $p1, killed $d7
    ; CHECK-NEXT: $p0, dead $dc1 = PADDA_2D killed $p0, $d1
    ; CHECK-NEXT: $dc1 = MOV_mv_scl killed $dc7
    ; CHECK-NEXT: $p1, dead $dc1 = PADDA_2D killed $p1, killed $d1
    ; CHECK-NEXT: DelayedSchedBarrier implicit killed renamable $p0, implicit killed renamable $p1, implicit killed $m0, implicit killed $d2, implicit killed $d3, implicit killed $d4, implicit killed $d5, implicit killed $d6
    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:ep = COPY $p0
    %5:ep = COPY $p1
    %9:edc = COPY $r7

    ; ISel code for: %200(p0), %300(i20) = G_INTRINSIC(add_2d_byte) %4, %0, %1, %2, %3
    %100:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count
    %200:ep, %300:edc = PADDA_2D %4, %100

    ; ISel code for: %201(p0), %301(i20) = G_INTRINSIC(add_2d_byte) %5, %0, %1, %2, %3
    %101:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %9, %subreg.sub_dim_count
    %201:ep, %301:edc = PADDA_2D %5, %101

    ; ISel code for: %202(p0), %302(i20) = G_INTRINSIC(add_2d_byte) %200, %0, %1, %2, %300
    %102:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %300, %subreg.sub_dim_count
    %202:ep, %302:edc = PADDA_2D %200, %102

    ; ISel code for: %203(p0), %303(i20) = G_INTRINSIC(add_2d_byte) %201, %0, %1, %2, %301
    %106:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %301, %subreg.sub_dim_count
    %203:ep, %303:edc = PADDA_2D %201, %106

    ; Return the two twice-incremented pointer.
    PseudoRET implicit $lr, implicit %202, implicit %203, implicit $m0, implicit $d2 , implicit $d3 , implicit $d4 , implicit $d5 , implicit $d6
...

# Standard loop where the pointer is incremented using PADDA_2D at each
# iteration. Each iteration uses the incremented counter from the previous one.
# After PHI elimination and reg alloc, we should see a simple `PADDA_2D p0 [d0]`
# in the loop body.
---
name:            test_padd_loop
alignment:       16
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: test_padd_loop
  ; CHECK: bb.0.entry (align 16):
  ; CHECK-NEXT:   successors: %bb.3(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT:   liveins: $p0, $r0, $r1, $r2, $r3, $r4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $m0 = MOV_mv_scl killed $r0
  ; CHECK-NEXT:   renamable $r0 = MOVA_lda_cg 0
  ; CHECK-NEXT:   renamable $r5 = GE renamable $r0, renamable $r4
  ; CHECK-NEXT:   JNZ killed renamable $r5, %bb.3
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   DelayedSchedBarrier
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $m0, $p0, $r0, $r1, $r2, $r3, $r4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $dn0 = MOV_mv_scl killed $r1
  ; CHECK-NEXT:   $dj0 = MOV_mv_scl killed $r2
  ; CHECK-NEXT:   $dc0 = MOV_mv_scl killed $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2 (align 16):
  ; CHECK-NEXT:   successors: %bb.3(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT:   liveins: $d0:0x0000000000000870, $dc0, $dj0, $dn0, $m0, $p0, $r0, $r4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   ST_dms_sts_idx_imm renamable $r0, renamable $p0, 0 :: (store (s32))
  ; CHECK-NEXT:   renamable $r0 = nuw nsw ADD_add_r_ri killed renamable $r0, 1, implicit-def $srcarry
  ; CHECK-NEXT:   renamable $r1 = EQ renamable $r4, renamable $r0
  ; CHECK-NEXT:   JZ killed renamable $r1, %bb.2
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   $p0, $dc0 = PADDA_2D killed $p0, $d0
  ; CHECK-NEXT:   DelayedSchedBarrier
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3 (align 16):
  ; CHECK-NEXT:   RET implicit $lr
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   DelayedSchedBarrier
  bb.0.entry:
    liveins: $p0, $r0, $r1, $r2, $r3, $r4

    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:ep = COPY killed $p0
    %5:er = COPY killed $r4
    %24:er = MOVA_lda_cg 0
    %25:er = GE %24, %5
    PseudoJNZ killed %25, %bb.2
  bb.1:
    PseudoJ_jump_imm %bb.3
  bb.2:
    PseudoRET implicit $lr
  bb.3:
    %6:er = PHI %24, %bb.1, %13, %bb.3
    %7:ep = PHI %4, %bb.1, %10, %bb.3
    %100:edc = PHI %3, %bb.1, %102, %bb.3
    ST_dms_sts_idx_imm %6, %7, 0 :: (store (s32))
    %101:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %100, %subreg.sub_dim_count
    %10:ep, %102:edc = PADDA_2D %7, %101
    %13:er = nuw nsw ADD_add_r_ri killed %6, 1, implicit-def $srcarry
    %19:er = EQ %5, %13
    PseudoJNZ killed %19, %bb.2
    PseudoJ_jump_imm %bb.3
...

# PADDA_2D conditionally followed by another PADDA_2D using the incremented
# counter. We'd like to see the two PADDA_2D use the same d0 register.
---
name:            test_padd_conditional
alignment:       16
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: test_padd_conditional
  ; CHECK: bb.0.entry (align 16):
  ; CHECK-NEXT:   successors: %bb.2(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT:   liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   JNZ killed renamable $r4, %bb.2
  ; CHECK-NEXT:   $m0 = MOV_mv_scl killed $r0
  ; CHECK-NEXT:   $dn0 = MOV_mv_scl killed $r1
  ; CHECK-NEXT:   $dj0 = MOV_mv_scl killed $r2
  ; CHECK-NEXT:   $dc0 = MOV_mv_scl killed $r3
  ; CHECK-NEXT:   $p0, $dc0 = PADDA_2D killed $p0, $d0
  ; CHECK-NEXT:   DelayedSchedBarrier
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $d0:0x0000000000000870, $dc0, $dj0, $dn0, $m0, $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $p0, $dc0 = PADDA_2D killed $p0, killed $d0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2 (align 16):
  ; CHECK-NEXT:   liveins: $dc0, $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   RET implicit $lr
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   DelayedSchedBarrier implicit killed renamable $dc0, implicit killed renamable $p0
  bb.0.entry:
    liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5

    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:ep = COPY killed $p0
    %5:er = COPY killed $r4
    %100:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count
    %101:ep, %102:edc = PADDA_2D %4, %100
    PseudoJNZ killed %5, %bb.2
  bb.1:
    %200:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %102, %subreg.sub_dim_count
    %201:ep, %202:edc = PADDA_2D %101, %200
  bb.2:
    %10:edc = PHI %202, %bb.1, %102, %bb.0
    %11:ep = PHI %201, %bb.1, %101, %bb.0
    PseudoRET implicit $lr, implicit %10, implicit %11
...

# Diamond pattern where one branch uses the incremented counter from the
# dominating PADDA_2D, and the other ones uses a value coming from r5.
# What we want to see is a conditional copy from r5 to dc0.
---
name:            test_padd_diamond
alignment:       16
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: test_padd_diamond
  ; CHECK: bb.0.entry (align 16):
  ; CHECK-NEXT:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT:   liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   JZ killed renamable $r4, %bb.2
  ; CHECK-NEXT:   $m0 = MOV_mv_scl killed $r0
  ; CHECK-NEXT:   $dn0 = MOV_mv_scl killed $r1
  ; CHECK-NEXT:   $dj0 = MOV_mv_scl killed $r2
  ; CHECK-NEXT:   $dc0 = MOV_mv_scl killed $r3
  ; CHECK-NEXT:   $p0, $dc0 = PADDA_2D killed $p0, $d0
  ; CHECK-NEXT:   DelayedSchedBarrier
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $d0:0x0000000000000860, $dj0, $dn0, $m0, $p0, $r5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $dc0 = MOV_mv_scl killed $r5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2 (align 16):
  ; CHECK-NEXT:   liveins: $p0, $d0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   RET implicit $lr
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   $p0, $dc0 = PADDA_2D killed $p0, killed $d0
  ; CHECK-NEXT:   DelayedSchedBarrier implicit killed renamable $dc0, implicit killed renamable $p0
  bb.0.entry:
    liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5

    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:ep = COPY killed $p0
    %5:er = COPY killed $r4
    %6:edc = COPY $r5
    %100:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count
    %101:ep, %102:edc = PADDA_2D %4, %100
    PseudoJNZ killed %5, %bb.2
  bb.1:
    %200:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %102, %subreg.sub_dim_count
    %201:ep, %202:edc = PADDA_2D %101, %200
    PseudoJ_jump_imm %bb.3
  bb.2:
    %300:ed = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %6, %subreg.sub_dim_count
    %301:ep, %302:edc = PADDA_2D %101, %300
  bb.3:
    %10:edc = PHI %202, %bb.1, %302, %bb.2
    %11:ep = PHI %201, %bb.1, %301, %bb.2
    PseudoRET implicit $lr, implicit %10, implicit %11
...

---
name:            test_padd_phi_source
alignment:       16
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: test_padd_phi_source
  ; CHECK: bb.0.entry (align 16):
  ; CHECK-NEXT:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT:   liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   JZ killed renamable $r5, %bb.2
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   DelayedSchedBarrier
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $p0, $r0, $r1, $r2, $r4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $r3 = MOV_mv_scl killed $r4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2 (align 16):
  ; CHECK-NEXT:   liveins: $p0, $r0, $r1, $r2, $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   RET implicit $lr
  ; CHECK-NEXT:   $m0 = MOV_mv_scl killed $r0
  ; CHECK-NEXT:   $dn0 = MOV_mv_scl killed $r1
  ; CHECK-NEXT:   $dj0 = MOV_mv_scl killed $r2
  ; CHECK-NEXT:   $dc0 = MOV_mv_scl killed $r3
  ; CHECK-NEXT:   $p0, $dc0 = PADDA_2D killed $p0, killed $d0
  ; CHECK-NEXT:   DelayedSchedBarrier implicit killed renamable $p0, implicit killed renamable $dc0
  bb.0.entry:
    successors: %bb.2(0x40000000), %bb.1(0x40000000)
    liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5
    %0:er = COPY $r0
    %1:er = COPY $r1
    %2:er = COPY $r2
    %3:er = COPY $r3
    %4:er = COPY $r4
    %5:er = COPY $r5
    %10:ep_as_32bit = COPY $p0
    PseudoJNZ %5, %bb.2
  bb.1:
    successors: %bb.3(0x80000000)
    %11:er = COPY %3
    PseudoJ_jump_imm %bb.3
  bb.2:
    successors: %bb.3(0x80000000)
    %11:er = COPY %4
  bb.3:
    undef %9.sub_mod:ed = COPY %0
    %9.sub_dim_size:ed = COPY %1
    %9.sub_dim_stride:ed = COPY %2
    %9.sub_dim_count:ed = COPY %11
    %10:ep_as_32bit, %9.sub_dim_count:ed = PADDA_2D %10, %9
    PseudoRET implicit $lr, implicit %10, implicit %9.sub_dim_count
...
