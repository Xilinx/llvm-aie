# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates

# RUN: llc --start-before=greedy --stop-after=virtregrewriter --mtriple=aie2 -o - %s | FileCheck %s

# This verifies that the LiveDebugVariables analysis is preserved across
# multiple runs of the greedy RA, and that the DBG_VALUE instructions are
# updated as expected with physical registers.

# The MIR is obtained by compiling the snippet below and stopping before greedy.
#    void *padd_2d(void *a, int off, int size1, addr_t &count1, int inc1) {
#      return add_2d_byte(a, off, size1, count1, inc1);
#    }

# Note that the connection to source locations is already lost after ISel, where
# the four input parameters are combined into a single "ed" register.


--- |
  source_filename = "t2.cc"
  target datalayout = "e-m:e-p:20:32-i1:8:32-i8:8:32-i16:16:32-i32:32:32-f32:32:32-i64:32-f64:32-a:0:32-n32"
  target triple = "aie2"

  define dso_local ptr @padd_2d(ptr %a, i32 noundef %off, i32 noundef %size1, ptr nocapture nonnull align 4 dereferenceable(4) %count1, i32 noundef %inc1) local_unnamed_addr #0 !dbg !9 {
  entry:
    tail call void @llvm.dbg.value(metadata ptr %a, metadata !19, metadata !DIExpression(DW_OP_LLVM_fragment, 0, 20)), !dbg !24
    tail call void @llvm.dbg.value(metadata i32 %off, metadata !20, metadata !DIExpression()), !dbg !24
    tail call void @llvm.dbg.value(metadata i32 %size1, metadata !21, metadata !DIExpression()), !dbg !24
    tail call void @llvm.dbg.value(metadata ptr %count1, metadata !22, metadata !DIExpression(DW_OP_LLVM_fragment, 0, 20)), !dbg !24
    tail call void @llvm.dbg.value(metadata i32 %inc1, metadata !23, metadata !DIExpression()), !dbg !24
    %0 = trunc i32 %off to i20, !dbg !25
    %1 = trunc i32 %inc1 to i20, !dbg !25
    %2 = trunc i32 %size1 to i20, !dbg !25
    %3 = load i32, ptr %count1, align 4, !dbg !25, !tbaa !26
    %4 = trunc i32 %3 to i20, !dbg !25
    %5 = tail call { ptr, i20 } @llvm.aie2.add.2d(ptr %a, i20 %0, i20 %1, i20 %2, i20 %4), !dbg !25
    %6 = extractvalue { ptr, i20 } %5, 1, !dbg !25
    %7 = zext i20 %6 to i32, !dbg !25
    store i32 %7, ptr %count1, align 4, !dbg !25
    %8 = extractvalue { ptr, i20 } %5, 0, !dbg !25
    ret ptr %8, !dbg !30
  }

  declare { ptr, i20 } @llvm.aie2.add.2d(ptr, i20, i20, i20, i20) #1

  declare void @llvm.dbg.value(metadata, metadata, metadata) #2

  attributes #0 = { mustprogress nofree nosync nounwind memory(argmem: readwrite) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
  attributes #1 = { nounwind memory(none) }
  attributes #2 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }

  !llvm.dbg.cu = !{!0}
  !llvm.module.flags = !{!4, !5, !6, !7}
  !llvm.ident = !{!8}

  !0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: "clang version 18.0.0git", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, retainedTypes: !2, splitDebugInlining: false, nameTableKind: None)
  !1 = !DIFile(filename: "t2.cc", directory: "llvm-aie")
  !2 = !{!3}
  !3 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: null, size: 32)
  !4 = !{i32 7, !"Dwarf Version", i32 4}
  !5 = !{i32 2, !"Debug Info Version", i32 3}
  !6 = !{i32 1, !"wchar_size", i32 4}
  !7 = !{i32 7, !"debug-info-assignment-tracking", i1 true}
  !8 = !{!"clang version 18.0.0git"}
  !9 = distinct !DISubprogram(name: "padd_2d", linkageName: "padd_2d", scope: !1, file: !1, line: 1, type: !10, scopeLine: 1, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !18)
  !10 = !DISubroutineType(types: !11)
  !11 = !{!3, !3, !12, !12, !13, !12}
  !12 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
  !13 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !14, size: 32)
  !14 = !DIDerivedType(tag: DW_TAG_typedef, name: "addr_t", file: !15, line: 222, baseType: !16)
  !15 = !DIFile(filename: "build/lib/clang/18/include/aiebase_typedefs.h", directory: "llvm-aie")
  !16 = !DIDerivedType(tag: DW_TAG_typedef, name: "int32_t", file: !17, line: 193, baseType: !12)
  !17 = !DIFile(filename: "build/lib/clang/18/include/stdint.h", directory: "llvm-aie")
  !18 = !{!19, !20, !21, !22, !23}
  !19 = !DILocalVariable(name: "a", arg: 1, scope: !9, file: !1, line: 1, type: !3)
  !20 = !DILocalVariable(name: "off", arg: 2, scope: !9, file: !1, line: 1, type: !12)
  !21 = !DILocalVariable(name: "size1", arg: 3, scope: !9, file: !1, line: 1, type: !12)
  !22 = !DILocalVariable(name: "count1", arg: 4, scope: !9, file: !1, line: 1, type: !13)
  !23 = !DILocalVariable(name: "inc1", arg: 5, scope: !9, file: !1, line: 1, type: !12)
  !24 = !DILocation(line: 0, scope: !9)
  !25 = !DILocation(line: 2, column: 10, scope: !9)
  !26 = !{!27, !27, i64 0}
  !27 = !{!"int", !28, i64 0}
  !28 = !{!"omnipotent char", !29, i64 0}
  !29 = !{!"Simple C++ TBAA"}
  !30 = !DILocation(line: 2, column: 3, scope: !9)

...
---
name:            padd_2d
alignment:       16
tracksRegLiveness: true
body:             |
  bb.0.entry:
    liveins: $p1, $p2, $r0, $r1, $r2

    ; CHECK-LABEL: name: padd_2d
    ; CHECK: liveins: $p1, $p2, $r0, $r1, $r2
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: DBG_VALUE $noreg, $noreg, !19, !DIExpression(DW_OP_LLVM_fragment, 0, 20), debug-location !24
    ; CHECK-NEXT: DBG_VALUE $r0, $noreg, !20, !DIExpression(), debug-location !24
    ; CHECK-NEXT: DBG_VALUE $r1, $noreg, !21, !DIExpression(), debug-location !24
    ; CHECK-NEXT: DBG_VALUE $p2, $noreg, !22, !DIExpression(DW_OP_LLVM_fragment, 0, 20), debug-location !24
    ; CHECK-NEXT: DBG_VALUE $r2, $noreg, !23, !DIExpression(), debug-location !24
    ; CHECK-NEXT: renamable $m0 = COPY killed renamable $r0, debug-location !25
    ; CHECK-NEXT: DBG_VALUE $noreg, $noreg, !20, !DIExpression(), debug-location !24
    ; CHECK-NEXT: renamable $dj0 = COPY killed renamable $r2, debug-location !25
    ; CHECK-NEXT: DBG_VALUE $noreg, $noreg, !23, !DIExpression(), debug-location !24
    ; CHECK-NEXT: renamable $dn0 = COPY killed renamable $r1, debug-location !25
    ; CHECK-NEXT: DBG_VALUE $noreg, $noreg, !21, !DIExpression(), debug-location !24
    ; CHECK-NEXT: renamable $dc0 = LDA_dms_lda_idx_imm renamable $p2, 0, debug-location !25 :: (dereferenceable load (s20) from %ir.count1, align 4, !tbaa !26)
    ; CHECK-NEXT: renamable $p0 = COPY $p1
    ; CHECK-NEXT: $p0, $dc0 = PADDA_2D_split killed $p0, killed $m0, killed $dn0, killed $dj0, killed $dc0, debug-location !25
    ; CHECK-NEXT: renamable $r0 = COPY killed renamable $dc0, debug-location !25
    ; CHECK-NEXT: ST_dms_sts_idx_imm killed renamable $r0, killed renamable $p2, 0, debug-location !25 :: (store (s32) into %ir.count1)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit $p0, debug-location !30
    %2:er = COPY $r0
    %3:er = COPY $r1
    %4:ep = COPY $p2
    %5:er = COPY $r2
    DBG_VALUE %11, $noreg, !19, !DIExpression(DW_OP_LLVM_fragment, 0, 20), debug-location !24
    DBG_VALUE %2, $noreg, !20, !DIExpression(), debug-location !24
    DBG_VALUE %3, $noreg, !21, !DIExpression(), debug-location !24
    DBG_VALUE %4, $noreg, !22, !DIExpression(DW_OP_LLVM_fragment, 0, 20), debug-location !24
    DBG_VALUE %5, $noreg, !23, !DIExpression(), debug-location !24
    undef %14.sub_mod:ed = COPY %2, debug-location !25
    %14.sub_dim_stride:ed = COPY %5, debug-location !25
    %14.sub_dim_size:ed = COPY %3, debug-location !25
    %14.sub_dim_count:ed = LDA_dms_lda_idx_imm %4, 0, debug-location !25 :: (dereferenceable load (s20) from %ir.count1, align 4, !tbaa !26)
    %11:ep_as_32bit = COPY $p1
    %11:ep_as_32bit, %14.sub_dim_count:ed = PADDA_2D_split %11, %14.sub_mod, %14.sub_dim_size, %14.sub_dim_stride, %14.sub_dim_count, debug-location !25
    %13:er = COPY %14.sub_dim_count, debug-location !25
    ST_dms_sts_idx_imm %13, %4, 0, debug-location !25 :: (store (s32) into %ir.count1)
    $p0 = COPY %11, debug-location !30
    PseudoRET implicit $lr, implicit killed $p0, debug-location !30

...
