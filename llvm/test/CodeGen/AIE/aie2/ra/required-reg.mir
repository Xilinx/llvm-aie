# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates

# RUN: llc -mtriple=aie2 -verify-machineinstrs --run-pass=greedy,virtregrewriter --require-preferred-registers %s -o - | FileCheck %s

# We turn preferred registers into required ones using --require-preferred-registers.
# Here we make sure that those choices are enforced even if they induce spills.
# See preferred-reg.mir as well.

---
name:            test_force_r13
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
registers:
  - { id: 0, class: er, preferred-register: '$r13' }
  - { id: 1, class: er, preferred-register: '' }
body:             |
  bb.0.entry:
    liveins: $p0
    ; CHECK-LABEL: name: test_force_r13
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: renamable $r13 = LDA_dms_lda_idx_imm $p0, 0
    ; CHECK-NEXT: ST_dms_spill killed renamable $r13, %stack.0, implicit $sp :: (store (s32) into %stack.0)
    ; CHECK-NEXT: renamable $r0 = LDA_dms_lda_idx_imm $p0, 4
    ; CHECK-NEXT: renamable $r13 = LDA_dms_spill %stack.0, implicit $sp :: (load (s32) from %stack.0)
    ; CHECK-NEXT: $r13 = MUL_mul_r_rr killed renamable $r13, killed renamable $r0
    ; CHECK-NEXT: renamable $r13 = LDA_dms_spill %stack.0, implicit $sp :: (load (s32) from %stack.0)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $r13
    %0:er = LDA_dms_lda_idx_imm $p0, 0
    %1:er = LDA_dms_lda_idx_imm $p0, 4
    $r13 = MUL_mul_r_rr %0, %1
    PseudoRET implicit $lr, implicit %0
...

---
name:            test_force_d3
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
registers:
  - { id: 0, class: ep, preferred-register: '' }
  - { id: 1, class: ed, preferred-register: '$d3' }
body:             |
  bb.0.entry:
    liveins: $p0, $d1
    ; CHECK-LABEL: name: test_force_d3
    ; CHECK: liveins: $d1, $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: ST_D_SPILL $d1, %stack.0, implicit $sp :: (store (s128) into %stack.0, align 4)
    ; CHECK-NEXT: renamable $d3 = LDA_D_SPILL %stack.0, implicit $sp :: (load (s128) from %stack.0, align 4)
    ; CHECK-NEXT: dead $p0, $dc3 = PADDA_2D_split killed $p0, $m3, $dn3, $dj3, $dc3
    ; CHECK-NEXT: ST_D_SPILL killed renamable $d3, %stack.0, implicit $sp :: (store (s128) into %stack.0, align 4)
    ; CHECK-NEXT: $d3 = COPY $d1
    ; CHECK-NEXT: renamable $d3 = LDA_D_SPILL %stack.0, implicit $sp :: (load (s128) from %stack.0, align 4)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $dc3
    %0:ep = COPY $p0
    %1:ed = COPY $d1
    %0:ep, %1.sub_dim_count:ed = PADDA_2D_split %0, %1.sub_mod, %1.sub_dim_size, %1.sub_dim_stride, %1.sub_dim_count
    $d3 = COPY $d1
    PseudoRET implicit $lr, implicit %1.sub_dim_count
...

# Due to phys reg copies, %0 really wants to go to $m4, and %10/11/12 really
# want to go to $m0. This is a typicaly case where "hint recoloring" changes
# the assignments to limit the number of broken hints. Make sure this does
# not happen here as %0 is REQUIRED to go to $m0.
---
name:            avoid_hint_recoloring
tracksRegLiveness: true
registers:
  - { id: 0, class: em, preferred-register: '$m0' }
  - { id: 1, class: edn, preferred-register: '$dn0' }
  - { id: 2, class: edj, preferred-register: '$dj0' }
  - { id: 3, class: edc, preferred-register: '$dc0' }
body:             |
  bb.1.entry:
    liveins: $p0, $m0, $m4

    ; CHECK-LABEL: name: avoid_hint_recoloring
    ; CHECK: liveins: $m0, $m4, $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: renamable $dn1 = COPY killed renamable $m0
    ; CHECK-NEXT: ST_dms_spill $m4, %stack.0, implicit $sp :: (store (s32) into %stack.0)
    ; CHECK-NEXT: renamable $dn0 = COPY $m4
    ; CHECK-NEXT: renamable $dj0 = COPY $m4
    ; CHECK-NEXT: renamable $dc0 = COPY $m4
    ; CHECK-NEXT: renamable $m0 = LDA_dms_spill %stack.0, implicit $sp :: (load (s32) from %stack.0)
    ; CHECK-NEXT: $p0, dead $dc0 = PADDA_2D_split killed $p0, killed $m0, killed $dn0, killed $dj0, killed $dc0
    ; CHECK-NEXT: renamable $m0 = COPY killed renamable $dn1
    ; CHECK-NEXT: dead renamable $p0 = PADDA_lda_ptr_inc_idx killed renamable $p0, renamable $m0
    ; CHECK-NEXT: $m4 = LDA_dms_spill %stack.0, implicit $sp :: (load (s32) from %stack.0)
    ; CHECK-NEXT: PseudoRET implicit $lr
    %10:em = COPY $m0
    %11:spill_edn_to_er = COPY %10
    %0:em = COPY $m4
    %1:edn = COPY $m4
    %2:edj = COPY $m4
    %3:edc = COPY $m4
    %20:ep = COPY $p0

    %20:ep, %3:edc = PADDA_2D_split %20, %0, %1, %2, %3
    %12:em = COPY %11
    %20:ep = PADDA_lda_ptr_inc_idx %20, %12

    $m0 = COPY %12
    $m4 = COPY %0
    PseudoRET implicit $lr
...
