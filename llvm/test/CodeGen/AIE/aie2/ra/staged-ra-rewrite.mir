# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates

# RUN: llc -O2 -mtriple=aie2 -verify-machineinstrs -run-pass=greedy,aie-superreg-rewrite %s -o - | FileCheck %s --check-prefix=VREGS

# Test rewriting of 2D/3D registers into independent vregs.

---
name:            test_split_2d_from_1d
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_from_1d
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 0
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm3:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:edn = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:em = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:edj = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT:   [[COPY5:%[0-9]+]]:edc = COPY [[LDA_dms_lda_idx_imm3]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY5:%[0-9]+]]:edc = PADDA_2D_split [[COPY]], [[COPY3]], [[COPY2]], [[COPY4]], [[COPY5]]
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY5]]
  bb.1.entry:
    liveins: $p0, $p1
    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %0:er = LDA_dms_lda_idx_imm %21, 0
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12
    undef %100.sub_dim_size:ed = COPY %1
    %100.sub_mod:ed = COPY %0
    %100.sub_dim_stride:ed = COPY %2
    %100.sub_dim_count:ed = COPY %3
  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count
...

# Similar to the test above but one of the subregs is used as a 32-bit compound
# operand. That particular subreg should use a _as_32bit class when rewritten as
# an independent vreg.
---
name:            test_split_2d_32bit_user
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_32bit_user
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 0
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm3:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:edn = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:em = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:edj = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT:   [[COPY5:%[0-9]+]]:edc_as_32bit = COPY [[LDA_dms_lda_idx_imm3]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   dead [[COPY:%[0-9]+]]:ep, [[COPY5:%[0-9]+]]:edc_as_32bit = PADDA_2D_split [[COPY]], [[COPY3]], [[COPY2]], [[COPY4]], [[COPY5]]
  ; VREGS-NEXT:   ST_dms_sts_idx_imm [[COPY5]], [[COPY1]], 12 :: (store (s20), align 4)
  bb.1.entry:
    liveins: $p0, $p1
    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %0:er = LDA_dms_lda_idx_imm %21, 0
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12
    undef %100.sub_dim_size:ed = COPY %1
    %100.sub_mod:ed = COPY %0
    %100.sub_dim_stride:ed = COPY %2
    %100.sub_dim_count:ed = COPY %3
  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    ST_dms_sts_idx_imm %100.sub_dim_count, %21, 12 :: (store (s20))
...

# Test splitting a 2D reg that is defined from 1D mods and a subreg of another 2D reg.
# This can happen quite often as the reg coaslescer is aggressively re-using sub-lanes.
---
name:            test_split_2d_from_other_2d
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_from_other_2d
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1, $d1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:ed = COPY $d1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:edn = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:em = COPY [[COPY2]].sub_mod
  ; VREGS-NEXT:   [[COPY5:%[0-9]+]]:edj = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY6:%[0-9]+]]:edc = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY6:%[0-9]+]]:edc = PADDA_2D_split [[COPY]], [[COPY4]], [[COPY3]], [[COPY5]], [[COPY6]]
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY6]]
  bb.1.entry:
    liveins: $p0, $p1, $d1
    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %22:ed = COPY $d1
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12
    undef %100.sub_dim_size:ed = COPY %1
    %100.sub_mod:ed = COPY %22.sub_mod
    %100.sub_dim_stride:ed = COPY %2
    %100.sub_dim_count:ed = COPY %3
  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count
...

# Test splitting a 2D reg that is defined from another 2D reg
---
name:            test_split_2d_from_full_copy
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_from_full_copy
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $d1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ed = COPY $d1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY1:%[0-9]+]].sub_dim_count:ed = PADDA_2D_split [[COPY]], [[COPY1]].sub_mod, [[COPY1]].sub_dim_size, [[COPY1]].sub_dim_stride, [[COPY1]].sub_dim_count
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY1]].sub_dim_count
  bb.1.entry:
    liveins: $p0, $d1
    %20:ep = COPY $p0
    %100:ed = COPY $d1
  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count
...

# Test splitting a 2D reg that has an undef lane
---
name:            test_split_2d_undef
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_undef
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:edn = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:edj = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:edc = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY4:%[0-9]+]]:edc = PADDA_2D_split [[COPY]], undef %9:em, [[COPY2]], [[COPY3]], [[COPY4]]
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY4]]
  bb.1.entry:
    liveins: $p0, $p1

    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12

    undef %100.sub_dim_size:ed = COPY %1
    %100.sub_dim_stride:ed = COPY %2
    %100.sub_dim_count:ed = COPY %3

  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, undef %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count
...

# Test splitting a 3D reg that's defined through 4 1D subregs, and 1 2D subreg.
# This is currently not split into independent vregs.
---
name:            test_split_3d_from_various
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_3d_from_various
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1, $m5, $dn5, $dj5, $dc5
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 0
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm3:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   undef [[COPY2:%[0-9]+]].sub_mod:ed = COPY $m5
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]].sub_dim_size:ed = COPY $dn5
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]].sub_dim_stride:ed = COPY $dj5
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]].sub_dim_count:ed = COPY $dc5
  ; VREGS-NEXT:   undef [[COPY3:%[0-9]+]].sub_dim_size:eds = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]].sub_mod:eds = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]].sub_dim_stride:eds = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]].sub_dim_count:eds = COPY [[LDA_dms_lda_idx_imm3]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]].sub_hi_dim:eds = COPY [[COPY2]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY3:%[0-9]+]].sub_dim_count:eds, [[COPY3:%[0-9]+]].sub_hi_dim_then_sub_dim_count:eds = PADDA_3D_split [[COPY]], [[COPY3]].sub_mod, [[COPY3]].sub_dim_size, [[COPY3]].sub_dim_stride, [[COPY3]].sub_dim_count, undef [[COPY3]].sub_hi_dim_then_sub_mod, [[COPY3]].sub_hi_dim_then_sub_dim_size, [[COPY3]].sub_hi_dim_then_sub_dim_stride, [[COPY3]].sub_hi_dim_then_sub_dim_count
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY3]].sub_dim_count, implicit [[COPY3]].sub_hi_dim_then_sub_dim_count
  bb.1.entry:
    successors: %bb.2
    liveins: $p0, $p1, $m5, $dn5, $dj5, $dc5

    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %0:er = LDA_dms_lda_idx_imm %21, 0
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12
    undef %4.sub_mod:ed = COPY $m5
    %4.sub_dim_size:ed = COPY $dn5
    %4.sub_dim_stride:ed = COPY $dj5
    %4.sub_dim_count:ed = COPY $dc5

    undef %100.sub_dim_size:eds = COPY %1
    %100.sub_mod:eds = COPY %0
    %100.sub_dim_stride:eds = COPY %2
    %100.sub_dim_count:eds = COPY %3
    %100.sub_hi_dim:eds = COPY %4


  bb.2:
    %20:ep, %100.sub_dim_count:eds, %100.sub_hi_dim_then_sub_dim_count:eds = PADDA_3D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count, undef %100.sub_hi_dim_then_sub_mod, %100.sub_hi_dim_then_sub_dim_size, %100.sub_hi_dim_then_sub_dim_stride, %100.sub_hi_dim_then_sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count, implicit %100.sub_hi_dim_then_sub_dim_count
...

# Test splitting a 3D reg that's defined through two 2D subregs.
# This is currently not split into independent vregs.
---
name:            test_split_3d_from_2d
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_3d_from_2d
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $d1, $d5
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ed = COPY $d1
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:ed = COPY $d5
  ; VREGS-NEXT:   undef [[COPY3:%[0-9]+]].sub_lo_dim:eds = COPY [[COPY1]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]].sub_hi_dim:eds = COPY [[COPY2]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY3:%[0-9]+]].sub_dim_count:eds, [[COPY3:%[0-9]+]].sub_hi_dim_then_sub_dim_count:eds = PADDA_3D_split [[COPY]], [[COPY3]].sub_mod, [[COPY3]].sub_dim_size, [[COPY3]].sub_dim_stride, [[COPY3]].sub_dim_count, undef [[COPY3]].sub_hi_dim_then_sub_mod, [[COPY3]].sub_hi_dim_then_sub_dim_size, [[COPY3]].sub_hi_dim_then_sub_dim_stride, [[COPY3]].sub_hi_dim_then_sub_dim_count
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY3]].sub_dim_count, implicit [[COPY3]].sub_hi_dim_then_sub_dim_count
  bb.1.entry:
    successors: %bb.2
    liveins: $p0, $d1, $d5

    %20:ep = COPY $p0
    %4:ed = COPY $d1
    %5:ed = COPY $d5
    undef %100.sub_lo_dim:eds = COPY %4
    %100.sub_hi_dim:eds = COPY %5

  bb.2:
    %20:ep, %100.sub_dim_count:eds, %100.sub_hi_dim_then_sub_dim_count:eds = PADDA_3D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count, undef %100.sub_hi_dim_then_sub_mod, %100.sub_hi_dim_then_sub_dim_size, %100.sub_hi_dim_then_sub_dim_stride, %100.sub_hi_dim_then_sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count, implicit %100.sub_hi_dim_then_sub_dim_count
...
