# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates

# RUN: llc -O2 -mtriple=aie2 -verify-machineinstrs -run-pass=greedy,aie-superreg-rewrite %s -o - | FileCheck %s --check-prefix=VREGS
# RUN: llc -O2 -mtriple=aie2 -verify-machineinstrs --aie-staged-ra -start-before=greedy -stop-after=virtregrewriter %s -o - \
# RUN:    | FileCheck %s --check-prefix=RA

# Test rewriting of 2D/3D registers into independent vregs.

---
name:            test_split_2d_from_1d
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_from_1d
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 0
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm3:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:edn = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:em = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:edj = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT:   [[COPY5:%[0-9]+]]:edc = COPY [[LDA_dms_lda_idx_imm3]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY5:%[0-9]+]]:edc = PADDA_2D_split [[COPY]], [[COPY3]], [[COPY2]], [[COPY4]], [[COPY5]]
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY5]]
  ;
  ; RA-LABEL: name: test_split_2d_from_1d
  ; RA: bb.0.entry:
  ; RA-NEXT:   successors: %bb.1(0x80000000)
  ; RA-NEXT:   liveins: $p0, $p1
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   renamable $r0 = LDA_dms_lda_idx_imm renamable $p1, 0
  ; RA-NEXT:   renamable $r1 = LDA_dms_lda_idx_imm renamable $p1, 4
  ; RA-NEXT:   renamable $r2 = LDA_dms_lda_idx_imm renamable $p1, 8
  ; RA-NEXT:   renamable $r3 = LDA_dms_lda_idx_imm killed renamable $p1, 12
  ; RA-NEXT:   renamable $dn0 = COPY killed renamable $r1
  ; RA-NEXT:   renamable $m0 = COPY killed renamable $r0
  ; RA-NEXT:   renamable $dj0 = COPY killed renamable $r2
  ; RA-NEXT:   renamable $dc0 = COPY killed renamable $r3
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: bb.1:
  ; RA-NEXT:   liveins: $dc0, $dj0, $dn0, $m0, $p0
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   $p0, $dc0 = PADDA_2D_split killed $p0, killed $m0, killed $dn0, killed $dj0, killed $dc0
  ; RA-NEXT:   PseudoRET implicit $lr, implicit killed renamable $p0, implicit killed renamable $dc0
  bb.1.entry:
    liveins: $p0, $p1
    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %0:er = LDA_dms_lda_idx_imm %21, 0
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12
    undef %100.sub_dim_size:ed = COPY %1
    %100.sub_mod:ed = COPY %0
    %100.sub_dim_stride:ed = COPY %2
    %100.sub_dim_count:ed = COPY %3
  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count
...

# Similar to the test above but one of the subregs is used as a 32-bit compound
# operand. That particular subreg should use a _as_32bit class when rewritten as
# an independent vreg.
---
name:            test_split_2d_32bit_user
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_32bit_user
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 0
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm3:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:edn = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:em = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:edj = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT:   [[COPY5:%[0-9]+]]:edc_as_32bit = COPY [[LDA_dms_lda_idx_imm3]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   dead [[COPY:%[0-9]+]]:ep, [[COPY5:%[0-9]+]]:edc_as_32bit = PADDA_2D_split [[COPY]], [[COPY3]], [[COPY2]], [[COPY4]], [[COPY5]]
  ; VREGS-NEXT:   ST_dms_sts_idx_imm [[COPY5]], [[COPY1]], 12 :: (store (s20), align 4)
  ;
  ; RA-LABEL: name: test_split_2d_32bit_user
  ; RA: bb.0.entry:
  ; RA-NEXT:   successors: %bb.1(0x80000000)
  ; RA-NEXT:   liveins: $p0, $p1
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   renamable $r0 = LDA_dms_lda_idx_imm renamable $p1, 0
  ; RA-NEXT:   renamable $r1 = LDA_dms_lda_idx_imm renamable $p1, 4
  ; RA-NEXT:   renamable $r2 = LDA_dms_lda_idx_imm renamable $p1, 8
  ; RA-NEXT:   renamable $r3 = LDA_dms_lda_idx_imm renamable $p1, 12
  ; RA-NEXT:   renamable $dn0 = COPY killed renamable $r1
  ; RA-NEXT:   renamable $m0 = COPY killed renamable $r0
  ; RA-NEXT:   renamable $dj0 = COPY killed renamable $r2
  ; RA-NEXT:   renamable $dc0 = COPY killed renamable $r3
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: bb.1:
  ; RA-NEXT:   liveins: $dc0, $dj0, $dn0, $m0, $p0, $p1
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   dead $p0, $dc0 = PADDA_2D_split killed $p0, killed $m0, killed $dn0, killed $dj0, killed $dc0
  ; RA-NEXT:   ST_dms_sts_idx_imm killed renamable $dc0, killed renamable $p1, 12 :: (store (s20), align 4)
  bb.1.entry:
    liveins: $p0, $p1
    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %0:er = LDA_dms_lda_idx_imm %21, 0
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12
    undef %100.sub_dim_size:ed = COPY %1
    %100.sub_mod:ed = COPY %0
    %100.sub_dim_stride:ed = COPY %2
    %100.sub_dim_count:ed = COPY %3
  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    ST_dms_sts_idx_imm %100.sub_dim_count, %21, 12 :: (store (s20))
...

# Test splitting a 2D reg that is defined from 1D mods and a subreg of another 2D reg.
# This can happen quite often as the reg coaslescer is aggressively re-using sub-lanes.
---
name:            test_split_2d_from_other_2d
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_from_other_2d
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1, $d1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:ed = COPY $d1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:edn = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:em = COPY [[COPY2]].sub_mod
  ; VREGS-NEXT:   [[COPY5:%[0-9]+]]:edj = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY6:%[0-9]+]]:edc = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY6:%[0-9]+]]:edc = PADDA_2D_split [[COPY]], [[COPY4]], [[COPY3]], [[COPY5]], [[COPY6]]
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY6]]
  ;
  ; RA-LABEL: name: test_split_2d_from_other_2d
  ; RA: bb.0.entry:
  ; RA-NEXT:   successors: %bb.1(0x80000000)
  ; RA-NEXT:   liveins: $d1, $p0, $p1
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   renamable $r0 = LDA_dms_lda_idx_imm renamable $p1, 4
  ; RA-NEXT:   renamable $r1 = LDA_dms_lda_idx_imm renamable $p1, 8
  ; RA-NEXT:   renamable $r2 = LDA_dms_lda_idx_imm killed renamable $p1, 12
  ; RA-NEXT:   renamable $dn1 = COPY killed renamable $r0
  ; RA-NEXT:   renamable $dj1 = COPY killed renamable $r1
  ; RA-NEXT:   renamable $dc1 = COPY killed renamable $r2
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: bb.1:
  ; RA-NEXT:   liveins: $dc1, $dj1, $dn1, $m1, $p0
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   $p0, $dc1 = PADDA_2D_split killed $p0, killed $m1, killed $dn1, killed $dj1, killed $dc1
  ; RA-NEXT:   PseudoRET implicit $lr, implicit killed renamable $p0, implicit killed renamable $dc1
  bb.1.entry:
    liveins: $p0, $p1, $d1
    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %22:ed = COPY $d1
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12
    undef %100.sub_dim_size:ed = COPY %1
    %100.sub_mod:ed = COPY %22.sub_mod
    %100.sub_dim_stride:ed = COPY %2
    %100.sub_dim_count:ed = COPY %3
  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count
...

# Test splitting a 2D reg that is defined from another 2D reg
# This is for testing purposes, we will not have copies from D and D_3D
# physical registers at this part of the flow, as these registers are not
# part of the calling convention.
---
name:            test_split_2d_from_full_copy
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_from_full_copy
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $d1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ed = COPY $d1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY1:%[0-9]+]].sub_dim_count:ed = PADDA_2D_split [[COPY]], [[COPY1]].sub_mod, [[COPY1]].sub_dim_size, [[COPY1]].sub_dim_stride, [[COPY1]].sub_dim_count
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY1]].sub_dim_count
  ;
  ; RA-LABEL: name: test_split_2d_from_full_copy
  ; RA: bb.0.entry:
  ; RA-NEXT:   successors: %bb.1(0x80000000)
  ; RA-NEXT:   liveins: $d1, $p0
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: bb.1:
  ; RA-NEXT:   liveins: $d1:0x0000000000000870, $p0
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   $p0, $dc1 = PADDA_2D_split killed $p0, $m1, $dn1, $dj1, $dc1
  ; RA-NEXT:   PseudoRET implicit $lr, implicit killed renamable $p0, implicit killed renamable $dc1
  bb.1.entry:
    liveins: $p0, $d1
    %20:ep = COPY $p0
    %100:ed = COPY $d1
  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count
...

# Test splitting a 2D reg that is defined from another 2D reg, the latter
# defined through 1D regs.
---
name:            test_split_2d_from_full_copy_def_by_1d
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_from_full_copy_def_by_1d
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $m1, $dn1, $dj1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:em = COPY $m1
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:edn = COPY $dn1
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:edj = COPY $dj1
  ; VREGS-NEXT:   [[MOV_PD_imm10_pseudo:%[0-9]+]]:edc = MOV_PD_imm10_pseudo 0
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:edc = COPY [[MOV_PD_imm10_pseudo]]
  ; VREGS-NEXT:   [[COPY5:%[0-9]+]]:edn = COPY [[COPY2]]
  ; VREGS-NEXT:   [[COPY6:%[0-9]+]]:edj = COPY [[COPY3]]
  ; VREGS-NEXT:   [[COPY7:%[0-9]+]]:em = COPY [[COPY1]]
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY4:%[0-9]+]]:edc = PADDA_2D_split [[COPY]], [[COPY7]], [[COPY5]], [[COPY6]], [[COPY4]]
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY4]]
  ;
  ; RA-LABEL: name: test_split_2d_from_full_copy_def_by_1d
  ; RA: bb.0.entry:
  ; RA-NEXT:   successors: %bb.1(0x80000000)
  ; RA-NEXT:   liveins: $dj1, $dn1, $m1, $p0
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   renamable $dc1 = MOV_PD_imm10_pseudo 0
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: bb.1:
  ; RA-NEXT:   liveins: $dc1, $dj1, $dn1, $m1, $p0
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   $p0, $dc1 = PADDA_2D_split killed $p0, killed $m1, killed $dn1, killed $dj1, killed $dc1
  ; RA-NEXT:   PseudoRET implicit $lr, implicit killed renamable $p0, implicit killed renamable $dc1
  bb.1.entry:
    liveins: $p0, $m1, $dn1, $dj1
    %20:ep = COPY $p0
    undef %21.sub_mod:ed = COPY $m1
    %21.sub_dim_size:ed = COPY $dn1
    %21.sub_dim_stride:ed = COPY $dj1
    %21.sub_dim_count:ed = MOV_PD_imm10_pseudo 0
  bb.2:
    %100:ed = COPY %21
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count
...

# Test splitting a 2D reg that has an undef lane
---
name:            test_split_2d_undef
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_undef
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:edn = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:edj = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:edc = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY4:%[0-9]+]]:edc = PADDA_2D_split [[COPY]], undef %9:em, [[COPY2]], [[COPY3]], [[COPY4]]
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY4]]
  ;
  ; RA-LABEL: name: test_split_2d_undef
  ; RA: bb.0.entry:
  ; RA-NEXT:   successors: %bb.1(0x80000000)
  ; RA-NEXT:   liveins: $p0, $p1
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   renamable $r0 = LDA_dms_lda_idx_imm renamable $p1, 4
  ; RA-NEXT:   renamable $r1 = LDA_dms_lda_idx_imm renamable $p1, 8
  ; RA-NEXT:   renamable $r2 = LDA_dms_lda_idx_imm killed renamable $p1, 12
  ; RA-NEXT:   renamable $dn0 = COPY killed renamable $r0
  ; RA-NEXT:   renamable $dj0 = COPY killed renamable $r1
  ; RA-NEXT:   renamable $dc0 = COPY killed renamable $r2
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: bb.1:
  ; RA-NEXT:   liveins: $dc0, $dj0, $dn0, $p0
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   $p0, $dc0 = PADDA_2D_split killed $p0, undef $m0, killed $dn0, killed $dj0, killed $dc0
  ; RA-NEXT:   PseudoRET implicit $lr, implicit killed renamable $p0, implicit killed renamable $dc0
  bb.1.entry:
    liveins: $p0, $p1

    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12

    undef %100.sub_dim_size:ed = COPY %1
    %100.sub_dim_stride:ed = COPY %2
    %100.sub_dim_count:ed = COPY %3

  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, undef %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count
...


# Similar to test_split_2d_undef above, but there is a full COPY to be rewritten
# and its source register is partially defined.
---
name:            test_split_2d_undef_through_copy
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_undef_through_copy
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:edn_as_32bit = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:edj_as_32bit = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:edc_as_32bit = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:edc = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:edn = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:edj = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY2:%[0-9]+]]:edc = PADDA_2D_split [[COPY]], undef %11:em, [[COPY3]], [[COPY4]], [[COPY2]]
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY2]]
  ;
  ; RA-LABEL: name: test_split_2d_undef_through_copy
  ; RA: bb.0.entry:
  ; RA-NEXT:   successors: %bb.1(0x80000000)
  ; RA-NEXT:   liveins: $p0, $p1
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   renamable $dn0 = LDA_dms_lda_idx_imm renamable $p1, 4
  ; RA-NEXT:   renamable $dj0 = LDA_dms_lda_idx_imm renamable $p1, 8
  ; RA-NEXT:   renamable $dc0 = LDA_dms_lda_idx_imm killed renamable $p1, 12
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: bb.1:
  ; RA-NEXT:   liveins: $dc0, $dj0, $dn0, $p0
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   $p0, $dc0 = PADDA_2D_split killed $p0, undef $m0, killed $dn0, killed $dj0, killed $dc0
  ; RA-NEXT:   PseudoRET implicit $lr, implicit killed renamable $p0, implicit killed renamable $dc0
  bb.1.entry:
    liveins: $p0, $p1

    %20:ep = COPY $p0
    %21:ep = COPY $p1
    undef %1.sub_dim_size:ed = LDA_dms_lda_idx_imm %21, 4
    %1.sub_dim_stride:ed = LDA_dms_lda_idx_imm %21, 8
    %1.sub_dim_count:ed = LDA_dms_lda_idx_imm %21, 12

  bb.2:
    %100:ed = COPY %1
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, undef %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count
...


# Test splitting a 3D reg that's defined through 4 1D subregs, and 1 2D subreg.
# This is currently not split into independent vregs.
---
name:            test_split_3d_from_various
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_3d_from_various
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1, $m5, $dn5, $dj5, $dc5
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 0
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm3:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   undef [[COPY2:%[0-9]+]].sub_mod:ed = COPY $m5
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]].sub_dim_size:ed = COPY $dn5
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]].sub_dim_stride:ed = COPY $dj5
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]].sub_dim_count:ed = COPY $dc5
  ; VREGS-NEXT:   undef [[COPY3:%[0-9]+]].sub_dim_size:eds = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]].sub_mod:eds = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]].sub_dim_stride:eds = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]].sub_dim_count:eds = COPY [[LDA_dms_lda_idx_imm3]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]].sub_hi_dim:eds = COPY [[COPY2]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY3:%[0-9]+]].sub_dim_count:eds, [[COPY3:%[0-9]+]].sub_hi_dim_then_sub_dim_count:eds = PADDA_3D_split [[COPY]], [[COPY3]].sub_mod, [[COPY3]].sub_dim_size, [[COPY3]].sub_dim_stride, [[COPY3]].sub_dim_count, undef [[COPY3]].sub_hi_dim_then_sub_mod, [[COPY3]].sub_hi_dim_then_sub_dim_size, [[COPY3]].sub_hi_dim_then_sub_dim_stride, [[COPY3]].sub_hi_dim_then_sub_dim_count
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY3]].sub_dim_count, implicit [[COPY3]].sub_hi_dim_then_sub_dim_count
  ;
  ; RA-LABEL: name: test_split_3d_from_various
  ; RA: bb.0.entry:
  ; RA-NEXT:   successors: %bb.1(0x80000000)
  ; RA-NEXT:   liveins: $dc5, $dj5, $dn5, $m5, $p0, $p1
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   renamable $r0 = LDA_dms_lda_idx_imm renamable $p1, 0
  ; RA-NEXT:   renamable $r1 = LDA_dms_lda_idx_imm renamable $p1, 4
  ; RA-NEXT:   renamable $r2 = LDA_dms_lda_idx_imm renamable $p1, 8
  ; RA-NEXT:   renamable $r3 = LDA_dms_lda_idx_imm killed renamable $p1, 12
  ; RA-NEXT:   renamable $dn0 = COPY killed renamable $r1
  ; RA-NEXT:   renamable $m0 = COPY killed renamable $r0
  ; RA-NEXT:   renamable $dj0 = COPY killed renamable $r2
  ; RA-NEXT:   renamable $dc0 = COPY killed renamable $r3
  ; RA-NEXT:   renamable $d4 = COPY killed renamable $d5
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: bb.1:
  ; RA-NEXT:   liveins: $p0, $d0_3d:0x000000000001C870
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   $p0, $dc0, $dc4 = PADDA_3D_split killed $p0, $m0, $dn0, $dj0, $dc0, undef $m4, $dn4, $dj4, $dc4
  ; RA-NEXT:   PseudoRET implicit $lr, implicit killed renamable $p0, implicit killed renamable $dc0, implicit renamable $dc4
  bb.1.entry:
    successors: %bb.2
    liveins: $p0, $p1, $m5, $dn5, $dj5, $dc5

    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %0:er = LDA_dms_lda_idx_imm %21, 0
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12
    undef %4.sub_mod:ed = COPY $m5
    %4.sub_dim_size:ed = COPY $dn5
    %4.sub_dim_stride:ed = COPY $dj5
    %4.sub_dim_count:ed = COPY $dc5

    undef %100.sub_dim_size:eds = COPY %1
    %100.sub_mod:eds = COPY %0
    %100.sub_dim_stride:eds = COPY %2
    %100.sub_dim_count:eds = COPY %3
    %100.sub_hi_dim:eds = COPY %4


  bb.2:
    %20:ep, %100.sub_dim_count:eds, %100.sub_hi_dim_then_sub_dim_count:eds = PADDA_3D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count, undef %100.sub_hi_dim_then_sub_mod, %100.sub_hi_dim_then_sub_dim_size, %100.sub_hi_dim_then_sub_dim_stride, %100.sub_hi_dim_then_sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count, implicit %100.sub_hi_dim_then_sub_dim_count
...

# Test splitting a 3D reg that's defined through two 2D subregs.
# This is currently not split into independent vregs.
---
name:            test_split_3d_from_2d
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_3d_from_2d
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $d1, $d5
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ed = COPY $d1
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:ed = COPY $d5
  ; VREGS-NEXT:   undef [[COPY3:%[0-9]+]].sub_lo_dim:eds = COPY [[COPY1]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]].sub_hi_dim:eds = COPY [[COPY2]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY3:%[0-9]+]].sub_dim_count:eds, [[COPY3:%[0-9]+]].sub_hi_dim_then_sub_dim_count:eds = PADDA_3D_split [[COPY]], [[COPY3]].sub_mod, [[COPY3]].sub_dim_size, [[COPY3]].sub_dim_stride, [[COPY3]].sub_dim_count, undef [[COPY3]].sub_hi_dim_then_sub_mod, [[COPY3]].sub_hi_dim_then_sub_dim_size, [[COPY3]].sub_hi_dim_then_sub_dim_stride, [[COPY3]].sub_hi_dim_then_sub_dim_count
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]], implicit [[COPY3]].sub_dim_count, implicit [[COPY3]].sub_hi_dim_then_sub_dim_count
  ;
  ; RA-LABEL: name: test_split_3d_from_2d
  ; RA: bb.0.entry:
  ; RA-NEXT:   successors: %bb.1(0x80000000)
  ; RA-NEXT:   liveins: $d1, $d5, $p0
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   renamable $d0 = COPY killed renamable $d1
  ; RA-NEXT:   renamable $d4 = COPY killed renamable $d5
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: bb.1:
  ; RA-NEXT:   liveins: $p0, $d0_3d:0x000000000001C870
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   $p0, $dc0, $dc4 = PADDA_3D_split killed $p0, $m0, $dn0, $dj0, $dc0, undef $m4, $dn4, $dj4, $dc4
  ; RA-NEXT:   PseudoRET implicit $lr, implicit killed renamable $p0, implicit killed renamable $dc0, implicit renamable $dc4
  bb.1.entry:
    successors: %bb.2
    liveins: $p0, $d1, $d5

    %20:ep = COPY $p0
    %4:ed = COPY $d1
    %5:ed = COPY $d5
    undef %100.sub_lo_dim:eds = COPY %4
    %100.sub_hi_dim:eds = COPY %5

  bb.2:
    %20:ep, %100.sub_dim_count:eds, %100.sub_hi_dim_then_sub_dim_count:eds = PADDA_3D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count, undef %100.sub_hi_dim_then_sub_mod, %100.sub_hi_dim_then_sub_dim_size, %100.sub_hi_dim_then_sub_dim_stride, %100.sub_hi_dim_then_sub_dim_count
    PseudoRET implicit $lr, implicit %20, implicit %100.sub_dim_count, implicit %100.sub_hi_dim_then_sub_dim_count
...

# %100.sub_dim_count:ed has two independent components, the first one use in PADDA_2D,
# and the second by PADDB_2D. This is fine as long as this is a subreg, but once it
# is rewritten as its own vreg, one needs to split that vreg further into two
# intervals/vregs: one for each component.
---
name:            test_split_2d_multi_components
tracksRegLiveness: true
body:             |
  ; VREGS-LABEL: name: test_split_2d_multi_components
  ; VREGS: bb.0.entry:
  ; VREGS-NEXT:   successors: %bb.1(0x80000000)
  ; VREGS-NEXT:   liveins: $p0, $p1
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep = COPY $p0
  ; VREGS-NEXT:   [[COPY1:%[0-9]+]]:ep = COPY $p1
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 0
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm1:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 4
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm2:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 8
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm3:%[0-9]+]]:er = LDA_dms_lda_idx_imm [[COPY1]], 12
  ; VREGS-NEXT:   [[COPY2:%[0-9]+]]:edn = COPY [[LDA_dms_lda_idx_imm1]]
  ; VREGS-NEXT:   [[COPY3:%[0-9]+]]:em = COPY [[LDA_dms_lda_idx_imm]]
  ; VREGS-NEXT:   [[COPY4:%[0-9]+]]:edj = COPY [[LDA_dms_lda_idx_imm2]]
  ; VREGS-NEXT:   [[COPY5:%[0-9]+]]:edc_as_32bit = COPY [[LDA_dms_lda_idx_imm3]]
  ; VREGS-NEXT: {{  $}}
  ; VREGS-NEXT: bb.1:
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[COPY5:%[0-9]+]]:edc_as_32bit = PADDA_2D_split [[COPY]], [[COPY3]], [[COPY2]], [[COPY4]], [[COPY5]]
  ; VREGS-NEXT:   ST_dms_sts_idx_imm [[COPY5]], [[COPY1]], 12 :: (store (s20), align 4)
  ; VREGS-NEXT:   [[LDA_dms_lda_idx_imm4:%[0-9]+]]:edc_as_32bit = LDA_dms_lda_idx_imm [[COPY1]], 16
  ; VREGS-NEXT:   [[COPY:%[0-9]+]]:ep, [[LDA_dms_lda_idx_imm4:%[0-9]+]]:edc_as_32bit = PADDB_2D_split [[COPY]], [[COPY3]], [[COPY2]], [[COPY4]], [[LDA_dms_lda_idx_imm4]]
  ; VREGS-NEXT:   ST_dms_sts_idx_imm [[LDA_dms_lda_idx_imm4]], [[COPY1]], 16 :: (store (s20), align 4)
  ; VREGS-NEXT:   PseudoRET implicit $lr, implicit [[COPY]]
  ;
  ; RA-LABEL: name: test_split_2d_multi_components
  ; RA: bb.0.entry:
  ; RA-NEXT:   successors: %bb.1(0x80000000)
  ; RA-NEXT:   liveins: $p0, $p1
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   renamable $r0 = LDA_dms_lda_idx_imm renamable $p1, 0
  ; RA-NEXT:   renamable $r1 = LDA_dms_lda_idx_imm renamable $p1, 4
  ; RA-NEXT:   renamable $r2 = LDA_dms_lda_idx_imm renamable $p1, 8
  ; RA-NEXT:   renamable $r3 = LDA_dms_lda_idx_imm renamable $p1, 12
  ; RA-NEXT:   renamable $dn0 = COPY killed renamable $r1
  ; RA-NEXT:   renamable $m0 = COPY killed renamable $r0
  ; RA-NEXT:   renamable $dj0 = COPY killed renamable $r2
  ; RA-NEXT:   renamable $dc0 = COPY killed renamable $r3
  ; RA-NEXT: {{  $}}
  ; RA-NEXT: bb.1:
  ; RA-NEXT:   liveins: $dc0, $dj0, $dn0, $m0, $p0, $p1
  ; RA-NEXT: {{  $}}
  ; RA-NEXT:   $p0, $dc0 = PADDA_2D_split killed $p0, $m0, $dn0, $dj0, killed $dc0
  ; RA-NEXT:   ST_dms_sts_idx_imm killed renamable $dc0, renamable $p1, 12 :: (store (s20), align 4)
  ; RA-NEXT:   renamable $dc0 = LDA_dms_lda_idx_imm renamable $p1, 16
  ; RA-NEXT:   $p0, $dc0 = PADDB_2D_split killed $p0, killed $m0, killed $dn0, killed $dj0, killed $dc0
  ; RA-NEXT:   ST_dms_sts_idx_imm killed renamable $dc0, killed renamable $p1, 16 :: (store (s20), align 4)
  ; RA-NEXT:   PseudoRET implicit $lr, implicit killed renamable $p0
  bb.1.entry:
    liveins: $p0, $p1
    %20:ep = COPY $p0
    %21:ep = COPY $p1
    %0:er = LDA_dms_lda_idx_imm %21, 0
    %1:er = LDA_dms_lda_idx_imm %21, 4
    %2:er = LDA_dms_lda_idx_imm %21, 8
    %3:er = LDA_dms_lda_idx_imm %21, 12
    undef %100.sub_dim_size:ed = COPY %1
    %100.sub_mod:ed = COPY %0
    %100.sub_dim_stride:ed = COPY %2
    %100.sub_dim_count:ed = COPY %3
  bb.2:
    %20:ep, %100.sub_dim_count:ed = PADDA_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    ST_dms_sts_idx_imm %100.sub_dim_count, %21, 12 :: (store (s20))
    %100.sub_dim_count:ed = LDA_dms_lda_idx_imm %21, 16
    %20:ep, %100.sub_dim_count:ed = PADDB_2D_split %20, %100.sub_mod, %100.sub_dim_size, %100.sub_dim_stride, %100.sub_dim_count
    ST_dms_sts_idx_imm %100.sub_dim_count, %21, 16 :: (store (s20))
    PseudoRET implicit $lr, implicit %20
...
