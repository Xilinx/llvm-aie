# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -O2 -mtriple=aie2 --issue-limit=1 -verify-machineinstrs \
# RUN:    -start-before=phi-node-elimination -stop-before=aie-finalize-mi-bundles \
# RUN:    %s -o - | FileCheck %s
# RUN: llc -O0 -mtriple=aie2 --issue-limit=1 -verify-machineinstrs \
# RUN:    -start-before=phi-node-elimination -stop-before=aie-finalize-mi-bundles %s -o -

---
name:            test_2_padd
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.0.entry:
    liveins: $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $p0

    ; CHECK-LABEL: name: test_2_padd
    ; CHECK: liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $m0 = MOV_mv_scl killed $r0
    ; CHECK-NEXT: $dn0 = MOV_mv_scl killed $r1
    ; CHECK-NEXT: $dj0 = MOV_mv_scl killed $r2
    ; CHECK-NEXT: $dc0 = MOV_mv_scl killed $r3
    ; CHECK-NEXT: $m4 = MOV_mv_scl killed $r4
    ; CHECK-NEXT: RET implicit $lr
    ; CHECK-NEXT: $dn4 = MOV_mv_scl killed $r5
    ; CHECK-NEXT: $dj4 = MOV_mv_scl killed $r6
    ; CHECK-NEXT: $dc4 = MOV_mv_scl killed $r7
    ; CHECK-NEXT: $p0, $dc0, $dc4 = PADDA_3D killed $p0, $d0_3d
    ; CHECK-NEXT: $p0, $dc0, $dc4 = PADDA_3D killed $p0, killed $d0_3d
    ; CHECK-NEXT: DelayedSchedBarrier implicit killed renamable $p0, implicit killed renamable $dc4
    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:em =  COPY $r4
    %5:edn = COPY $r5
    %6:edj = COPY $r6
    %7:edc = COPY $r7
    %8:ep = COPY $p0

    ; ISel code for: %200(p0), %300(i20), %400(i20) = G_INTRINSIC(add_3d_byte) %8, %0, %1, %2, %3, %4, %5, %6, %7
    %100:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %7, %subreg.sub_hi_dim_then_sub_dim_count
    %200:ep, %300:edc, %400:edc = PADDA_3D %8, %100

    ; ISel code for: %201(p0), %301(i20), %401(i20) = G_INTRINSIC(add_3d_byte) %8, %0, %1, %2, %300, %4, %5, %6, %400
    %101:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %300, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %400, %subreg.sub_hi_dim_then_sub_dim_count
    %201:ep, %301:edc, %401:edc = PADDA_3D %200, %101

    PseudoRET implicit $lr, implicit %201, implicit %401
...

# d1_3d = $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7
# d2_3d = d1_3d
# d1_3d = $r8, $r9, $r10, $r11, $r12, $r13, $r14, $r15
# SPILL d1_3d
# d1_3d = d2_3d
# $p0, $dc1, $dc5 = PADDA_3D killed $p0, killed $d1_3d
# dead $p2, $dc2, $dc6 = PADDA_3D killed $p2, $d2_3d
# d1_3d = d2_3d
# d2_3d = RELOAD
# $p0, dead $dc1, dead $dc5 = PADDA_3D killed $p0, killed $d1_3d
# $p1, dead $dc2, dead $dc6 = PADDA_3D killed $p1, killed $d2_3d
# RET p0, p1
---
name:            test_4_padd_scarce
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $r8, $r9, $r10, $r11, $r12, $r13, $r14, $r15, $p0, $p1, $m0, $d3_3d

    ; CHECK-LABEL: name: test_4_padd_scarce
    ; CHECK: liveins: $m0, $p0, $p1, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $r8, $r9, $r10, $r11, $r12, $r13, $r14, $r15, $d3_3d
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: frame-setup PADDB_sp_imm 32, implicit-def $sp, implicit $sp
    ; CHECK-NEXT: $m2 = MOV_mv_scl killed $r0
    ; CHECK-NEXT: $m1 = MOV_mv_scl killed $r8
    ; CHECK-NEXT: $dn2 = MOV_mv_scl killed $r1
    ; CHECK-NEXT: $dj2 = MOV_mv_scl killed $r2
    ; CHECK-NEXT: $dc2 = MOV_mv_scl killed $r3
    ; CHECK-NEXT: $m6 = MOV_mv_scl killed $r4
    ; CHECK-NEXT: $dn6 = MOV_mv_scl killed $r5
    ; CHECK-NEXT: $dj6 = MOV_mv_scl killed $r6
    ; CHECK-NEXT: $dc6 = MOV_mv_scl killed $r7
    ; CHECK-NEXT: ST_dms_spill killed $m1, -32, implicit $sp :: (store (s32) into %stack.0)
    ; CHECK-NEXT: $m1 = MOV_mv_scl $m2
    ; CHECK-NEXT: $dn1 = MOV_mv_scl $dn2
    ; CHECK-NEXT: $dj1 = MOV_mv_scl $dj2
    ; CHECK-NEXT: $dc1 = MOV_mv_scl $dc2
    ; CHECK-NEXT: $m5 = MOV_mv_scl $m6
    ; CHECK-NEXT: $dn5 = MOV_mv_scl $dn6
    ; CHECK-NEXT: $dj5 = MOV_mv_scl $dj6
    ; CHECK-NEXT: $dc5 = MOV_mv_scl $dc6
    ; CHECK-NEXT: $p0, $dc1, $dc5 = PADDA_3D killed $p0, killed $d1_3d
    ; CHECK-NEXT: $m1 = LDA_dms_spill -32, implicit $sp :: (load (s32) from %stack.0)
    ; CHECK-NEXT: $p2 = MOV_mv_scl $p1
    ; CHECK-NEXT: $dc0 = MOV_mv_scl killed $dc1
    ; CHECK-NEXT: $dc4 = MOV_mv_scl killed $dc5
    ; CHECK-NEXT: $p2, $dc2, $dc6 = PADDA_3D killed $p2, $d2_3d
    ; CHECK-NEXT: $dn1 = MOV_mv_scl killed $r9
    ; CHECK-NEXT: frame-destroy PADDB_sp_imm -32, implicit-def $sp, implicit $sp
    ; CHECK-NEXT: $dj1 = MOV_mv_scl killed $r10
    ; CHECK-NEXT: $m5 = MOV_mv_scl killed $r12
    ; CHECK-NEXT: $dn5 = MOV_mv_scl killed $r13
    ; CHECK-NEXT: $dj5 = MOV_mv_scl killed $r14
    ; CHECK-NEXT: $dc1 = MOV_mv_scl killed $r11
    ; CHECK-NEXT: RET implicit $lr
    ; CHECK-NEXT: $dc5 = MOV_mv_scl killed $r15
    ; CHECK-NEXT: $dc2 = MOV_mv_scl killed $dc0
    ; CHECK-NEXT: $dc6 = MOV_mv_scl killed $dc4
    ; CHECK-NEXT: $p0, dead $dc2, dead $dc6 = PADDA_3D killed $p0, killed $d2_3d
    ; CHECK-NEXT: $p1, dead $dc1, dead $dc5 = PADDA_3D killed $p1, killed $d1_3d
    ; CHECK-NEXT: DelayedSchedBarrier implicit killed renamable $p0, implicit killed renamable $p1, implicit killed renamable $p2, implicit killed $m0, implicit killed $d3_3d
    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:em =  COPY $r4
    %5:edn = COPY $r5
    %6:edj = COPY $r6
    %7:edc = COPY $r7

    %10:em =  COPY $r8
    %11:edn = COPY $r9
    %12:edj = COPY $r10
    %13:edc = COPY $r11
    %14:em =  COPY $r12
    %15:edn = COPY $r13
    %16:edj = COPY $r14
    %17:edc = COPY $r15

    %20:ep = COPY $p0
    %21:ep = COPY $p1

    %100:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %7, %subreg.sub_hi_dim_then_sub_dim_count
    %200:ep, %300:edc, %400:edc = PADDA_3D %20, %100

    %101:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %7, %subreg.sub_hi_dim_then_sub_dim_count
    %201:ep, %301:edc, %401:edc = PADDA_3D %21, %101

    %102:eds = REG_SEQUENCE %10, %subreg.sub_mod, %11, %subreg.sub_dim_size, %12, %subreg.sub_dim_stride, %13, %subreg.sub_dim_count, %14, %subreg.sub_hi_dim_then_sub_mod, %15, %subreg.sub_hi_dim_then_sub_dim_size, %16, %subreg.sub_hi_dim_then_sub_dim_stride, %17, %subreg.sub_hi_dim_then_sub_dim_count
    %202:ep, %302:edc, %402:edc = PADDA_3D %21, %102

    %103:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %300, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %400, %subreg.sub_hi_dim_then_sub_dim_count
    %203:ep, %303:edc, %403:edc = PADDA_3D %200, %103

    PseudoRET implicit $lr, implicit %203, implicit %202, implicit %201, implicit $m0, implicit $d3_3d
...


# Standard loop where the pointer is incremented using PADDA_3D at each
# iteration. Each iteration uses the incremented counter from the previous one.
# After PHI elimination and reg alloc, we should see a simple `PADDA_3D p0 [d0_3d]`
# in the loop body.
---
name:            test_padd_loop
alignment:       16
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: test_padd_loop
  ; CHECK: bb.0.entry (align 16):
  ; CHECK-NEXT:   successors: %bb.3(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT:   liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $r8
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $m0 = MOV_mv_scl killed $r0
  ; CHECK-NEXT:   renamable $r0 = MOVA_lda_cg 0
  ; CHECK-NEXT:   renamable $r9 = GE renamable $r0, renamable $r8
  ; CHECK-NEXT:   JNZ killed renamable $r9, %bb.3
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   DelayedSchedBarrier
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $r8, $d0_3d:0x00000000000F0870
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $dn0 = MOV_mv_scl killed $r1
  ; CHECK-NEXT:   $dj0 = MOV_mv_scl killed $r2
  ; CHECK-NEXT:   $dc0 = MOV_mv_scl killed $r3
  ; CHECK-NEXT:   $m4 = MOV_mv_scl killed $r4
  ; CHECK-NEXT:   $dn4 = MOV_mv_scl killed $r5
  ; CHECK-NEXT:   $dj4 = MOV_mv_scl killed $r6
  ; CHECK-NEXT:   $dc4 = MOV_mv_scl killed $r7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2 (align 16):
  ; CHECK-NEXT:   successors: %bb.3(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT:   liveins: $p0, $r0, $r8, $d0_3d:0x00000000000F0870
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   ST_dms_sts_idx_imm renamable $r0, renamable $p0, 0 :: (store (s32))
  ; CHECK-NEXT:   renamable $r0 = nuw nsw ADD_add_r_ri killed renamable $r0, 1, implicit-def $srcarry
  ; CHECK-NEXT:   renamable $r1 = EQ renamable $r8, renamable $r0
  ; CHECK-NEXT:   JZ killed renamable $r1, %bb.2
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   $p0, $dc0, $dc4 = PADDA_3D killed $p0, $d0_3d
  ; CHECK-NEXT:   $dc4 = MOV_mv_scl $dc0
  ; CHECK-NEXT:   DelayedSchedBarrier
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3 (align 16):
  ; CHECK-NEXT:   RET implicit $lr
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   DelayedSchedBarrier
  bb.0.entry:
    liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $r8

    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:em =  COPY $r4
    %5:edn = COPY $r5
    %6:edj = COPY $r6
    %7:edc = COPY $r7
    %8:ep = COPY killed $p0
    %9:er = COPY killed $r8
    %24:er = MOVA_lda_cg 0
    %25:er = GE %24, %9
    PseudoJNZ killed %25, %bb.2
  bb.1:
    PseudoJ_jump_imm %bb.3
  bb.2:
    PseudoRET implicit $lr
  bb.3:
    %60:er = PHI %24, %bb.1, %13, %bb.3
    %70:ep = PHI %8, %bb.1, %10, %bb.3
    %100:edc = PHI %3, %bb.1, %102, %bb.3
    %200:edc = PHI %7, %bb.1, %102, %bb.3
    ST_dms_sts_idx_imm %60, %70, 0 :: (store (s32))
    %101:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %100, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %200, %subreg.sub_hi_dim_then_sub_dim_count
    %10:ep, %102:edc, %202:edc = PADDA_3D %70, %101
    %13:er = nuw nsw ADD_add_r_ri killed %60, 1, implicit-def $srcarry
    %19:er = EQ %9, %13
    PseudoJNZ killed %19, %bb.2
    PseudoJ_jump_imm %bb.3
...

# PADDA_3D conditionally followed by another PADDA_3D using the incremented
# counter. We'd like to see the two PADDA_3D use the same d0_3d register.
---
name:            test_padd_conditional
alignment:       16
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: test_padd_conditional
  ; CHECK: bb.0.entry (align 16):
  ; CHECK-NEXT:   successors: %bb.2(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT:   liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $r8
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $m0 = MOV_mv_scl killed $r0
  ; CHECK-NEXT:   $dn0 = MOV_mv_scl killed $r1
  ; CHECK-NEXT:   $dj0 = MOV_mv_scl killed $r2
  ; CHECK-NEXT:   $dc0 = MOV_mv_scl killed $r3
  ; CHECK-NEXT:   JNZ killed renamable $r8, %bb.2
  ; CHECK-NEXT:   $m4 = MOV_mv_scl killed $r4
  ; CHECK-NEXT:   $dn4 = MOV_mv_scl killed $r5
  ; CHECK-NEXT:   $dj4 = MOV_mv_scl killed $r6
  ; CHECK-NEXT:   $dc4 = MOV_mv_scl killed $r7
  ; CHECK-NEXT:   $p0, $dc0, $dc4 = PADDA_3D killed $p0, $d0_3d
  ; CHECK-NEXT:   DelayedSchedBarrier
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $p0, $d0_3d:0x00000000000F0870
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $p0, $dc0, $dc4 = PADDA_3D killed $p0, $d0_3d
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2 (align 16):
  ; CHECK-NEXT:   liveins: $p0, $d0_3d:0x0000000000000010
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   RET implicit $lr
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   DelayedSchedBarrier implicit killed renamable $dc0, implicit killed renamable $p0
  bb.0.entry:
    liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $r8

    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:em =  COPY $r4
    %5:edn = COPY $r5
    %6:edj = COPY $r6
    %7:edc = COPY $r7
    %8:ep = COPY killed $p0
    %9:er = COPY killed $r8
    %100:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %7, %subreg.sub_hi_dim_then_sub_dim_count
    %101:ep, %102:edc, %103:edc = PADDA_3D %8, %100
    PseudoJNZ killed %9, %bb.2
  bb.1:
    %200:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %102, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %103, %subreg.sub_hi_dim_then_sub_dim_count
    %201:ep, %202:edc, %203:edc = PADDA_3D %101, %200
  bb.2:
    %10:edc = PHI %202, %bb.1, %102, %bb.0
    %11:ep = PHI %201, %bb.1, %101, %bb.0
    PseudoRET implicit $lr, implicit %10, implicit %11
...

# Diamond pattern where one branch uses the incremented counter from the
# dominating PADDA_3D, and the other ones uses a value coming from r9.
# What we want to see is a conditional copy from r9 to dc0.
---
name:            test_padd_diamond
alignment:       16
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: test_padd_diamond
  ; CHECK: bb.0.entry (align 16):
  ; CHECK-NEXT:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT:   liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $r8, $r9
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $m0 = MOV_mv_scl killed $r0
  ; CHECK-NEXT:   $dn0 = MOV_mv_scl killed $r1
  ; CHECK-NEXT:   $dj0 = MOV_mv_scl killed $r2
  ; CHECK-NEXT:   $dc0 = MOV_mv_scl killed $r3
  ; CHECK-NEXT:   JZ killed renamable $r8, %bb.2
  ; CHECK-NEXT:   $m4 = MOV_mv_scl killed $r4
  ; CHECK-NEXT:   $dn4 = MOV_mv_scl killed $r5
  ; CHECK-NEXT:   $dj4 = MOV_mv_scl killed $r6
  ; CHECK-NEXT:   $dc4 = MOV_mv_scl killed $r7
  ; CHECK-NEXT:   $p0, $dc0, $dc4 = PADDA_3D killed $p0, $d0_3d
  ; CHECK-NEXT:   DelayedSchedBarrier
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $p0, $r9, $d0_3d:0x00000000000F0860
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $dc0 = MOV_mv_scl killed $r9
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2 (align 16):
  ; CHECK-NEXT:   liveins: $p0, $d0_3d
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   RET implicit $lr
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   NOP
  ; CHECK-NEXT:   $p0, $dc0, $dc4 = PADDA_3D killed $p0, killed $d0_3d
  ; CHECK-NEXT:   DelayedSchedBarrier implicit killed renamable $dc0, implicit killed renamable $p0, implicit killed renamable $dc4
  bb.0.entry:
    liveins: $p0, $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7, $r8, $r9

    %0:em =  COPY $r0
    %1:edn = COPY $r1
    %2:edj = COPY $r2
    %3:edc = COPY $r3
    %4:em =  COPY $r4
    %5:edn = COPY $r5
    %6:edj = COPY $r6
    %7:edc = COPY $r7
    %8:ep = COPY killed $p0
    %9:er = COPY killed $r8
    %30:edc = COPY $r9
    %100:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %3, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %7, %subreg.sub_hi_dim_then_sub_dim_count
    %101:ep, %102:edc, %103:edc = PADDA_3D %8, %100
    PseudoJNZ killed %9, %bb.2
  bb.1:
    %200:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %102, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %103, %subreg.sub_hi_dim_then_sub_dim_count
    %201:ep, %202:edc, %203:edc = PADDA_3D %101, %200
    PseudoJ_jump_imm %bb.3
  bb.2:
    %300:eds = REG_SEQUENCE %0, %subreg.sub_mod, %1, %subreg.sub_dim_size, %2, %subreg.sub_dim_stride, %30, %subreg.sub_dim_count, %4, %subreg.sub_hi_dim_then_sub_mod, %5, %subreg.sub_hi_dim_then_sub_dim_size, %6, %subreg.sub_hi_dim_then_sub_dim_stride, %103, %subreg.sub_hi_dim_then_sub_dim_count
    %301:ep, %302:edc, %303:edc = PADDA_3D %101, %300
  bb.3:
    %10:edc = PHI %202, %bb.1, %302, %bb.2
    %11:ep = PHI %201, %bb.1, %301, %bb.2
    %12:edc = PHI %203, %bb.1, %303, %bb.2
    PseudoRET implicit $lr, implicit %10, implicit %11, implicit %12
...
