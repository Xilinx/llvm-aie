; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O2 --issue-limit=1 -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

; r16-r19 are used in the function due to the CC. They are also part of the
; callee-saved registers.
; Make sure the CC takes precedence and they are not saved.
define <2 x i32> @no_save_L(<2 x i32> %a) {
; CHECK-LABEL: no_save_L:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    mov r16, r18 // Delay Slot 2
; CHECK-NEXT:    mov r17, r19 // Delay Slot 1
  ret <2 x i32> %a
}

; r16-r21 are used by CC, so they aren't saved by PEI even though they are
; callee-saved registers.
; Here we make sure %a is preserved accross the call to foo.
define <2 x i32> @preserve_L(<2 x i32> %a, <2 x i32> %b) {
; CHECK-LABEL: preserve_L:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    nopa ; paddb [sp], #32; nopx
; CHECK-NEXT:    st lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    jl #foo
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    mov r16, r20 // Delay Slot 2
; CHECK-NEXT:    mov r17, r21 // Delay Slot 1
; CHECK-NEXT:    nopb ; lda lr, [sp, #-32]; nops ; nopxm ; nopv // 4-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    mov r16, r18 // Delay Slot 3
; CHECK-NEXT:    mov r17, r19 // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 1
  call void @foo(<2 x i32> %b)
  ret <2 x i32> %a
}

define i32 @preserve_R(i32 %a, <2 x i32> %b) {
; CHECK-LABEL: preserve_R:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    nopa ; paddb [sp], #32; nopx
; CHECK-NEXT:    st lr, [sp, #-28] // 4-byte Folded Spill
; CHECK-NEXT:    jl #foo
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    st r18, [sp, #-32] // 4-byte Folded Spill Delay Slot 2
; CHECK-NEXT:    mov r18, r1 // Delay Slot 1
; CHECK-NEXT:    nopb ; lda lr, [sp, #-28]; nops ; nopxm ; nopv // 4-byte Folded Reload
; CHECK-NEXT:    mov r0, r18
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r18, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 1
  call void @foo(<2 x i32> %b)
  ret i32 %a
}

define i32 @no_CC_CSR_overlap(i32 %a) {
; CHECK-LABEL: no_CC_CSR_overlap:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r0, r1 // Delay Slot 1
  ret i32 %a
}

define void @no_CC_regs() {
; CHECK-LABEL: no_CC_regs:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  ret void
}

declare void @foo(<2 x i32>)
