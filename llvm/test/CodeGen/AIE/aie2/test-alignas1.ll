; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

%struct.S1 = type { i32, [252 x i8] }
%struct.S7 = type { %struct.S1 }

@__const._Z12test_alignasv.a = private unnamed_addr constant <{ [8 x i16], [8 x i16] }> <{ [8 x i16] [i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1], [8 x i16] zeroinitializer }>, align 256
@n9 = global i32 0, align 1024

define <16 x i16> @_Z12test_alignasv() {
  ; CHECK-LABEL: name: _Z12test_alignasv
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @__const._Z12test_alignasv.a
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 32
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.0.a
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.1.b
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s20) = G_TRUNC [[C]](s32)
  ; CHECK-NEXT:   G_MEMCPY [[FRAME_INDEX]](p0), [[GV]](p0), [[TRUNC]](s20), 0 :: (store (s8) into %ir.a, align 256), (load (s8) from @__const._Z12test_alignasv.a, align 256)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY [[FRAME_INDEX]](p0)
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(p0) = COPY [[COPY]](p0)
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<16 x s16>) = G_LOAD [[COPY1]](p0) :: (dereferenceable load (<16 x s16>) from %ir.arrayidx, align 256)
  ; CHECK-NEXT:   G_STORE [[LOAD]](<16 x s16>), [[FRAME_INDEX1]](p0) :: (store (<16 x s16>) into %ir.b, align 1024)
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(<16 x s16>) = G_LOAD [[FRAME_INDEX1]](p0) :: (dereferenceable load (<16 x s16>) from %ir.b, align 1024)
  ; CHECK-NEXT:   $wl0 = COPY [[LOAD1]](<16 x s16>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $wl0
entry:
  %a = alloca [16 x i16], align 256
  %b = alloca <16 x i16>, align 1024
  call void @llvm.memcpy.p0.p0.i32(ptr align 256 %a, ptr align 256 @__const._Z12test_alignasv.a, i32 32, i1 false)
  %arraydecay = getelementptr inbounds [16 x i16], ptr %a, i32 0, i32 0
  %arrayidx = getelementptr inbounds <16 x i16>, ptr %arraydecay, i32 0
  %0 = load <16 x i16>, ptr %arrayidx, align 256
  store <16 x i16> %0, ptr %b, align 1024
  %1 = load <16 x i16>, ptr %b, align 1024
  ret <16 x i16> %1
}

declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #1

define i32 @_Z13test_alignas1v() {
  ; CHECK-LABEL: name: _Z13test_alignas1v
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @n9
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.0.s1
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.1.b
  ; CHECK-NEXT:   [[FRAME_INDEX2:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.2.s7
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY [[FRAME_INDEX]](p0)
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[COPY]](p0) :: (dereferenceable load (s32) from %ir.n, align 512)
  ; CHECK-NEXT:   G_STORE [[LOAD]](s32), [[FRAME_INDEX1]](p0) :: (store (s32) into %ir.b, align 64)
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[GV]](p0) :: (dereferenceable load (s32) from @n9, align 1024)
  ; CHECK-NEXT:   $r0 = COPY [[LOAD1]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
entry:
  %s1 = alloca %struct.S1, align 512
  %b = alloca i32, align 64
  %s7 = alloca %struct.S7, align 1024
  %n = getelementptr inbounds %struct.S1, ptr %s1, i32 0, i32 0
  %0 = load i32, ptr %n, align 512
  store i32 %0, ptr %b, align 64
  %1 = load i32, ptr @n9, align 1024
  ret i32 %1
}
