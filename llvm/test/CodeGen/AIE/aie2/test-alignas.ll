; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O0 --issue-limit=1 -verify-machineinstrs -mtriple=aie2 %s -o - \
; RUN:   | FileCheck %s

%struct.S1 = type { i32, [252 x i8] }
%struct.S7 = type { %struct.S1 }

@__const._Z12test_alignasv.a = private unnamed_addr constant <{ [8 x i16], [8 x i16] }> <{ [8 x i16] [i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1], [8 x i16] zeroinitializer }>, align 256
@n9 = global i32 0, align 1024

define <16 x i16> @_Z12test_alignasv() {
; CHECK-LABEL: _Z12test_alignasv:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    paddb [sp], #2048; nopa ; nops ; nopx ; nopm ; nopv
; CHECK-NEXT:    st lr, [sp, #-2048] // 4-byte Folded Spill
; CHECK-NEXT:    jl #memcpy
; CHECK-NEXT:    mov p1, sp // Delay Slot 5
; CHECK-NEXT:    padda [p1], #-1792 // Delay Slot 4
; CHECK-NEXT:    st p1, [sp, #-992] // 4-byte Folded Spill Delay Slot 3
; CHECK-NEXT:    movxm p2, #.L__const._Z12test_alignasv.a // Delay Slot 2
; CHECK-NEXT:    mova r0, #32 // Delay Slot 1
; CHECK-NEXT:    lda p0, [sp, #-992]; nops ; nopv // 4-byte Folded Reload
; CHECK-NEXT:    lda lr, [sp, #-2048] // 4-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    vlda wh0, [p0, #0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    vst wh0, [sp, #-1024]
; CHECK-NEXT:    vlda wl0, [sp, #-1024]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-2048 // Delay Slot 1
entry:
  %a = alloca [16 x i16], align 256
  %b = alloca <16 x i16>, align 1024
  call void @llvm.memcpy.p0.p0.i32(ptr align 256 %a, ptr align 256 @__const._Z12test_alignasv.a, i32 32, i1 false)
  %arraydecay = getelementptr inbounds [16 x i16], ptr %a, i32 0, i32 0
  %arrayidx = getelementptr inbounds <16 x i16>, ptr %arraydecay, i32 0
  %0 = load <16 x i16>, ptr %arrayidx, align 256
  store <16 x i16> %0, ptr %b, align 1024
  %1 = load <16 x i16>, ptr %b, align 1024
  ret <16 x i16> %1
}

declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg)

define i32 @_Z13test_alignas1v() {
; CHECK-LABEL: _Z13test_alignas1v:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #2048; nopx
; CHECK-NEXT:    mov p2, sp
; CHECK-NEXT:    padda [p2], #-2048
; CHECK-NEXT:    lda r0, [p2, #0]
; CHECK-NEXT:    mov p1, sp
; CHECK-NEXT:    movxm p0, #n9
; CHECK-NEXT:    padda [p1], #-1792
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    st r0, [p1, #0]
; CHECK-NEXT:    lda r0, [p0, #0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-2048 // Delay Slot 1
entry:
  %s1 = alloca %struct.S1, align 512
  %b = alloca i32, align 64
  %s7 = alloca %struct.S7, align 1024
  %n = getelementptr inbounds %struct.S1, ptr %s1, i32 0, i32 0
  %0 = load i32, ptr %n, align 512
  store i32 %0, ptr %b, align 64
  %1 = load i32, ptr @n9, align 1024
  ret i32 %1
}
