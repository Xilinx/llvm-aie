; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2 --issue-limit=1 %s -o - | FileCheck %s

define dso_local noundef signext i32 @_Z15test_ext_v2int4Dv16_iii(<16 x i32> noundef %v, i32 noundef %idx, i32 noundef %sign) local_unnamed_addr #0 {
; CHECK-LABEL: _Z15test_ext_v2int4Dv16_iii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; mov r1, r16
; CHECK-NEXT:    mova r16, #63
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mov crVaddSign, r2 // Delay Slot 5
; CHECK-NEXT:    vextract.d8 r0, x0, r16 // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    mov crVaddSign, #0 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %0 = bitcast <16 x i32> %v to <64 x i8>
  %1 = tail call i32 @llvm.aie2.vextract.elem8.I512(<64 x i8> %0, i32 63, i32 %sign)
  ret i32 %1
}


define dso_local noundef signext i32 @_Z15test_ext_v4int4Dv16_iii(<16 x i32> noundef %v, i32 noundef %idx, i32 noundef %sign) local_unnamed_addr #0 {
; CHECK-LABEL: _Z15test_ext_v4int4Dv16_iii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; mov r1, r16
; CHECK-NEXT:    mova r16, #50
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mov crVaddSign, r2 // Delay Slot 5
; CHECK-NEXT:    vextract.d16 r0, x0, r16 // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    mov crVaddSign, #0 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %0 = bitcast <16 x i32> %v to <32 x i16>
  %1 = tail call i32 @llvm.aie2.vextract.elem16.I512(<32 x i16> %0, i32 50, i32 %sign)
  ret i32 %1
}


define dso_local noundef i32 @_Z15test_ext_v8int4Dv16_iii(<16 x i32> noundef %v, i32 noundef %idx, i32 noundef %sign) local_unnamed_addr #0 {
; CHECK-LABEL: _Z15test_ext_v8int4Dv16_iii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; mov r1, r16
; CHECK-NEXT:    mova r16, #10
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mov crVaddSign, r2 // Delay Slot 5
; CHECK-NEXT:    vextract.d32 r0, x0, r16 // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    mov crVaddSign, #0 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %0 = tail call i32 @llvm.aie2.vextract.elem32.I512(<16 x i32> %v, i32 10, i32 %sign)
  ret i32 %0
}


define dso_local noundef signext i32 @_Z21test_ext_v2int4_sign1Dv16_ii(<16 x i32> noundef %v, i32 noundef %idx) local_unnamed_addr #0 {
; CHECK-LABEL: _Z21test_ext_v2int4_sign1Dv16_ii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #6 // Delay Slot 4
; CHECK-NEXT:    vextract.s8 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %0 = bitcast <16 x i32> %v to <64 x i8>
  %1 = tail call i32 @llvm.aie2.vextract.elem8.I512(<64 x i8> %0, i32 6, i32 1)
  ret i32 %1
}


define dso_local noundef signext i32 @_Z21test_ext_v4int4_sign1Dv16_ii(<16 x i32> noundef %v, i32 noundef %idx) local_unnamed_addr #0 {
; CHECK-LABEL: _Z21test_ext_v4int4_sign1Dv16_ii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #5 // Delay Slot 4
; CHECK-NEXT:    vextract.s16 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %0 = bitcast <16 x i32> %v to <32 x i16>
  %1 = tail call i32 @llvm.aie2.vextract.elem16.I512(<32 x i16> %0, i32 5, i32 1)
  ret i32 %1
}


define dso_local noundef i32 @_Z21test_ext_v8int4_sign1Dv16_ii(<16 x i32> noundef %v, i32 noundef %idx) local_unnamed_addr #0 {
; CHECK-LABEL: _Z21test_ext_v8int4_sign1Dv16_ii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.s32 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %0 = tail call i32 @llvm.aie2.vextract.elem32.I512(<16 x i32> %v, i32 1, i32 1)
  ret i32 %0
}


define dso_local noundef signext i32 @_Z21test_ext_v2int4_sign0Dv16_ii(<16 x i32> noundef %v, i32 noundef %idx) local_unnamed_addr #0 {
; CHECK-LABEL: _Z21test_ext_v2int4_sign0Dv16_ii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #16 // Delay Slot 4
; CHECK-NEXT:    vextract.d8 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %0 = bitcast <16 x i32> %v to <64 x i8>
  %1 = tail call i32 @llvm.aie2.vextract.elem8.I512(<64 x i8> %0, i32 16, i32 0)
  ret i32 %1
}


define dso_local noundef signext i32 @_Z21test_ext_v4int4_sign0Dv16_ii(<16 x i32> noundef %v, i32 noundef %idx) local_unnamed_addr #0 {
; CHECK-LABEL: _Z21test_ext_v4int4_sign0Dv16_ii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #51 // Delay Slot 4
; CHECK-NEXT:    vextract.d16 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %0 = bitcast <16 x i32> %v to <32 x i16>
  %1 = tail call i32 @llvm.aie2.vextract.elem16.I512(<32 x i16> %0, i32 51, i32 0)
  ret i32 %1
}


define dso_local noundef i32 @_Z21test_ext_v8int4_sign0Dv16_ii(<16 x i32> noundef %v, i32 noundef %idx) local_unnamed_addr #0 {
; CHECK-LABEL: _Z21test_ext_v8int4_sign0Dv16_ii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #41 // Delay Slot 4
; CHECK-NEXT:    vextract.d32 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %0 = tail call i32 @llvm.aie2.vextract.elem32.I512(<16 x i32> %v, i32 41, i32 0)
  ret i32 %0
}

define dso_local noundef <8 x i8> @_Z16test_ext_v16int4Dv64_DB8_ii(<64 x i8> noundef %v, i32 noundef %idx, i32 noundef %sign) local_unnamed_addr #0 {
; CHECK-LABEL: _Z16test_ext_v16int4Dv64_DB8_ii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mova r16, #1 // Delay Slot 5
; CHECK-NEXT:    mov crVaddSign, r1 // Delay Slot 4
; CHECK-NEXT:    vextract.d64 r17:r16, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov crVaddSign, #0 // Delay Slot 1
entry:
  %0 = bitcast <64 x i8> %v to <16 x i32>
  %1 = tail call <2 x i32> @llvm.aie2.vextract.elem64.I512(<16 x i32> %0, i32 1, i32 %sign)
  %2 = bitcast <2 x i32> %1 to <8 x i8>
  ret <8 x i8> %2
}

define dso_local noundef i64 @_Z12test_ext_u64Dv16_iii(<16 x i32> noundef %v, i32 noundef %idx, i32 noundef %sign) local_unnamed_addr #0 {
; CHECK-LABEL: _Z12test_ext_u64Dv16_iii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; nopx ; mov r4, r16; nops
; CHECK-NEXT:    mov r16, r2
; CHECK-NEXT:    mov crVaddSign, r3
; CHECK-NEXT:    vextract.d64 r25:r24, x0, r16
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    mov crVaddSign, #0 // Delay Slot 4
; CHECK-NEXT:    mov r16, r4 // Delay Slot 3
; CHECK-NEXT:    mov r0, r24 // Delay Slot 2
; CHECK-NEXT:    mov r1, r25 // Delay Slot 1
entry:
  %0 = tail call <2 x i32> @llvm.aie2.vextract.elem64.I512(<16 x i32> %v, i32 %idx, i32 %sign)
  %1 = bitcast <2 x i32> %0 to i64
  ret i64 %1
}

declare i32 @llvm.aie2.vextract.elem8.I512(<64 x i8>, i32, i32) #1
declare i32 @llvm.aie2.vextract.elem16.I512(<32 x i16>, i32, i32) #1
declare i32 @llvm.aie2.vextract.elem32.I512(<16 x i32>, i32, i32) #1
declare <2 x i32> @llvm.aie2.vextract.elem64.I512(<16 x i32>, i32, i32) #1

define dso_local noundef zeroext i16 @_Z5test0Dv16_t(<16 x i16> noundef %vec)  {
; CHECK-LABEL: _Z5test0Dv16_t:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.d16 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <16 x i16> %vec, i64 1
  ret i16 %vecext
}

define dso_local noundef signext i16 @_Z5test1Dv16_s(<16 x i16> noundef %vec)  {
; CHECK-LABEL: _Z5test1Dv16_s:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.s16 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <16 x i16> %vec, i64 1
  ret i16 %vecext
}

define dso_local noundef signext i8 @_Z5test2Dv32_a(<32 x i8> noundef %vec)  {
; CHECK-LABEL: _Z5test2Dv32_a:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.s8 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <32 x i8> %vec, i64 1
  ret i8 %vecext
}

define dso_local noundef zeroext i8 @_Z5test3Dv32_h(<32 x i8> noundef %vec)  {
; CHECK-LABEL: _Z5test3Dv32_h:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.d8 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <32 x i8> %vec, i64 1
  ret i8 %vecext
}

define dso_local noundef i32 @_Z5test4Dv8_i(<8 x i32> noundef %vec)  {
; CHECK-LABEL: _Z5test4Dv8_i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.s32 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <8 x i32> %vec, i64 1
  ret i32 %vecext
}

define dso_local noundef i32 @_Z5test5Dv8_j(<8 x i32> noundef %vec)  {
; CHECK-LABEL: _Z5test5Dv8_j:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.s32 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <8 x i32> %vec, i64 1
  ret i32 %vecext
}
define dso_local noundef zeroext i16 @_Z5test0Dv32_t(<32 x i16> noundef %vec)  {
; CHECK-LABEL: _Z5test0Dv32_t:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.d16 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <32 x i16> %vec, i64 1
  ret i16 %vecext
}

define dso_local noundef signext i16 @_Z5test1Dv32_s(<32 x i16> noundef %vec)  {
; CHECK-LABEL: _Z5test1Dv32_s:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.s16 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <32 x i16> %vec, i64 1
  ret i16 %vecext
}

define dso_local noundef signext i8 @_Z5test2Dv64_a(<64 x i8> noundef %vec)  {
; CHECK-LABEL: _Z5test2Dv64_a:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.s8 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <64 x i8> %vec, i64 1
  ret i8 %vecext
}

define dso_local noundef zeroext i8 @_Z5test3Dv64_h(<64 x i8> noundef %vec)  {
; CHECK-LABEL: _Z5test3Dv64_h:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.d8 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <64 x i8> %vec, i64 1
  ret i8 %vecext
}

define dso_local noundef i32 @_Z5test4Dv16_i(<16 x i32> noundef %vec)  {
; CHECK-LABEL: _Z5test4Dv16_i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.s32 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <16 x i32> %vec, i64 1
  ret i32 %vecext
}

define dso_local noundef i32 @_Z5test5Dv16_j(<16 x i32> noundef %vec)  {
; CHECK-LABEL: _Z5test5Dv16_j:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r1, r16 // Delay Slot 5
; CHECK-NEXT:    mova r16, #1 // Delay Slot 4
; CHECK-NEXT:    vextract.s32 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %vecext = extractelement <16 x i32> %vec, i64 1
  ret i32 %vecext
}

define dso_local noundef i32 @test0_v2int32(<2 x i32> noundef %val) {
; CHECK-LABEL: test0_v2int32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r0, r16 // Delay Slot 1
entry:
  %vecext = extractelement <2 x i32> %val, i64 0
  ret i32 %vecext
}

define dso_local noundef i32 @test1_v2int32(<2 x i32> noundef %val) {
; CHECK-LABEL: test1_v2int32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r0, r17 // Delay Slot 1
entry:
  %vecext = extractelement <2 x i32> %val, i64 1
  ret i32 %vecext
}

define dso_local noundef signext i8 @_Z5test1Dv128_a(<128 x i8> noundef %vec)  {
; CHECK-LABEL: _Z5test1Dv128_a:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    paddb [sp], #32; nopxm
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    lda r0, [p0, #0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r3, r16
; CHECK-NEXT:    mova r1, #0
; CHECK-NEXT:    movx r2, #64
; CHECK-NEXT:    lt r27, r0, r2
; CHECK-NEXT:    sel.nez r1, r1, r2, r27
; CHECK-NEXT:    add r24, r27, #-1
; CHECK-NEXT:    sub r16, r0, r1
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mov r25, r24 // Delay Slot 5
; CHECK-NEXT:    vsel.8 x0, x4, x5, r25:r24 // Delay Slot 4
; CHECK-NEXT:    vextract.s8 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 2
; CHECK-NEXT:    mov r16, r3 // Delay Slot 1
entry:
  %idx = alloca i32, align 4
  %idx.0.idx.0.idx.0.idx.0. = load volatile i32, ptr %idx, align 4
  %vecext = extractelement <128 x i8> %vec, i32 %idx.0.idx.0.idx.0.idx.0.
  ret i8 %vecext
}

define dso_local noundef signext i16 @_Z5test2Dv64_s(<64 x i16> noundef %vec)  {
; CHECK-LABEL: _Z5test2Dv64_s:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    paddb [sp], #32; nopxm
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    lda r0, [p0, #0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r3, r16
; CHECK-NEXT:    mov r4, r17
; CHECK-NEXT:    mova r1, #0
; CHECK-NEXT:    mova r2, #32
; CHECK-NEXT:    paddb [sp], #-32
; CHECK-NEXT:    lt r27, r0, r2
; CHECK-NEXT:    sel.nez r1, r1, r2, r27
; CHECK-NEXT:    add r17, r27, #-1
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    vsel.16 x0, x4, x5, r17 // Delay Slot 5
; CHECK-NEXT:    sub r16, r0, r1 // Delay Slot 4
; CHECK-NEXT:    vextract.s16 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    or r17, r4, r4 // Delay Slot 2
; CHECK-NEXT:    mov r16, r3 // Delay Slot 1
entry:
  %idx = alloca i32, align 4
  %idx.0.idx.0.idx.0.idx.0. = load volatile i32, ptr %idx, align 4
  %vecext = extractelement <64 x i16> %vec, i32 %idx.0.idx.0.idx.0.idx.0.
  ret i16 %vecext
}

define dso_local noundef i32 @_Z5test3Dv32_i(<32 x i32> noundef %vec)  {
; CHECK-LABEL: _Z5test3Dv32_i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    paddb [sp], #32; nopxm
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    lda r0, [p0, #0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r3, r16
; CHECK-NEXT:    mov r4, r17
; CHECK-NEXT:    mova r1, #0
; CHECK-NEXT:    mova r2, #16
; CHECK-NEXT:    paddb [sp], #-32
; CHECK-NEXT:    lt r27, r0, r2
; CHECK-NEXT:    sel.nez r1, r1, r2, r27
; CHECK-NEXT:    add r17, r27, #-1
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    vsel.32 x0, x4, x5, r17 // Delay Slot 5
; CHECK-NEXT:    sub r16, r0, r1 // Delay Slot 4
; CHECK-NEXT:    vextract.s32 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    or r17, r4, r4 // Delay Slot 2
; CHECK-NEXT:    mov r16, r3 // Delay Slot 1
entry:
  %idx = alloca i32, align 4
  %idx.0.idx.0.idx.0.idx.0. = load volatile i32, ptr %idx, align 4
  %vecext = extractelement <32 x i32> %vec, i32 %idx.0.idx.0.idx.0.idx.0.
  ret i32 %vecext
}

define dso_local noundef signext i8 @_Z16extract_8bit_256Dv32_a(<32 x i8> noundef %vec)  {
; CHECK-LABEL: _Z16extract_8bit_256Dv32_a:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #32; nopxm
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    st.s8 r0, [p0, #0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r1, r16
; CHECK-NEXT:    mova r16, #5
; CHECK-NEXT:    vextract.s8 r0, x0, r16
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.s8 r0, [p0, #0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %ret = alloca i8, align 4
  %vecext = extractelement <32 x i8> %vec, i64 5
  store volatile i8 %vecext, ptr %ret
  %ret.0.ret.0.ret.0.ret.0. = load volatile i8, ptr %ret
  ret i8 %ret.0.ret.0.ret.0.ret.0.
}

define dso_local noundef zeroext i16 @_Z17extract_16bit_256Dv16_t(<16 x i16> noundef %vec)  {
; CHECK-LABEL: _Z17extract_16bit_256Dv16_t:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #32; nopxm
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    st.s16 r0, [p0, #0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r1, r16
; CHECK-NEXT:    mova r16, #15
; CHECK-NEXT:    vextract.s16 r0, x0, r16
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u16 r0, [p0, #0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %ret = alloca i16, align 4
  %vecext = extractelement <16 x i16> %vec, i64 15
  store volatile i16 %vecext, ptr %ret
  %ret.0.ret.0.ret.0.ret.0. = load volatile i16, ptr %ret
  ret i16 %ret.0.ret.0.ret.0.ret.0.
}

define dso_local noundef signext i8 @_Z16extract_8bit_512Dv64_a(<64 x i8> noundef %vec)  {
; CHECK-LABEL: _Z16extract_8bit_512Dv64_a:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #32; nopxm
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    st.s8 r0, [p0, #0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r1, r16
; CHECK-NEXT:    mova r16, #63
; CHECK-NEXT:    vextract.s8 r0, x0, r16
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.s8 r0, [p0, #0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %ret = alloca i8, align 4
  %vecext = extractelement <64 x i8> %vec, i64 63
  store volatile i8 %vecext, ptr %ret
  %ret.0.ret.0.ret.0.ret.0. = load volatile i8, ptr %ret
  ret i8 %ret.0.ret.0.ret.0.ret.0.
}

define dso_local noundef zeroext i16 @_Z17extract_16bit_512Dv32_t(<32 x i16> noundef %vec)  {
; CHECK-LABEL: _Z17extract_16bit_512Dv32_t:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #32; nopxm
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    st.s16 r0, [p0, #0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r1, r16
; CHECK-NEXT:    mova r16, #15
; CHECK-NEXT:    vextract.s16 r0, x0, r16
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u16 r0, [p0, #0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %ret = alloca i16, align 4
  %vecext = extractelement <32 x i16> %vec, i64 15
  store volatile i16 %vecext, ptr %ret
  %ret.0.ret.0.ret.0.ret.0. = load volatile i16, ptr %ret
  ret i16 %ret.0.ret.0.ret.0.ret.0.
}


define dso_local noundef signext i8 @_Z17extract_8bit_1024Dv128_a(<128 x i8> noundef %vec)  {
; CHECK-LABEL: _Z17extract_8bit_1024Dv128_a:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #32; nopxm
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    st.s8 r0, [p0, #0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r1, r16
; CHECK-NEXT:    mova r16, #63
; CHECK-NEXT:    vextract.s8 r0, x5, r16
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.s8 r0, [p0, #0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %ret = alloca i8, align 4
  %vecext = extractelement <128 x i8> %vec, i64 127
  store volatile i8 %vecext, ptr %ret
  %ret.0.ret.0.ret.0.ret.0. = load volatile i8, ptr %ret
  ret i8 %ret.0.ret.0.ret.0.ret.0.
}


define dso_local noundef zeroext i16 @_Z18extract_16bit_1024Dv64_t(<64 x i16> noundef %vec)  {
; CHECK-LABEL: _Z18extract_16bit_1024Dv64_t:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #32; nopxm
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    paddb [p0], #-32
; CHECK-NEXT:    st.s16 r0, [p0, #0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r1, r16
; CHECK-NEXT:    mova r16, #31
; CHECK-NEXT:    vextract.s16 r0, x5, r16
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda.u16 r0, [p0, #0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %ret = alloca i16, align 4
  %vecext = extractelement <64 x i16> %vec, i64 63
  store volatile i16 %vecext, ptr %ret
  %ret.0.ret.0.ret.0.ret.0. = load volatile i16, ptr %ret
  ret i16 %ret.0.ret.0.ret.0.ret.0.
}
