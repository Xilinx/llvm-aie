; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc --mtriple=aie2 -O2 --issue-limit=6 %s -o - | FileCheck %s

define dso_local i32 @dot(ptr nocapture readonly %a, ptr nocapture readonly %b, i32 noundef %n) {
; This pipelines in three stages. We have a dynamic tripcount, and we
; get a guard from loop rotation, two guards from prologues,
; and then the software pipelined body
; NOTE: we use a large immediate offset in the pointer increments to force
; using padda rather than the padd pseudo. This is awaiting proper handling
; of pseudos in pre-RA scheduling/pipelining
; CHECK-LABEL: dot:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r0, #0; nopb ; nopxm
; CHECK-NEXT:    ge r2, r0, r1
; CHECK-NEXT:    jnz r2, #.LBB0_6
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %for.body
; CHECK-NEXT:    lda r2, [p0, #0]; nopb ; add r5, r1, #-1
; CHECK-NEXT:    lda r3, [p1, #0]
; CHECK-NEXT:    jz r5, #.LBB0_5
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    padda [p0], #2044 // Delay Slot 2
; CHECK-NEXT:    padda [p1], #2044 // Delay Slot 1
; CHECK-NEXT:  // %bb.2: // %for.body
; CHECK-NEXT:    lda r1, [p0, #0]; nopb ; add r5, r5, #-1
; CHECK-NEXT:    lda r4, [p1, #0]
; CHECK-NEXT:    jz r5, #.LBB0_4
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    padda [p0], #2044 // Delay Slot 2
; CHECK-NEXT:    padda [p1], #2044 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_3: // %for.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    lda r4, [p1, #0]; nopb ; and r6, r3, r2; mov r3, r4; nops
; CHECK-NEXT:    add r5, r5, #-1; mov r2, r1
; CHECK-NEXT:    lda r1, [p0, #0]
; CHECK-NEXT:    jnz r5, #.LBB0_3
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    padda [p0], #2044 // Delay Slot 2
; CHECK-NEXT:    padda [p1], #2044; or r0, r6, r0 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_4:
; CHECK-NEXT:    and r2, r3, r2; mov r3, r4
; CHECK-NEXT:    or r0, r2, r0; mov r2, r1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_5:
; CHECK-NEXT:    nopa ; nopb ; and r1, r3, r2; nopm
; CHECK-NEXT:    or r0, r1, r0
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_6: // %for.cond.cleanup
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1

entry:
  %cmp4 = icmp sgt i32 %n, 0
  br i1 %cmp4, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %s.0.lcssa = phi i32 [ 0, %entry ], [ %or, %for.body ]
  ret i32 %s.0.lcssa

for.body:                                         ; preds = %entry, %for.body
  %i.08 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %s.07 = phi i32 [ %or, %for.body ], [ 0, %entry ]
  %a.addr.06 = phi ptr [ %incdec.ptr, %for.body ], [ %a, %entry ]
  %b.addr.05 = phi ptr [ %incdec.ptr1, %for.body ], [ %b, %entry ]
  %incdec.ptr = getelementptr inbounds i32, ptr %a.addr.06, i20 511
  %0 = load i32, ptr %a.addr.06, align 4
  %incdec.ptr1 = getelementptr inbounds i32, ptr %b.addr.05, i20 511
  %1 = load i32, ptr %b.addr.05, align 4
  %and = and i32 %1, %0
  %or = or i32 %and, %s.07
  %inc = add nuw nsw i32 %i.08, 1
  %exitcond.not = icmp eq i32 %inc, %n
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}
