# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -mtriple=aie2 -run-pass=postmisched --issue-limit=1 --debug %s -o - 2>%t.log | FileCheck %s
# RUN: cat %t.log | FileCheck %s --check-prefix=CHECK-SU
# REQUIRES: asserts


# VMAC reads its accumulator input in E3 and writes in E5
# There is a WAR edge of -1 (= 3 - 5 + BypassedCycles) latency between the two
# VMAC instructions. Here, we verify that the second VMAC is scheduled AT MOST
# one cycle before the first one. If we ever get the schedule below, the anti-dep
# would not be respected and we have a broken schedule.
#   VMAC cm0, cm2, ...
#   NOP
#   VMAC cm1, cm0, ...  <--- WRONG: Bypass taken, we already read the new cm0
---
name:            antidep_minus_2_plus_bypass
alignment:       16
body:             |
  bb.0.entry:
    liveins: $p0
    ; CHECK-LABEL: name: antidep_minus_2_plus_bypass
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $cm0 = VMAC_vmac_cm_core_dense killed $cm2, killed $x2, killed $x3, $r1
    ; CHECK-NEXT: $cm1 = VMAC_vmac_cm_core_dense $cm0, killed $x0, killed $x1, killed $r1
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: VST_dmw_sts_am_ag_idx_imm killed $amll0, killed $p0, 0
    ; CHECK-NEXT: NOP
    $cm1 = VMAC_vmac_cm_core_dense $cm0, $x0, $x1, $r1
    $cm0 = VMAC_vmac_cm_core_dense $cm2, $x2, $x3, $r1
    VST_dmw_sts_am_ag_idx_imm $amll0, $p0, 0
...
# CHECK-SU-LABEL: antidep_minus_2_plus_bypass:%bb.0 entry
# CHECK-SU: SU(0):   $cm1 = VMAC_vmac_cm_core_dense $cm0, $x0, $x1, $r1
# CHECK-SU:  Successors:
# CHECK-SU:    SU(1): Anti Latency=0(-1)
# CHECK-SU: SU(1):   $cm0 = VMAC_vmac_cm_core_dense $cm2, $x2, $x3, $r1


# There is an anti-dependency between VMOV and VBAND.
# VMOV reads in E1 while VBAND writes in E2. We need to account for the
# potential WL bypass, otherwise the edge latency would be -1 and the
# instructions could be re-ordered. They cannot be re-ordered, otherwise
# the bypass would be taken and VMOV would wrongly take the new value for wl0.
---
name:            antidep_minus_1_plus_wl_bypass
alignment:       16
body:             |
  bb.0.entry:
    liveins: $p0
    ; CHECK-LABEL: name: antidep_minus_1_plus_wl_bypass
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $wl1 = VMOV_mv_w killed $wl0
    ; CHECK-NEXT: $x0 = VBAND killed $x2, killed $x4
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: VST_dmw_sts_w_ag_idx_imm killed $wh0, killed $p0, 0
    ; CHECK-NEXT: NOP
    $wl1 = VMOV_mv_w $wl0
    $x0 = VBAND $x2, $x4
    VST_dmw_sts_w_ag_idx_imm $wh0, $p0, 0
...
# CHECK-SU-LABEL: antidep_minus_1_plus_wl_bypass:%bb.0 entry
# CHECK-SU: SU(0):   $wl1 = VMOV_mv_w $wl0
# CHECK-SU:  Successors:
# CHECK-SU:    SU(1): Anti Latency=0{{$}}
# CHECK-SU: SU(1):   $x0 = VBAND $x2, $x4
---
name:            antidep_minus_1_plus_X_bypass
alignment:       16
body:             |
  bb.0.entry:
    liveins: $p0
    ; CHECK-LABEL: name: antidep_minus_1_plus_X_bypass
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $x1 = VMOV_mv_x killed $x0
    ; CHECK-NEXT: $x0 = VBAND killed $x2, killed $x4
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: VST_dmw_sts_w_ag_idx_imm killed $wh0, killed $p0, 0
    ; CHECK-NEXT: NOP
    $x1 = VMOV_mv_x $x0
    $x0 = VBAND $x2, $x4
    VST_dmw_sts_w_ag_idx_imm $wh0, $p0, 0
...
# CHECK-SU-LABEL: antidep_minus_1_plus_X_bypass:%bb.0 entry
# CHECK-SU: SU(0):   $x1 = VMOV_mv_x $x0
# CHECK-SU:  Successors:
# CHECK-SU:    SU(1): Anti Latency=0{{$}}
# CHECK-SU: SU(1):   $x0 = VBAND $x2, $x4

# There is an anti-dependency between VMOV and VBAND.
# VMOV reads in E1 while VBAND writes in E2. There is no potential bypass in use
# because the MOV slot bypass does not work for wh registers.
# Therefore, the edge latency is -1 and the instructions can be re-ordered.
---
name:            antidep_minus_1
alignment:       16
body:             |
  bb.0.entry:
    liveins: $p0
    ; CHECK-LABEL: name: antidep_minus_1
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $x0 = VBAND killed $x2, killed $x4
    ; CHECK-NEXT: $wl1 = VMOV_mv_w $wh0
    ; CHECK-NEXT: VST_dmw_sts_w_ag_idx_imm killed $wh0, killed $p0, 0
    ; CHECK-NEXT: NOP
    $wl1 = VMOV_mv_w $wh0
    $x0 = VBAND $x2, $x4
    VST_dmw_sts_w_ag_idx_imm $wh0, $p0, 0
...
# CHECK-SU-LABEL: antidep_minus_1:%bb.0 entry
# CHECK-SU: SU(0):   $wl1 = VMOV_mv_w $wh0
# CHECK-SU:  Successors:
# CHECK-SU:    SU(1): Anti Latency=0(-1)
# CHECK-SU: SU(1):   $x0 = VBAND $x2, $x4

# There is an anti-dependency between the first VST and VBAND.
# This is a simpler case, the instructions are in different slots, so they have
# no bypass.
# VST reads in E1 while VBAND writes in E2.
# Therefore, the edge latency is -1 and the instructions can be re-ordered.
---
name:            antidep_minus_1_simple
alignment:       16
body:             |
  bb.0.entry:
    liveins: $p0
    ; CHECK-LABEL: name: antidep_minus_1_simple
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $x0 = VBAND killed $x2, killed $x4
    ; CHECK-NEXT: VST_dmw_sts_w_ag_idx_imm $wh0, $p0, 16
    ; CHECK-NEXT: VST_dmw_sts_w_ag_idx_imm killed $wh0, killed $p0, 0
    ; CHECK-NEXT: NOP
    VST_dmw_sts_w_ag_idx_imm $wh0, $p0, 16
    $x0 = VBAND $x2, $x4
    VST_dmw_sts_w_ag_idx_imm $wh0, $p0, 0
...
# CHECK-SU-LABEL: antidep_minus_1_simple:%bb.0 entry
# CHECK-SU: SU(0):   VST_dmw_sts_w_ag_idx_imm $wh0, $p0, 16
# CHECK-SU:  Successors:
# CHECK-SU:    SU(1): Anti Latency=0(-1)
# CHECK-SU: SU(1):   $x0 = VBAND $x2, $x4
