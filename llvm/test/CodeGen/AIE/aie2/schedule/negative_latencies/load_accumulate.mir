# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -march=aie2 --aie-bottomup-cycles=1000 --aie-bottomup-delta=128 -run-pass=postmisched %s -o - \
# RUN:   | FileCheck %s

# An example where multiple part-word loads are accumulated in a same register.
# The added complexity is that the load offset comes from a separate MOV
# immediate instruction, which also always uses the same register: $dj0
# This can only be tightly packed using negative latencies properly.

---
name:            load_s16
alignment:       16
body:             |
  bb.0.entry:
    liveins: $p0, $p1

    ; CHECK-LABEL: name: load_s16
    ; CHECK: liveins: $p0, $p1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $dj0 = MOVA_lda_cg 14
    ; CHECK-NEXT: $r3 = LDA_S16_ag_idx $p0, killed $dj0
    ; CHECK-NEXT: $dj0 = MOVA_lda_cg 16
    ; CHECK-NEXT: $r4 = LDA_S16_ag_idx $p0, killed $dj0
    ; CHECK-NEXT: $dj0 = MOVA_lda_cg 18
    ; CHECK-NEXT: $r4 = LDA_S16_ag_idx $p0, killed $dj0
    ; CHECK-NEXT: $dj0 = MOVA_lda_cg 20
    ; CHECK-NEXT: $r4 = LDA_S16_ag_idx $p0, killed $dj0
    ; CHECK-NEXT: $dj0 = MOVA_lda_cg 22
    ; CHECK-NEXT: $r4 = LDA_S16_ag_idx killed $p0, killed $dj0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r3 = ADD killed $r3, $r4, implicit-def $srcarry
    ; CHECK-NEXT: $r3 = ADD killed $r3, $r4, implicit-def $srcarry
    ; CHECK-NEXT: RET implicit $lr
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r3 = ADD killed $r3, $r4, implicit-def $srcarry
    ; CHECK-NEXT: $r3 = ADD killed $r3, killed $r4, implicit-def $srcarry
    ; CHECK-NEXT: ST_dms_sts_idx_imm killed $r3, killed $p1, 0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: DelayedSchedBarrier
    $dj0 = MOV_PD_imm10_pseudo 14
    $r3 = LDA_S16_ag_idx $p0, killed $dj0
    $dj0 = MOV_PD_imm10_pseudo 16
    $r4 = LDA_S16_ag_idx $p0, killed $dj0
    $r3 = ADD $r3, $r4, implicit-def $srcarry
    $dj0 = MOV_PD_imm10_pseudo 18
    $r4 = LDA_S16_ag_idx $p0, killed $dj0
    $r3 = ADD $r3, $r4, implicit-def $srcarry
    $dj0 = MOV_PD_imm10_pseudo 20
    $r4 = LDA_S16_ag_idx $p0, killed $dj0
    $r3 = ADD $r3, $r4, implicit-def $srcarry
    $dj0 = MOV_PD_imm10_pseudo 22
    $r4 = LDA_S16_ag_idx $p0, killed $dj0
    $r3 = ADD $r3, $r4, implicit-def $srcarry
    ST_dms_sts_idx_imm $r3, $p1, 0

    RET implicit $lr
    DelayedSchedBarrier
...

# Similar as above, but the MOV immediate for $dj0 is fixed in the M slot.
---
name:            load_s16_fixed_movm
alignment:       16
body:             |
  bb.0.entry:
    liveins: $p0, $p1

    ; CHECK-LABEL: name: load_s16_fixed_movm
    ; CHECK: liveins: $p0, $p1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $dj0 = MOV_mv_cg 14
    ; CHECK-NEXT: $r3 = LDA_S16_ag_idx $p0, $dj0 {
    ; CHECK-NEXT:   $dj0 = MOV_mv_cg 16
    ; CHECK-NEXT: }
    ; CHECK-NEXT: $r4 = LDA_S16_ag_idx $p0, $dj0 {
    ; CHECK-NEXT:   $dj0 = MOV_mv_cg 18
    ; CHECK-NEXT: }
    ; CHECK-NEXT: $r4 = LDA_S16_ag_idx $p0, $dj0 {
    ; CHECK-NEXT:   $dj0 = MOV_mv_cg 20
    ; CHECK-NEXT: }
    ; CHECK-NEXT: $r4 = LDA_S16_ag_idx $p0, $dj0 {
    ; CHECK-NEXT:   $dj0 = MOV_mv_cg 22
    ; CHECK-NEXT: }
    ; CHECK-NEXT: $r4 = LDA_S16_ag_idx killed $p0, killed $dj0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r3 = ADD killed $r3, $r4, implicit-def $srcarry
    ; CHECK-NEXT: $r3 = ADD killed $r3, $r4, implicit-def $srcarry
    ; CHECK-NEXT: $r3 = ADD killed $r3, $r4, implicit-def $srcarry
    ; CHECK-NEXT: $r3 = ADD killed $r3, killed $r4, implicit-def $srcarry
    ; CHECK-NEXT: ST_dms_sts_idx_imm killed $r3, killed $p1, 0
    ; CHECK-NEXT: NOP
    $dj0 = MOV_mv_cg 14
    $r3 = LDA_S16_ag_idx $p0, killed $dj0
    $dj0 = MOV_mv_cg 16
    $r4 = LDA_S16_ag_idx $p0, killed $dj0
    $r3 = ADD $r3, $r4, implicit-def $srcarry
    $dj0 = MOV_mv_cg 18
    $r4 = LDA_S16_ag_idx $p0, killed $dj0
    $r3 = ADD $r3, $r4, implicit-def $srcarry
    $dj0 = MOV_mv_cg 20
    $r4 = LDA_S16_ag_idx $p0, killed $dj0
    $r3 = ADD $r3, $r4, implicit-def $srcarry
    $dj0 = MOV_mv_cg 22
    $r4 = LDA_S16_ag_idx $p0, killed $dj0
    $r3 = ADD $r3, $r4, implicit-def $srcarry
    ST_dms_sts_idx_imm $r3, $p1, 0
...
# TODO: test with s8 loads and MOVs to compute the offset
