# NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates

# RUN: llc --mtriple=aie2 -O2 --start-before=postmisched %s -o - | FileCheck %s

# This crashed the postpipeliner because it reaches NCopies=1 which causes an out of
# bound access when setting up LCD heuristics.
# The filecheck reference is the unpipelined loop

--- |
  define void @crash_computeLoopCarriedParameters(ptr nocapture %params_ptr, ptr nocapture readonly %curr_ptr) local_unnamed_addr {
  ; CHECK-LABEL: crash_computeLoopCarriedParameters:
  ; CHECK:         .p2align 4
  ; CHECK-NEXT:  // %bb.0: // %entry
  ; CHECK-NEXT:    nopb ; nopa ; nops ; movxm ls, #.LBB0_1; nopv
  ; CHECK-NEXT:    mova r0, #8; nopb ; movxm le, #.L_LEnd0
  ; CHECK-NEXT:    add.nc lc, r0, #0
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; mov p2, p0; nopv
  ; CHECK-NEXT:    .p2align 4
  ; CHECK-NEXT:  .LBB0_1: // %for.body
  ; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
  ; CHECK-NEXT:    nopb ; lda r0, [p2, #0]; nops ; nopx ; mov p2, p1; nopv
  ; CHECK-NEXT:    nopa ; nopx
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:  .L_LEnd0:
  ; CHECK-NEXT:    nopb ; nopa ; st r0, [p0, #0]; nopxm ; nopv
  ; CHECK-NEXT:  // %bb.2: // %for.cond.cleanup
  ; CHECK-NEXT:    nopa ; ret lr
  ; CHECK-NEXT:    nop // Delay Slot 5
  ; CHECK-NEXT:    nop // Delay Slot 4
  ; CHECK-NEXT:    nop // Delay Slot 3
  ; CHECK-NEXT:    nop // Delay Slot 2
  ; CHECK-NEXT:    nop // Delay Slot 1
  entry:
    call void @llvm.set.loop.iterations.i32(i32 8)
    br label %for.body

  for.cond.cleanup:                                 ; preds = %for.body
    ret void

  for.body:                                         ; preds = %for.body, %entry
    %params_ptr.addr.011 = phi ptr [ %params_ptr, %entry ], [ %curr_ptr, %for.body ]
    %0 = load i32, ptr %params_ptr.addr.011, align 4
    store i32 %0, ptr %params_ptr, align 4
    %1 = call i1 @llvm.loop.decrement.i32(i32 1)
    br i1 %1, label %for.body, label %for.cond.cleanup, !llvm.loop !0
  }

  declare void @llvm.set.loop.iterations.i32(i32)
  declare i1 @llvm.loop.decrement.i32(i32)

  !0 = distinct !{!0, !1, !2}
  !1 = !{!"llvm.loop.mustprogress"}
  !2 = !{!"llvm.loop.itercount.range", i64 8}

...
---
name:            crash_computeLoopCarriedParameters
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
failedISel:      false
tracksRegLiveness: true
body:             |
  bb.0.entry (align 16):
    successors: %bb.1(0x80000000)
    liveins: $p0, $p1

    $r0 = MOV_RLC_imm10_pseudo 8
    $lc = ADD_NC $r0, 0
    $ls = MOVXM_lng_cg %bb.1
    $le = MOVXM_lng_cg <mcsymbol .L_LEnd0>
    $p2 = MOV_mv_scl $p0

  bb.1.for.body (align 16):
    successors: %bb.1(0x7c000000), %bb.2(0x04000000)
    liveins: $p0, $p1, $p2

    $r0 = LDA_dms_lda_idx_imm $p2, 0
    ST_dms_sts_idx_imm killed $r0, $p0, 0
    $p2 = MOV_mv_scl $p1
    PseudoLoopEnd <mcsymbol .L_LEnd0>, %bb.1

  bb.2.for.cond.cleanup:
    RET implicit $lr
    DelayedSchedBarrier
...
