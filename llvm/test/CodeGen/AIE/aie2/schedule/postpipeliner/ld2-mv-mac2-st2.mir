# NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates

# RUN: llc --mtriple=aie2 -O2 --start-before=postmisched %s -o - | FileCheck %s

# A fairly dense loop with two loads, two macs and two stores, fitting in NS=6 x II=2

--- |
  define dso_local void @loop(ptr addrspace(5) noalias nocapture writeonly %d, ptr addrspace(6) noalias nocapture readonly %s, i32 noundef %n) local_unnamed_addr #0 {
  ; CHECK-LABEL: loop:
  ; CHECK:         .p2align 4
  ; CHECK-NEXT:  // %bb.0: // %entry
  ; CHECK-NEXT:    mova r1, #0; nopb ; nopxm
  ; CHECK-NEXT:    ge r1, r1, r0
  ; CHECK-NEXT:    jnz r1, #.LBB0_3
  ; CHECK-NEXT:    nop // Delay Slot 5
  ; CHECK-NEXT:    nop // Delay Slot 4
  ; CHECK-NEXT:    nop // Delay Slot 3
  ; CHECK-NEXT:    nop // Delay Slot 2
  ; CHECK-NEXT:    nop // Delay Slot 1
  ; CHECK-NEXT:  // %bb.1: // %for.body.preheader
  ; CHECK-NEXT:    add.nc lc, r0, #-6
  ; CHECK-NEXT:    movxm ls, #.LBB0_2
  ; CHECK-NEXT:    movxm le, #.L_LEnd0
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopx
  ; CHECK-NEXT:    vldb wl4, [p0], m2
  ; CHECK-NEXT:    vldb.2d wl4, [p0], d0
  ; CHECK-NEXT:    vldb wl4, [p0], m2
  ; CHECK-NEXT:    vldb.2d wl4, [p0], d0
  ; CHECK-NEXT:    vldb wl4, [p0], m2
  ; CHECK-NEXT:    vldb.2d wl4, [p0], d0; vmov wh4, wl0
  ; CHECK-NEXT:    vldb wl4, [p0], m2
  ; CHECK-NEXT:    vldb.2d wl4, [p0], d0; vmov wh4, wl0; vmac cm1, cm0, x4, x2, r0
  ; CHECK-NEXT:    vldb wl4, [p0], m2; vmac cm2, cm0, x4, x2, r0
  ; CHECK-NEXT:    vldb.2d wl4, [p0], d0; vmov wh4, wl0; vmac cm1, cm0, x4, x2, r0
  ; CHECK-NEXT:    vldb wl4, [p0], m2; vmac cm2, cm0, x4, x2, r0
  ; CHECK-NEXT:    vldb.2d wl4, [p0], d0; vmov wh4, wl0; vmac cm1, cm0, x4, x2, r0
  ; CHECK-NEXT:    .p2align 4
  ; CHECK-NEXT:  .LBB0_2: // %for.body
  ; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
  ; CHECK-NEXT:    vldb wl4, [p0], m2; nopa ; vst.srs.d8.s32 cm1, s0, [p1], m2; nopxm ; vmac cm2, cm0, x4, x2, r0
  ; CHECK-NEXT:  .L_LEnd9:
  ; CHECK-NEXT:    vldb.2d wl4, [p0], d0; nopa ; vst.2d.srs.d8.s32 cm2, s0, [p1], d1; nopx ; vmov wh4, wl0; vmac cm1, cm0, x4, x2, r0
  ; CHECK-NEXT:    .p2align 4
  ; CHECK-NEXT:  .LBB0_3: // %for.cond.cleanup
  ; CHECK-NEXT:    vst.srs.d8.s32 cm1, s0, [p1], m2; nopx ; vmac cm2, cm0, x4, x2, r0
  ; CHECK-NEXT:    vst.2d.srs.d8.s32 cm2, s0, [p1], d1; vmov wh4, wl0; vmac cm1, cm0, x4, x2, r0
  ; CHECK-NEXT:    vst.srs.d8.s32 cm1, s0, [p1], m2; vmac cm2, cm0, x4, x2, r0
  ; CHECK-NEXT:    vst.2d.srs.d8.s32 cm2, s0, [p1], d1; vmov wh4, wl0; vmac cm1, cm0, x4, x2, r0
  ; CHECK-NEXT:    vst.srs.d8.s32 cm1, s0, [p1], m2; vmac cm2, cm0, x4, x2, r0
  ; CHECK-NEXT:    vst.2d.srs.d8.s32 cm2, s0, [p1], d1; vmac cm1, cm0, x4, x2, r0
  ; CHECK-NEXT:    vst.srs.d8.s32 cm1, s0, [p1], m2; vmac cm2, cm0, x4, x2, r0
  ; CHECK-NEXT:    vst.2d.srs.d8.s32 cm2, s0, [p1], d1
  ; CHECK-NEXT:    vst.srs.d8.s32 cm1, s0, [p1], m2
  ; CHECK-NEXT:    vst.2d.srs.d8.s32 cm2, s0, [p1], d1
  ; CHECK-NEXT:    vst.srs.d8.s32 cm1, s0, [p1], m2
  ; CHECK-NEXT:    vst.2d.srs.d8.s32 cm2, s0, [p1], d1
  ; CHECK-NEXT:    ret lr
  ; CHECK-NEXT:    nop // Delay Slot 5
  ; CHECK-NEXT:    nop // Delay Slot 4
  ; CHECK-NEXT:    nop // Delay Slot 3
  ; CHECK-NEXT:    nop // Delay Slot 2
  ; CHECK-NEXT:    nop // Delay Slot 1
  entry:
    %cmp5 = icmp sgt i32 %n, 0
    br i1 %cmp5, label %for.body.preheader, label %for.cond.cleanup

  for.body.preheader:                               ; preds = %entry
    call void @llvm.set.loop.iterations.i32(i32 %n)
    br label %for.body

  for.cond.cleanup:                                 ; preds = %for.body, %entry
    ret void

  for.body:                                         ; preds = %for.body.preheader, %for.body
    %d.addr.07 = phi ptr addrspace(5) [ %incdec.ptr, %for.body ], [ %d, %for.body.preheader ]
    %s.addr.06 = phi ptr addrspace(6) [ %incdec.ptr1, %for.body ], [ %s, %for.body.preheader ]
    %0 = load i32, ptr addrspace(6) %s.addr.06, align 4, !tbaa !2
    %add = add nsw i32 %0, 1
    store i32 %add, ptr addrspace(5) %d.addr.07, align 4, !tbaa !2
    %incdec.ptr = getelementptr inbounds i32, ptr addrspace(5) %d.addr.07, i20 1
    %incdec.ptr1 = getelementptr inbounds i32, ptr addrspace(6) %s.addr.06, i20 1
    %1 = call i1 @llvm.loop.decrement.i32(i32 1)
    br i1 %1, label %for.body, label %for.cond.cleanup, !llvm.loop !6
  }

  ; Function Attrs: nocallback noduplicate nofree nosync nounwind willreturn
  declare void @llvm.set.loop.iterations.i32(i32) #1

  ; Function Attrs: nocallback noduplicate nofree nosync nounwind willreturn
  declare i1 @llvm.loop.decrement.i32(i32) #1

  attributes #0 = { nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
  attributes #1 = { nocallback noduplicate nofree nosync nounwind willreturn }

  !llvm.module.flags = !{!0}
  !llvm.ident = !{!1}

  !0 = !{i32 1, !"wchar_size", i32 4}
  !1 = !{!"clang version 18.0.0git (git@github.com:Xilinx/llvm-aie.git 6532135c22419e573eaa75f1cc5defff7e04f931)"}
  !2 = !{!3, !3, i64 0}
  !3 = !{!"int", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = distinct !{!6, !7, !8}
  !7 = !{!"llvm.loop.mustprogress"}
  !8 = !{!"llvm.loop.itercount.range", i64 10}

...
---
name:            loop
alignment:       16
tracksRegLiveness: true
body:             |
  bb.0.entry (align 16):
    successors: %bb.1, %bb.3
    liveins: $p0, $p1, $r0

    renamable $r1 = MOV_RLC_imm10_pseudo 0
    renamable $r1 = GE killed renamable $r1, renamable $r0
    JNZ killed renamable $r1, %bb.3
    DelayedSchedBarrier

  bb.1.for.body.preheader:
    successors: %bb.2
    liveins: $p0, $p1, $r0

    $lc = ADD_NC $r0, 0
    $ls = MOVXM_lng_cg %bb.2
    $le = MOVXM_lng_cg <mcsymbol .L_LEnd0>

  bb.2.for.body (align 16):
    successors: %bb.2(0x7c000000), %bb.3(0x04000000)
    liveins: $p0, $p1, $r0, $m2, $wl0, $cm0, $x2, $d0, $d1, $s0
    $wl4, $p0 = VLD_pstm_pseudo $p0, $m2, :: (load (<8 x s32>) from %ir.s.addr.06, addrspace 5)
    $wh4 = VMOV_mv_w $wl0
    $cm1 = VMAC_vmac_cm_core_dense $cm0, $x4, $x2, $r0
    $wl4, $p0, $dc0 = VLD_2D_pseudo killed $p0, $d0 :: (load (<8 x s32>) from %ir.s.addr.06, addrspace 5)
    $cm2 = VMAC_vmac_cm_core_dense $cm0, $x4, $x2, $r0
    $p1 = VST_SRS_D8_S32_ag_pstm_nrm $p1, $m2, $cm1, $s0, implicit-def $srsrs_of, implicit $crsat, implicit $crrnd, implicit $crsrssign :: (store (<32 x s8>) into %ir.d.addr.07, addrspace 6)
    $p1, $dc1 = VST_2D_SRS_D8_S32 $p1, $d1, $cm2, $s0, implicit-def $srsrs_of, implicit $crsat, implicit $crrnd, implicit $crsrssign :: (store (<32 x s8>) into %ir.d.addr.07, addrspace 7)
    PseudoLoopEnd <mcsymbol .L_LEnd9>, %bb.2

  bb.3.for.cond.cleanup (align 16):
    RET implicit $lr
    DelayedSchedBarrier

...
