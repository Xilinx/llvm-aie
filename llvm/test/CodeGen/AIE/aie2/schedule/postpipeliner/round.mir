# NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates

# RUN: llc --mtriple=aie2 -O2 --start-before=postmisched %s -o - | FileCheck %s

# Inspired by Round
# Currently we don't get this post-pipelined, because the RecMII is
# dominated by a cycle caused by WAW on srups_of/srsrs_of
# The important observation is that these writes are sticky, which
# means that the actual order of updates doesn't matter as long as there are
# no resets of the flags in the loop.
# Once we implement that in the WAW dag mutator or more generally in
# ScheduleDAGInstr, it is expected that this loop with two symmetric
# chains might fit in a low II

--- |
  target datalayout = "e-m:e-p:20:32-i1:8:32-i8:8:32-i16:16:32-i32:32:32-f32:32:32-i64:32-f64:32-a:0:32-n32"
  target triple = "aie2"

  define dso_local void @round(ptr addrspace(5) noalias nocapture readonly %in1, ptr addrspace(6) noalias nocapture readonly %in2, ptr addrspace(7) noalias nocapture writeonly %out, i32 noundef %n) local_unnamed_addr #0 {
  ; CHECK-LABEL: round:
  ; CHECK:         .p2align 4
  ; CHECK-NEXT:  // %bb.0: // %entry
  ; CHECK-NEXT:    mova r1, #0; nopb ; nopxm
  ; CHECK-NEXT:    ge r1, r1, r0
  ; CHECK-NEXT:    jnz r1, #.LBB0_4
  ; CHECK-NEXT:    nop // Delay Slot 5
  ; CHECK-NEXT:    nop // Delay Slot 4
  ; CHECK-NEXT:    nop // Delay Slot 3
  ; CHECK-NEXT:    nop // Delay Slot 2
  ; CHECK-NEXT:    nop // Delay Slot 1
  ; CHECK-NEXT:  // %bb.1: // %for.body.preheader
  ; CHECK-NEXT:    add.nc lc, r0, #-1
  ; CHECK-NEXT:    movxm ls, #.LBB0_2
  ; CHECK-NEXT:    movxm le, #.L_LEnd0
  ; CHECK-NEXT:    nopb ; vlda.ups.s32.s8 cm0, s0, [p0], #32; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; vlda.ups.s32.s8 cm1, s0, [p0], #32; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
  ; CHECK-NEXT:    nopa ; nopb ; nopxm
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    .p2align 4
  ; CHECK-NEXT:  .LBB0_2: // %for.body
  ; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
  ; CHECK-NEXT:    vlda.ups.s32.s8 cm0, s0, [p0], #32; nopb ; vsrs.s8.s32 wh0, cm0, s1
  ; CHECK-NEXT:    vlda.ups.s32.s8 cm1, s0, [p0], #32; vsrs.s8.s32 wh2, cm1, s1
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    vups.s32.s8 cm2, wh0, s1
  ; CHECK-NEXT:    vups.s32.s8 cm3, wh2, s1
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    vst.srs.s8.s32 cm2, s0, [p1], #32
  ; CHECK-NEXT:  .L_LEnd0:
  ; CHECK-NEXT:    nopb ; nopa ; vst.srs.s8.s32 cm3, s0, [p1], #32; nopxm ; nopv
  ; CHECK-NEXT:  // %bb.3: // %for.cond.cleanup
  ; CHECK-NEXT:    vsrs.s8.s32 wh0, cm0, s1; nopx
  ; CHECK-NEXT:    vsrs.s8.s32 wh2, cm1, s1
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    vups.s32.s8 cm2, wh0, s1
  ; CHECK-NEXT:    vups.s32.s8 cm3, wh2, s1
  ; CHECK-NEXT:    nop
  ; CHECK-NEXT:    vst.srs.s8.s32 cm2, s0, [p1], #32
  ; CHECK-NEXT:    vst.srs.s8.s32 cm3, s0, [p1], #32
  ; CHECK-NEXT:    .p2align 4
  ; CHECK-NEXT:  .LBB0_4: // %for.cond.cleanup
  ; CHECK-NEXT:    nopa ; ret lr
  ; CHECK-NEXT:    nop // Delay Slot 5
  ; CHECK-NEXT:    nop // Delay Slot 4
  ; CHECK-NEXT:    nop // Delay Slot 3
  ; CHECK-NEXT:    nop // Delay Slot 2
  ; CHECK-NEXT:    nop // Delay Slot 1
  entry:
    %cmp13 = icmp sgt i32 %n, 0
    br i1 %cmp13, label %for.body.preheader, label %for.cond.cleanup

  for.body.preheader:                               ; preds = %entry
    call void @llvm.set.loop.iterations.i32(i32 %n)
    br label %for.body

  for.body:                                         ; preds = %for.body.preheader, %for.body
    %in1.addr.016 = phi ptr addrspace(5) [ %incdec.ptr5, %for.body ], [ %in1, %for.body.preheader ]
    %out.addr.015 = phi ptr addrspace(7) [ %incdec.ptr, %for.body ], [ %out, %for.body.preheader ]
    %in2.addr.014 = phi ptr addrspace(6) [ %incdec.ptr6, %for.body ], [ %in2, %for.body.preheader ]
    %0 = load <64 x i8>, ptr addrspace(5) %in1.addr.016, align 32, !tbaa !2
    %1 = load <64 x i8>, ptr addrspace(6) %in2.addr.014, align 32, !tbaa !2
    %2 = tail call { <64 x i8>, <2 x i32> } @llvm.aie2.vbneg.ltz8(<64 x i8> %1)
    %3 = extractvalue { <64 x i8>, <2 x i32> } %2, 0
    %and.i = and <64 x i8> %3, %0
    %4 = tail call { <64 x i8>, <2 x i32> } @llvm.aie2.vbneg.ltz8(<64 x i8> %0)
    %5 = extractvalue { <64 x i8>, <2 x i32> } %4, 0
    %and.i12 = and <64 x i8> %5, %1
    %or.i = or <64 x i8> %and.i12, %and.i
    %incdec.ptr = getelementptr inbounds i8, ptr addrspace(7) %out.addr.015, i20 64
    store <64 x i8> %or.i, ptr addrspace(7) %out.addr.015, align 32, !tbaa !2
    %incdec.ptr5 = getelementptr inbounds i8, ptr addrspace(5) %in1.addr.016, i20 64
    %incdec.ptr6 = getelementptr inbounds i8, ptr addrspace(6) %in2.addr.014, i20 64
    %6 = call i1 @llvm.loop.decrement.i32(i32 1)
    br i1 %6, label %for.body, label %for.cond.cleanup, !llvm.loop !5

  for.cond.cleanup:                                 ; preds = %for.body, %entry
    ret void
  }

  declare { <64 x i8>, <2 x i32> } @llvm.aie2.vbneg.ltz8(<64 x i8>) #1
  declare void @llvm.set.loop.iterations.i32(i32) #2
  declare i1 @llvm.loop.decrement.i32(i32) #2

  attributes #0 = { mustprogress nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
  attributes #1 = { nocallback nofree nosync nounwind willreturn memory(none) }
  attributes #2 = { nocallback noduplicate nofree nosync nounwind willreturn }

  !llvm.module.flags = !{!0}
  !llvm.ident = !{!1}

  !0 = !{i32 1, !"wchar_size", i32 4}
  !1 = !{!"clang version 19.0.0git (git@github.com:Xilinx/llvm-aie.git 7dacd4f131902667e5df5f8a9eb9322a88a81437)"}
  !2 = !{!3, !3, i64 0}
  !3 = !{!"omnipotent char", !4, i64 0}
  !4 = !{!"Simple C++ TBAA"}
  !5 = distinct !{!5, !6, !7}
  !6 = !{!"llvm.loop.mustprogress"}
  !7 = !{!"llvm.loop.itercount.range", i64 10}

...
---
name:            round
alignment:       16
tracksRegLiveness: true
body:             |
  bb.0.entry (align 16):
    successors: %bb.1(0x50000000), %bb.3(0x30000000)
    liveins: $p0, $p1, $p2, $r0

    $r1 = MOV_RLC_imm10_pseudo 0
    $r1 = GE $r1, $r0
    JNZ $r1, %bb.3
    DelayedSchedBarrier

  bb.1.for.body.preheader:
    successors: %bb.2(0x80000000)
    liveins: $p0, $p1, $p2, $r0

    $lc = ADD_NC $r0, 0
    $ls = MOVXM_lng_cg %bb.2
    $le = MOVXM_lng_cg <mcsymbol .L_LEnd0>

  bb.2.for.body (align 16):
    successors: %bb.2(0x7c000000), %bb.3(0x04000000)
    liveins: $p0, $p1, $s0, $s1

    $cm0, $p0 = VLDA_UPS_S32_S8_ag_pstm_nrm_imm $s0, $p0, 32, implicit-def $srups_of, implicit $crsat :: (load (<32 x s8>) from %ir.in1.addr.016, !tbaa !4, addrspace 5)
    $cm1, $p0 = VLDA_UPS_S32_S8_ag_pstm_nrm_imm $s0, $p0, 32, implicit-def $srups_of, implicit $crsat :: (load (<32 x s8>) from %ir.in1.addr.016, !tbaa !4, addrspace 5)
    $wh0 = VSRS_S8_S32_mv_w_srs $cm0, renamable $s1, implicit-def dead $srsrs_of, implicit $crsat, implicit $crrnd
    $wh2 = VSRS_S8_S32_mv_w_srs $cm1, renamable $s1, implicit-def dead $srsrs_of, implicit $crsat, implicit $crrnd
    $cm2 = VUPS_S32_S8_mv_ups_w2c $wh0, $s1, implicit-def dead $srups_of, implicit $crsat
    $cm3 = VUPS_S32_S8_mv_ups_w2c $wh2, $s1, implicit-def dead $srups_of, implicit $crsat
    $p1 = VST_SRS_S8_S32_ag_pstm_nrm_imm $p1, 32, $cm2, $s0, implicit-def $srsrs_of, implicit $crsat, implicit $crrnd :: (store (<32 x s8>) into %ir.out.addr.015, !tbaa !4, addrspace 6)
    $p1 = VST_SRS_S8_S32_ag_pstm_nrm_imm $p1, 32, $cm3, $s0, implicit-def $srsrs_of, implicit $crsat, implicit $crrnd :: (store (<32 x s8>) into %ir.out.addr.015, !tbaa !4, addrspace 6)

    PseudoLoopEnd <mcsymbol .L_LEnd0>, %bb.2

  bb.3.for.cond.cleanup (align 16):
    RET implicit $lr
    DelayedSchedBarrier

...
