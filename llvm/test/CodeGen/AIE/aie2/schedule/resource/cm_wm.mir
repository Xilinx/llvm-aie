# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -march=aie2 %topdown-single -run-pass=postmisched %s -o - \
# RUN:   | FileCheck %s

# VUPS accesses CM_WM write port in cycle 3, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP such that the
# two instructions don't access the same port in the same cycle
---
name:            E3_VUPS_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E3_VUPS_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $cm8 = VUPS_S64_D32_mv_ups_x2c killed $x2, killed $s2, implicit-def $srups_of, implicit $crsat, implicit $crupssign
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $cm8 = VUPS_S64_D32_mv_ups_x2c $x2, $s2, implicit-def $srups_of, implicit $crsat, implicit $crupssign
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VUPS accesses CM_WM write port in cycle 3, VCONV_FP32_BF16 in cycle 2
# The scheduler needs to insert an additional NOP such that the
# two instructions don't access the same port in the same cycle
---
name:            E3_VUPS_E2_VCONV_FP32_BF16_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E3_VUPS_E2_VCONV_FP32_BF16_CM_WM_PORT
    ; CHECK: $cm8 = VUPS_S64_D32_mv_ups_x2c $x2, killed $s2, implicit-def $srups_of, implicit $crsat, implicit $crupssign
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bml5 = VCONV_FP32_BF16 killed $wl1
    ; CHECK-NEXT: $bml6 = VCONV_FP32_BF16 killed $wl2
    ; CHECK-NEXT: NOP
  $cm8 = VUPS_S64_D32_mv_ups_x2c $x2, $s2, implicit-def $srups_of, implicit $crsat, implicit $crupssign
  $bml5 = VCONV_FP32_BF16 $wl1
  $bml6 = VCONV_FP32_BF16 $wl2
...

# VLDA accesses CM_WM write port in cycle 7, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 4th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E7_VLDA_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E7_VLDA_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $amll0 = VLDA_dmw_lda_am_ag_idx_imm killed $p0, 0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $amll0 = VLDA_dmw_lda_am_ag_idx_imm $p0, 0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VLDA_POSTINC accesses CM_WM write port in cycle 7, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 4th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E7_VLDA_POSTINC_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E7_VLDA_POSTINC_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $amll0, $p0 = VLDA_dmw_lda_am_ag_pstm_nrm_imm killed $p0, 0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $amll0, $p0 = VLDA_dmw_lda_am_ag_pstm_nrm_imm $p0, 0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VLDA.2D accesses CM_WM write port in cycle 7, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 4th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E7_VLDA_2D_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E7_VLDA_2D_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $amhh0, $p0, $dc0 = VLDA_2D_dmw_lda_am killed $p0, killed $d0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $amhh0, $p0, $dc0 = VLDA_2D_dmw_lda_am $p0, $d0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...


# VLDA.3D accesses CM_WM write port in cycle 7, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 4th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E7_VLDA_3D_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E7_VLDA_3D_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $amhh0, $p0, $dc0, $dc4 = VLDA_3D_dmw_lda_am killed $p0, killed $d0_3d
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $amhh0, $p0, $dc0, $dc4 = VLDA_3D_dmw_lda_am $p0, $d0_3d
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VLDA accesses CM_WM write port in cycle 7, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 4th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E7_VLDA_CONV_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E7_VLDA_CONV_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $bml0 = VLDA_CONV_FP32_BF16_ag_idx_imm killed $p0, 0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $bml0 = VLDA_CONV_FP32_BF16_ag_idx_imm $p0, 0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VLDA_POSTINC_CONV accesses CM_WM write port in cycle 7, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 4th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E7_VLDA_CONV_POSTINC_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E7_VLDA_CONV_POSTINC_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $bml0, $p0 = VLDA_CONV_FP32_BF16_pstm_nrm_imm killed $p0, 0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $bml0, $p0 = VLDA_CONV_FP32_BF16_pstm_nrm_imm $p0, 0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VLDA.3D.CONV accesses CM_WM write port in cycle 7, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 4th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E7_VLDA_3D_CONV_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E7_VLDA_3D_CONV_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $bmh0, $p0, $dc0, $dc4 = VLDA_3D_CONV_FP32_BF16 killed $p0, killed $d0_3d
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $bmh0, $p0, $dc0, $dc4 = VLDA_3D_CONV_FP32_BF16 $p0, $d0_3d
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VLDA.UPS accesses CM_WM write port in cycle 9, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 6th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E9_VLDA_UPS_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E9_VLDA_UPS_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $bmh0 = VLDA_UPS_S32_S16_ag_idx_imm killed $s0, killed $p0, 0, implicit-def $srups_of, implicit $crsat
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $bmh0 = VLDA_UPS_S32_S16_ag_idx_imm $s0, $p0, 0, implicit-def $srups_of, implicit $crsat
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VLDA.POSTINC.UPS accesses CM_WM write port in cycle 9, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 6th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E9_VLDA_POSTINC_UPS_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E9_VLDA_POSTINC_UPS_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $bmh0, $p0 = VLDA_UPS_S32_D16_ag_pstm_nrm_imm killed $s0, killed $p0, 0, implicit-def $srups_of, implicit $crsat, implicit $crupssign
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $bmh0, $p0 = VLDA_UPS_S32_D16_ag_pstm_nrm_imm $s0, $p0, 0, implicit-def $srups_of, implicit $crsat, implicit $crupssign
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VLDA.2D.UPS accesses CM_WM write port in cycle 9, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 6th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E9_VLDA_2D_UPS_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E9_VLDA_2D_UPS_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $bmh0, $p0, $dc4 = VLDA_2D_UPS_S32_D16 killed $s0, killed $p0, killed $d4, implicit-def $srups_of, implicit $crsat, implicit $crupssign
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $bmh0, $p0, $dc4 = VLDA_2D_UPS_S32_D16 $s0, $p0, $d4, implicit-def $srups_of, implicit $crsat, implicit $crupssign
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VLDA.3D.UPS accesses CM_WM write port in cycle 9, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 6th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E9_VLDA_3D_UPS_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E9_VLDA_3D_UPS_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $bmh0, $p0, $dc3, $dc7 = VLDA_3D_UPS_S32_D16 killed $s0, killed $p0, killed $d3_3d, implicit-def $srups_of, implicit $crsat, implicit $crupssign
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $bmh0, $p0, $dc3, $dc7 = VLDA_3D_UPS_S32_D16 $s0, $p0, $d3_3d, implicit-def $srups_of, implicit $crsat, implicit $crupssign
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...

# VLDA.2D.CONV accesses CM_WM write port in cycle 7, VSHUFFLE in cycle 2
# The scheduler needs to insert an additional NOP after the 5th VSHUFFLE
# such that the two instructions don't access the same port in the same cycle
---
name:            E7_VLDA_2D_CONV_E2_VSHUFFLE_CM_WM_PORT
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E7_VLDA_2D_CONV_E2_VSHUFFLE_CM_WM_PORT
    ; CHECK: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh0, $p0, $dc4 = VLDA_2D_CONV_FP32_BF16 killed $p0, killed $d4
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VSHUFFLE $x0, $x1, $r0
    ; CHECK-NEXT: $bmh7 = VSHUFFLE killed $x0, killed $x1, killed $r0
    ; CHECK-NEXT: NOP
  $bmh0, $p0, $dc4 = VLDA_2D_CONV_FP32_BF16 $p0, $d4
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
  $bmh7 = VSHUFFLE $x0, $x1, $r0
...


# VMOV_mv_x accesses the CM_WM port in cycle E2, VLDA in cycle E7
# The scheduler needs to insert an additional NOP after the 5th VMOV_mv_x
# such that the two instructions don't access the same port in the same cycle
---
name:            E2_VMOV_X_E7_VLD
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E2_VMOV_X_E7_VLD
    ; CHECK: $bmh7 = VMOV_mv_x $bml6
    ; CHECK-NEXT: $amll0 = VLDA_dmw_lda_am_ag_idx_imm killed $p0, 0
    ; CHECK-NEXT: $bmh7 = VMOV_mv_x $bml6
    ; CHECK-NEXT: $bmh7 = VMOV_mv_x $bml6
    ; CHECK-NEXT: $bmh7 = VMOV_mv_x $bml6
    ; CHECK-NEXT: $bmh7 = VMOV_mv_x $bml6
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $bmh7 = VMOV_mv_x $bml6
    ; CHECK-NEXT: $bmh7 = VMOV_mv_x killed $bml6
    ; CHECK-NEXT: NOP
  $amll0 = VLDA_dmw_lda_am_ag_idx_imm $p0, 0
  $bmh7 = VMOV_mv_x $bml6
  $bmh7 = VMOV_mv_x $bml6
  $bmh7 = VMOV_mv_x $bml6
  $bmh7 = VMOV_mv_x $bml6
  $bmh7 = VMOV_mv_x $bml6
  $bmh7 = VMOV_mv_x $bml6
  $bmh7 = VMOV_mv_x $bml6
...

# VMOV_mv_w accesses the CM_WM port in cycle E2, VLDA in cycle E7
# The scheduler needs to insert an additional NOP after the 5th VMOV_mv_x
# such that the two instructions don't access the same port in the same cycle
---
name:            E2_VMOV_W_E7_VLD
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: E2_VMOV_W_E7_VLD
    ; CHECK: $amhh7 = VMOV_mv_w $amll6
    ; CHECK-NEXT: $amll0 = VLDA_dmw_lda_am_ag_idx_imm killed $p0, 0
    ; CHECK-NEXT: $amhh7 = VMOV_mv_w $amll6
    ; CHECK-NEXT: $amhh7 = VMOV_mv_w $amll6
    ; CHECK-NEXT: $amhh7 = VMOV_mv_w $amll6
    ; CHECK-NEXT: $amhh7 = VMOV_mv_w $amll6
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $amhh7 = VMOV_mv_w $amll6
    ; CHECK-NEXT: $amhh7 = VMOV_mv_w killed $amll6
    ; CHECK-NEXT: NOP
  $amll0 = VLDA_dmw_lda_am_ag_idx_imm $p0, 0
  $amhh7 = VMOV_mv_w $amll6
  $amhh7 = VMOV_mv_w $amll6
  $amhh7 = VMOV_mv_w $amll6
  $amhh7 = VMOV_mv_w $amll6
  $amhh7 = VMOV_mv_w $amll6
  $amhh7 = VMOV_mv_w $amll6
  $amhh7 = VMOV_mv_w $amll6
...
