# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -mtriple=aie2 -run-pass=postmisched %s -o - | FileCheck %s

# partial store does a late read of its source register as part
# of read-modify write
# That causes a large anti latency with early writers

---
name:            test
alignment:       16
body:             |
  bb.0.entry:
    liveins: $r0, $p0
    ; CHECK-LABEL: name: test
    ; CHECK: liveins: $r0, $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: ST_S8_ag_idx_imm killed $r0, $p0, 0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r0 = MOVXM_lng_cg 0
    ; CHECK-NEXT: ST_S16_ag_idx_imm killed $r0, killed $p0, 2
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r0 = MOVXM_lng_cg 0
    ; CHECK-NEXT: NOP
    ST_S8_ag_idx_imm $r0, $p0, 0
    $r0 = MOVXM_lng_cg 0
    ST_S16_ag_idx_imm $r0, $p0, 2
    $r0 = MOVXM_lng_cg 0
...

---
name:           test_2
alignment:      16
body:           |
  bb.0.entry:
    liveins: $r0, $p0
    ; CHECK-LABEL: name: test_2
    ; CHECK: liveins: $r0, $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $p0 = ST_S8_ag_pstm_nrm_imm killed $r0, killed $p0, 0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r0 = MOVXM_lng_cg 0
    ; CHECK-NEXT: $p0 = ST_S8_ag_pstm_nrm_imm killed $r0, killed $p0, 2
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r0 = MOVXM_lng_cg 0
    ; CHECK-NEXT: NOP
    $p0 = ST_S8_ag_pstm_nrm_imm $r0, $p0, 0
    $r0 = MOVXM_lng_cg 0
    $p0 = ST_S8_ag_pstm_nrm_imm $r0, $p0, 2
    $r0 = MOVXM_lng_cg 0
...

# No delay slots are needed after the first load because the store reads in E7 when the load's write has already taken place
# 6 delay slots are needed after the first store to ensure $r0 is stored in E11 (relative to ST) before it is loaded in E5 (relative to LDA)
# 5 delay slots are needed after the 2nd store to make sure $r1 has been read (E7) before the MOV writes it (E1)
# 7 delay slots are needed after the last store to make sure the pipeline is empty at the end of the basic block (the store unit being used in E8)
---
name:            II_STHB_2D
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: II_STHB_2D
    ; CHECK: $r0, $p0 = LDA_dms_lda_pstm_nrm_imm killed $p0, 4
    ; CHECK-NEXT: $p1, $dc0 = ST_2D_S16 killed $r0, killed $p1, $d0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r0, $p2 = LDA_dms_lda_pstm_nrm_imm killed $p2, 4
    ; CHECK-NEXT: $p3, $dc0 = ST_2D_S16 killed $r1, killed $p3, killed $d0
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r1 = MOVXM_lng_cg 0
    ; CHECK-NEXT: $p2, $dc4 = ST_2D_S8 killed $r1, killed $p2, killed $d4
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
  $r0, $p0 = LDA_dms_lda_pstm_nrm_imm $p0, 4
  $p1, $dc0 = ST_2D_S16 $r0, $p1, $d0
  $r0, $p2 = LDA_dms_lda_pstm_nrm_imm $p2, 4
  $p3, $dc0 = ST_2D_S16 $r1, $p3, $d0
  $r1 = MOVXM_lng_cg 0
  $p2, $dc4 = ST_2D_S8 $r1, $p2, $d4
...

# To test the latencies of all inputs, we need 2 stores back to back
# Once alias analysis is supported for partword stores, we expect the 2 stores to
# be scheduled back to back. For now a hard stop of all memory
# operations is enforced during the critical section of the store instruction.
---
name:            II_STHB_2D_backTOback
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: II_STHB_2D_backTOback
    ; CHECK: $p3, $dc0 = ST_2D_S16 $r1, killed $p3, $d0 :: (store (s16) into stack - 8)
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $p3, $dc0 = ST_2D_S16 killed $r1, killed $p3, killed $d0 :: (store (s16) into stack - 4)
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    $p3, $dc0 = ST_2D_S16 $r1, $p3, $d0 :: (store (s16) into stack - 8)
    $p3, $dc0 = ST_2D_S16 $r1, $p3, $d0 :: (store (s16) into stack - 4)
...
---
name:            II_STHB_3D
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: II_STHB_3D
    ; CHECK: $r0, $p0 = LDA_dms_lda_pstm_nrm_imm killed $p0, 4
    ; CHECK-NEXT: $p1, $dc0, $dc4 = ST_3D_S16 killed $r0, killed $p1, $d0_3d
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r0, $p2 = LDA_dms_lda_pstm_nrm_imm killed $p2, 4
    ; CHECK-NEXT: $p3, $dc0, $dc4 = ST_3D_S16 killed $r1, killed $p3, killed $d0_3d
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $r1 = MOVXM_lng_cg 0
    ; CHECK-NEXT: $p2, $dc3, $dc7 = ST_3D_S8 killed $r1, killed $p2, killed $d3_3d
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
  $r0, $p0 = LDA_dms_lda_pstm_nrm_imm $p0, 4
  $p1, $dc0, $dc4 = ST_3D_S16 $r0, $p1, $d0_3d
  $r0, $p2 = LDA_dms_lda_pstm_nrm_imm $p2, 4
  $p3, $dc0, $dc4 = ST_3D_S16 $r1, $p3, $d0_3d
  $r1 = MOVXM_lng_cg 0
  $p2, $dc3, $dc7 = ST_3D_S8 $r1, $p2, $d3_3d
...

# To test the latencies of all inputs, we need 2 stores back to back
# Once alias analysis is supported for partword stores, we expect the 2 stores to
# be scheduled back to back. For now a hard stop of all memory
# operations is enforced during the critical section of the store instruction.
---
name:            II_STHB_3D_backTOback
alignment:       16
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: II_STHB_3D_backTOback
    ; CHECK: $p3, $dc0, $dc4 = ST_3D_S16 $r1, killed $p3, $d0_3d :: (store (s16) into stack - 8)
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: $p3, $dc0, $dc4 = ST_3D_S16 killed $r1, killed $p3, killed $d0_3d :: (store (s16) into stack - 4)
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    ; CHECK-NEXT: NOP
    $p3, $dc0, $dc4 = ST_3D_S16 $r1, $p3, $d0_3d :: (store (s16) into stack - 8)
    $p3, $dc0, $dc4 = ST_3D_S16 $r1, $p3, $d0_3d :: (store (s16) into stack - 4)
...
