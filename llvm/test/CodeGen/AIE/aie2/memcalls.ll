; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc --mtriple=aie2 --issue-limit=1 %s -o - | FileCheck %s
define void @callmemcpy(ptr %p, ptr %q) {
; CHECK-LABEL: callmemcpy:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    paddb [sp], #32; nopx
; CHECK-NEXT:    st lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    jl #memcpy
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    mov p2, p1 // Delay Slot 3
; CHECK-NEXT:    mov p1, p0 // Delay Slot 2
; CHECK-NEXT:    mova r0, #40 // Delay Slot 1
; CHECK-NEXT:    lda lr, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 1
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr %p, ptr %q, i32 40, i1 false)
  ret void
}

define void @callmemmov(ptr %p, ptr %q) {
; CHECK-LABEL: callmemmov:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    paddb [sp], #32; nopx
; CHECK-NEXT:    st lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    jl #memmov
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    mov p2, p1 // Delay Slot 3
; CHECK-NEXT:    mov p1, p0 // Delay Slot 2
; CHECK-NEXT:    mova r0, #40 // Delay Slot 1
; CHECK-NEXT:    lda lr, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 1
entry:
  %call = tail call ptr @memmov(ptr %p, ptr %q, i32 40)
  ret void
}


define void @callmemset(ptr %p) {
; CHECK-LABEL: callmemset:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    paddb [sp], #32; nopx
; CHECK-NEXT:    st lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    jl #memset
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    mova r0, #42 // Delay Slot 3
; CHECK-NEXT:    mova r1, #40 // Delay Slot 2
; CHECK-NEXT:    mov p1, p0 // Delay Slot 1
; CHECK-NEXT:    lda lr, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 1
entry:
  tail call void @llvm.memset.p0.i32(ptr %p, i8 42, i32 40, i1 false)
  ret void
}

declare void @llvm.memcpy.p0.p0.i32(ptr, ptr, i32, i1)
declare ptr @memmov(ptr, ptr, i32 )
declare void @llvm.memset.p0.i32(ptr, i8, i32, i1)
