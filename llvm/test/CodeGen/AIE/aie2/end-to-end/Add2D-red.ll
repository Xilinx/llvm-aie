; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2 %s -o - | FileCheck %s --check-prefix=ASM

; This is a reduced version of the Add2D_0 MLLib benchmark which only contains
; the interesting loop nest. The point is to verify SWP.

%struct.add2d_internal_params = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i8, bfloat, [28 x i8] }

; Function Attrs: nounwind memory(none)
declare <16 x i64> @llvm.aie2.v32acc32() #0

; Function Attrs: nounwind memory(inaccessiblemem: read)
declare <16 x i64> @llvm.aie2.acc32.v32.I256.ups(<32 x i8>, i32, i32) #1

; Function Attrs: nounwind memory(none)
declare <32 x i8> @llvm.aie2.v32int8() #0

; Function Attrs: nounwind memory(inaccessiblemem: read)
declare <32 x i8> @llvm.aie2.I256.v32.acc32.srs(<16 x i64>, i32, i32) #1

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
declare <16 x i64> @llvm.aie2.add.acc(<16 x i64>, <16 x i64>, i32) #2

; Function Attrs: nounwind memory(none)
declare { ptr, i20, i20 } @llvm.aie2.add.3d(ptr, i20, i20, i20, i20, i20, i20, i20) #0

; Function Attrs: mustprogress noinline
define void @add2d(ptr noalias %params, ptr noalias %ifm1_data, ptr noalias %ifm2_data, ptr noalias %ofm_data, ptr %.out, ptr %conv.i.i.i.out, ptr %idx.ext9.out, ptr %.out1, ptr %.out2, ptr %.out3, ptr %.out4, ptr %.out5, ptr %conv.i.i.i.i.i.out, ptr %.out6, ptr %conv.i.i.i46.out, ptr %xtraiter.out, ptr %in_ptr1.051.unr.ce.out, ptr %in_ptr2.0.in50.unr.ce.out, ptr %out_ptr.049.unr.ce.out, ptr %itr_left_cnt0.048.unr.ce.out, ptr %itr_left_cnt1.047.unr.ce.out) #3 {
; ASM-LABEL: add2d:
; ASM:         .p2align 4
; ASM-NEXT:  // %bb.0: // %newFuncRoot
; ASM-NEXT:    paddb [sp], #32
; ASM-NEXT:    st p7, [sp, #-32] // 4-byte Folded Spill
; ASM-NEXT:    paddb [p0], #40; st p6, [sp, #-28] // 4-byte Folded Spill
; ASM-NEXT:    lda m2, [p0], #-4
; ASM-NEXT:    lda m5, [p0], #8
; ASM-NEXT:    lda m4, [p0], #8
; ASM-NEXT:    lda m3, [p0], #-24
; ASM-NEXT:    lda r4, [p0], #36
; ASM-NEXT:    lda r1, [p0], #-32
; ASM-NEXT:    lda r0, [p0], #-12; mov p6, sp
; ASM-NEXT:    lda r2, [p0], #40; paddb [p6], #-36
; ASM-NEXT:    lda p6, [p6, #0]; mov p7, sp
; ASM-NEXT:    paddb [p7], #-40
; ASM-NEXT:    lda p7, [p7, #0]
; ASM-NEXT:    lda m1, [p0], #36
; ASM-NEXT:    lda m0, [p0], #-8
; ASM-NEXT:    lda dn0, [p0], #-8
; ASM-NEXT:    st r2, [p4, #0]
; ASM-NEXT:    lda dj0, [p0], #12; nez r3, r0; mov p4, sp
; ASM-NEXT:    st r3, [p5, #0]
; ASM-NEXT:    lda dn4, [p0], #-8; paddb [p4], #-44; mov p5, sp
; ASM-NEXT:    lda p4, [p4, #0]; paddb [p5], #-48
; ASM-NEXT:    lda p5, [p5, #0]
; ASM-NEXT:    lda dj4, [p0], #-36
; ASM-NEXT:    nop
; ASM-NEXT:    st m1, [p6, #0]
; ASM-NEXT:    lda r0, [p0], #-36; mov p6, sp
; ASM-NEXT:    st m0, [p7, #0]
; ASM-NEXT:    st dj0, [p4, #0]
; ASM-NEXT:    lda r5, [p0, #0]; mov p4, sp
; ASM-NEXT:    paddb [p4], #-60; st dj4, [p5, #0]
; ASM-NEXT:    lda p7, [p4, #0]; paddb [p6], #-52; mov p5, sp
; ASM-NEXT:    lda r6, [p6, #0]; paddb [p5], #-76; mov p4, sp
; ASM-NEXT:    lda r9, [p5, #0]; paddb [p4], #-64; mov p5, sp
; ASM-NEXT:    lda r8, [p4, #0]; paddb [p5], #-80; mov p0, sp
; ASM-NEXT:    lda r10, [p5, #0]; paddb [p0], #-68; mov p5, sp
; ASM-NEXT:    lda p4, [p0, #0]; paddb [p5], #-84; mov p6, sp
; ASM-NEXT:    lda r11, [p5, #0]
; ASM-NEXT:    paddb [p6], #-56; mov p0, sp
; ASM-NEXT:    lda p6, [p6, #0]; paddb [p0], #-72; mov p5, sp
; ASM-NEXT:    lda p0, [p0, #0]; paddb [p5], #-88
; ASM-NEXT:    lda r12, [p5, #0]; mov p5, sp
; ASM-NEXT:    paddb [p5], #-92
; ASM-NEXT:    lda r13, [p5, #0]
; ASM-NEXT:    mova r6, #1; add r7, r1, #-1; mov p5, r6
; ASM-NEXT:    mova r6, #3; ne r4, r4, r6
; ASM-NEXT:    st dn0, [p5, #0]; ltu r7, r7, r6
; ASM-NEXT:    st dn4, [p6, #0]; jz r7, #.LBB0_2
; ASM-NEXT:    nez r0, r0; mov p6, r8 // Delay Slot 5
; ASM-NEXT:    st r0, [p7, #0] // Delay Slot 4
; ASM-NEXT:    paddb [p2], m5; st r5, [p6, #0] // Delay Slot 3
; ASM-NEXT:    padda [p1], m2; paddb [p2], m4; and r8, r1, r6; st r4, [p4, #0] // Delay Slot 2
; ASM-NEXT:    mova r6, #0; paddb [p2], m3; st r8, [p0, #0] // Delay Slot 1
; ASM-NEXT:  // %bb.1:
; ASM-NEXT:    nopb ; nopa ; nops ; j #.LBB0_6; nopv
; ASM-NEXT:    nopa ; nopx // Delay Slot 5
; ASM-NEXT:    nop // Delay Slot 4
; ASM-NEXT:    nop // Delay Slot 3
; ASM-NEXT:    nop // Delay Slot 2
; ASM-NEXT:    mova r0, #0 // Delay Slot 1
; ASM-NEXT:    .p2align 4
; ASM-NEXT:  .LBB0_2: // %entry.new
; ASM-NEXT:    vlda.ups.s32.d8 cm0, s1, [p1], m1; nopb ; nopx ; mov dc0, #0; nops
; ASM-NEXT:    vlda.ups.s32.d8 cm2, s1, [p1], m1; mov dc4, dc0
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm1, s1, [p2], d0
; ASM-NEXT:    vlda.ups.s32.d8 cm3, s1, [p1], m1
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm4, s1, [p2], d0; mov crUPSSign, r3
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm5, s1, [p2], d0; mov s1, r2
; ASM-NEXT:    vlda.ups.s32.d8 cm0, s1, [p1], m1
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm1, s1, [p2], d0
; ASM-NEXT:    vlda.ups.s32.d8 cm2, s1, [p1], m1
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm8, s1, [p2], d0
; ASM-NEXT:    vlda.ups.s32.d8 cm5, s1, [p1], m1
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm6, s1, [p2], d0
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm4, s1, [p2], d0; vadd cm6, cm1, cm0, r0
; ASM-NEXT:    vlda.ups.s32.d8 cm3, s1, [p1], m1
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm1, s1, [p2], d0; movx r6, #-4; vadd cm4, cm4, cm2, r0
; ASM-NEXT:    vlda.ups.s32.d8 cm0, s1, [p1], m1; and r1, r1, r6; vadd cm3, cm5, cm3, r0
; ASM-NEXT:    add r1, r1, #-4; mov crSRSSign, r4
; ASM-NEXT:    add r1, r1, #-4; mov s0, r5
; ASM-NEXT:    vst.srs.d8.s32 cm6, s0, [p3], #32; jz r1, #.LBB0_5
; ASM-NEXT:    vst.srs.d8.s32 cm4, s0, [p3], #32; vadd cm8, cm8, cm2, r0 // Delay Slot 5
; ASM-NEXT:    vst.srs.d8.s32 cm3, s0, [p3], #32; vadd cm7, cm1, cm0, r0 // Delay Slot 4
; ASM-NEXT:    nop // Delay Slot 3
; ASM-NEXT:    nop // Delay Slot 2
; ASM-NEXT:    nop // Delay Slot 1
; ASM-NEXT:    .p2align 4
; ASM-NEXT:  .LBB0_3: // %for.body
; ASM-NEXT:    // =>This Inner Loop Header: Depth=1
; ASM-NEXT:    vlda.ups.s32.d8 cm2, s1, [p1], m1; nopb ; nopxm ; nops
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm6, s1, [p2], d0
; ASM-NEXT:    vlda.ups.s32.d8 cm5, s1, [p1], m1; vst.srs.d8.s32 cm7, s0, [p3], #32; vadd cm3, cm4, cm3, r0
; ASM-NEXT:    vlda.ups.s32.d8 cm3, s1, [p1], m1; vadd cm5, cm6, cm5, r0
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm6, s1, [p2], d0; add r1, r1, #-4; vadd cm7, cm1, cm0, r0
; ASM-NEXT:    vlda.ups.s32.d8 cm0, s1, [p1], m1; jnz r1, #.LBB0_3
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm4, s1, [p2], d0 // Delay Slot 5
; ASM-NEXT:    vlda.3d.ups.s32.d8 cm1, s1, [p2], d0; vst.srs.d8.s32 cm8, s0, [p3], #32 // Delay Slot 4
; ASM-NEXT:    vst.srs.d8.s32 cm5, s0, [p3], #32 // Delay Slot 3
; ASM-NEXT:    nop // Delay Slot 2
; ASM-NEXT:    vst.srs.d8.s32 cm3, s0, [p3], #32; vadd cm8, cm6, cm2, r0 // Delay Slot 1
; ASM-NEXT:  // %bb.4:
; ASM-NEXT:    nopb ; nopa ; nops ; nopxm ; nopv
; ASM-NEXT:    .p2align 4
; ASM-NEXT:  .LBB0_5:
; ASM-NEXT:    nopb ; nopa ; nops ; nopxm ; vadd cm5, cm6, cm5, r0
; ASM-NEXT:    vadd cm3, cm4, cm3, r0
; ASM-NEXT:    vadd cm0, cm1, cm0, r0
; ASM-NEXT:    nop
; ASM-NEXT:    nop
; ASM-NEXT:    vst.srs.d8.s32 cm7, s0, [p3], #32
; ASM-NEXT:    vst.srs.d8.s32 cm8, s0, [p3], #32
; ASM-NEXT:    vst.srs.d8.s32 cm5, s0, [p3], #32
; ASM-NEXT:    vst.srs.d8.s32 cm3, s0, [p3], #32; mov crUPSSign, #0
; ASM-NEXT:    vst.srs.d8.s32 cm0, s0, [p3], #32; mov r6, dc0
; ASM-NEXT:    mov r0, dc4
; ASM-NEXT:    mov crSRSSign, #0
; ASM-NEXT:    .p2align 4
; ASM-NEXT:  .LBB0_6: // %for.cond.cleanup.unr-lcssa.split
; ASM-NEXT:    nopb ; lda p7, [sp, #-32]; nops ; nopxm ; nopv // 4-byte Folded Reload
; ASM-NEXT:    mov p0, r13
; ASM-NEXT:    st r0, [p0, #0]
; ASM-NEXT:    mov p0, r12
; ASM-NEXT:    st r6, [p0, #0]
; ASM-NEXT:    lda p6, [sp, #-28]; mov p0, r11 // 4-byte Folded Reload
; ASM-NEXT:    st p3, [p0, #0]; ret lr
; ASM-NEXT:    mov p0, r10 // Delay Slot 5
; ASM-NEXT:    st p2, [p0, #0] // Delay Slot 4
; ASM-NEXT:    mov p0, r9 // Delay Slot 3
; ASM-NEXT:    st p1, [p0, #0] // Delay Slot 2
; ASM-NEXT:    paddb [sp], #-32 // Delay Slot 1
newFuncRoot:
  br label %entry.split

entry.new:                                        ; preds = %entry.split
  %unroll_iter = and i32 %51, -4
  br label %for.body

for.body:                                         ; preds = %for.body, %entry.new
  %in_ptr1.051 = phi ptr addrspace(5) [ %add.ptr.ascast, %entry.new ], [ %add.ptr10.3, %for.body ]
  %in_ptr2.0.in50 = phi ptr [ %add.ptr6, %entry.new ], [ %41, %for.body ]
  %out_ptr.049 = phi ptr addrspace(5) [ %48, %entry.new ], [ %add.ptr21.3, %for.body ]
  %itr_left_cnt0.048 = phi i32 [ 0, %entry.new ], [ %38, %for.body ]
  %itr_left_cnt1.047 = phi i32 [ 0, %entry.new ], [ %40, %for.body ]
  %niter = phi i32 [ 0, %entry.new ], [ %niter.next.3, %for.body ]
  %in_ptr2.0 = addrspacecast ptr %in_ptr2.0.in50 to ptr addrspace(6)
  %0 = load <32 x i8>, ptr addrspace(5) %in_ptr1.051, align 32, !tbaa !4
  %1 = tail call noundef <16 x i64> @llvm.aie2.acc32.v32.I256.ups(<32 x i8> %0, i32 %55, i32 %conv.i.i.i)
  %add.ptr10 = getelementptr inbounds i8, ptr addrspace(5) %in_ptr1.051, i20 %idx.ext9
  %2 = load <32 x i8>, ptr addrspace(6) %in_ptr2.0, align 32, !tbaa !4
  %3 = tail call noundef <16 x i64> @llvm.aie2.acc32.v32.I256.ups(<32 x i8> %2, i32 %55, i32 %conv.i.i.i)
  %4 = trunc i32 %itr_left_cnt0.048 to i20
  %5 = trunc i32 %itr_left_cnt1.047 to i20
  %6 = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr %in_ptr2.0.in50, i20 %62, i20 %63, i20 %64, i20 %65, i20 %4, i20 %66, i20 %5)
  %7 = extractvalue { ptr, i20, i20 } %6, 1
  %8 = extractvalue { ptr, i20, i20 } %6, 2
  %9 = extractvalue { ptr, i20, i20 } %6, 0
  %10 = tail call noundef <16 x i64> @llvm.aie2.add.acc(<16 x i64> %3, <16 x i64> %1, i32 %conv.i.i.i.i.i)
  %11 = tail call noundef <32 x i8> @llvm.aie2.I256.v32.acc32.srs(<16 x i64> %10, i32 %68, i32 %conv.i.i.i46)
  store <32 x i8> %11, ptr addrspace(5) %out_ptr.049, align 32, !tbaa !4
  %add.ptr21 = getelementptr inbounds i8, ptr addrspace(5) %out_ptr.049, i20 32
  %in_ptr2.0.1 = addrspacecast ptr %9 to ptr addrspace(6)
  %12 = load <32 x i8>, ptr addrspace(5) %add.ptr10, align 32, !tbaa !4
  %13 = tail call noundef <16 x i64> @llvm.aie2.acc32.v32.I256.ups(<32 x i8> %12, i32 %55, i32 %conv.i.i.i)
  %add.ptr10.1 = getelementptr inbounds i8, ptr addrspace(5) %add.ptr10, i20 %idx.ext9
  %14 = load <32 x i8>, ptr addrspace(6) %in_ptr2.0.1, align 32, !tbaa !4
  %15 = tail call noundef <16 x i64> @llvm.aie2.acc32.v32.I256.ups(<32 x i8> %14, i32 %55, i32 %conv.i.i.i)
  %16 = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr %9, i20 %62, i20 %63, i20 %64, i20 %65, i20 %7, i20 %66, i20 %8)
  %17 = extractvalue { ptr, i20, i20 } %16, 1
  %18 = extractvalue { ptr, i20, i20 } %16, 2
  %19 = extractvalue { ptr, i20, i20 } %16, 0
  %20 = tail call noundef <16 x i64> @llvm.aie2.add.acc(<16 x i64> %15, <16 x i64> %13, i32 %conv.i.i.i.i.i)
  %21 = tail call noundef <32 x i8> @llvm.aie2.I256.v32.acc32.srs(<16 x i64> %20, i32 %68, i32 %conv.i.i.i46)
  store <32 x i8> %21, ptr addrspace(5) %add.ptr21, align 32, !tbaa !4
  %add.ptr21.1 = getelementptr inbounds i8, ptr addrspace(5) %out_ptr.049, i20 64
  %in_ptr2.0.2 = addrspacecast ptr %19 to ptr addrspace(6)
  %22 = load <32 x i8>, ptr addrspace(5) %add.ptr10.1, align 32, !tbaa !4
  %23 = tail call noundef <16 x i64> @llvm.aie2.acc32.v32.I256.ups(<32 x i8> %22, i32 %55, i32 %conv.i.i.i)
  %add.ptr10.2 = getelementptr inbounds i8, ptr addrspace(5) %add.ptr10.1, i20 %idx.ext9
  %24 = load <32 x i8>, ptr addrspace(6) %in_ptr2.0.2, align 32, !tbaa !4
  %25 = tail call noundef <16 x i64> @llvm.aie2.acc32.v32.I256.ups(<32 x i8> %24, i32 %55, i32 %conv.i.i.i)
  %26 = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr %19, i20 %62, i20 %63, i20 %64, i20 %65, i20 %17, i20 %66, i20 %18)
  %27 = extractvalue { ptr, i20, i20 } %26, 1
  %28 = extractvalue { ptr, i20, i20 } %26, 2
  %29 = extractvalue { ptr, i20, i20 } %26, 0
  %30 = tail call noundef <16 x i64> @llvm.aie2.add.acc(<16 x i64> %25, <16 x i64> %23, i32 %conv.i.i.i.i.i)
  %31 = tail call noundef <32 x i8> @llvm.aie2.I256.v32.acc32.srs(<16 x i64> %30, i32 %68, i32 %conv.i.i.i46)
  store <32 x i8> %31, ptr addrspace(5) %add.ptr21.1, align 32, !tbaa !4
  %add.ptr21.2 = getelementptr inbounds i8, ptr addrspace(5) %out_ptr.049, i20 96
  %in_ptr2.0.3 = addrspacecast ptr %29 to ptr addrspace(6)
  %32 = load <32 x i8>, ptr addrspace(5) %add.ptr10.2, align 32, !tbaa !4
  %33 = tail call noundef <16 x i64> @llvm.aie2.acc32.v32.I256.ups(<32 x i8> %32, i32 %55, i32 %conv.i.i.i)
  %add.ptr10.3 = getelementptr inbounds i8, ptr addrspace(5) %add.ptr10.2, i20 %idx.ext9
  %34 = load <32 x i8>, ptr addrspace(6) %in_ptr2.0.3, align 32, !tbaa !4
  %35 = tail call noundef <16 x i64> @llvm.aie2.acc32.v32.I256.ups(<32 x i8> %34, i32 %55, i32 %conv.i.i.i)
  %36 = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr %29, i20 %62, i20 %63, i20 %64, i20 %65, i20 %27, i20 %66, i20 %28)
  %37 = extractvalue { ptr, i20, i20 } %36, 1
  %38 = zext i20 %37 to i32
  %39 = extractvalue { ptr, i20, i20 } %36, 2
  %40 = zext i20 %39 to i32
  %41 = extractvalue { ptr, i20, i20 } %36, 0
  %42 = tail call noundef <16 x i64> @llvm.aie2.add.acc(<16 x i64> %35, <16 x i64> %33, i32 %conv.i.i.i.i.i)
  %43 = tail call noundef <32 x i8> @llvm.aie2.I256.v32.acc32.srs(<16 x i64> %42, i32 %68, i32 %conv.i.i.i46)
  store <32 x i8> %43, ptr addrspace(5) %add.ptr21.2, align 32, !tbaa !4
  %add.ptr21.3 = getelementptr inbounds i8, ptr addrspace(5) %out_ptr.049, i20 128
  %niter.next.3 = add i32 %niter, 4
  %niter.ncmp.3 = icmp eq i32 %niter.next.3, %unroll_iter
  br i1 %niter.ncmp.3, label %for.cond.cleanup.unr-lcssa.split, label %for.body, !llvm.loop !21

entry.split:                                      ; preds = %newFuncRoot
  %row_offset = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 10
  %44 = load i32, ptr %row_offset, align 8, !tbaa !25
  %idx.ext = trunc i32 %44 to i20
  %add.ptr = getelementptr inbounds i8, ptr %ifm1_data, i20 %idx.ext
  %add.ptr.ascast = addrspacecast ptr %add.ptr to ptr addrspace(5)
  %header_offset = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 9
  %45 = load i32, ptr %header_offset, align 4, !tbaa !29
  %idx.ext1 = trunc i32 %45 to i20
  %add.ptr2 = getelementptr inbounds i8, ptr %ifm2_data, i20 %idx.ext1
  %col_offset = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 11
  %46 = load i32, ptr %col_offset, align 4, !tbaa !30
  %idx.ext3 = trunc i32 %46 to i20
  %add.ptr4 = getelementptr inbounds i8, ptr %add.ptr2, i20 %idx.ext3
  %offset = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 13
  %47 = load i32, ptr %offset, align 4, !tbaa !31
  %idx.ext5 = trunc i32 %47 to i20
  %add.ptr6 = getelementptr inbounds i8, ptr %add.ptr4, i20 %idx.ext5
  %48 = addrspacecast ptr %ofm_data to ptr addrspace(5)
  %act = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 7
  %49 = load i32, ptr %act, align 4, !tbaa !32
  %num_inputs = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 16
  %50 = load i32, ptr %num_inputs, align 32, !tbaa !33
  %51 = freeze i32 %50
  %cmp = icmp sgt i32 %51, 7
  %52 = tail call noundef <16 x i64> @llvm.aie2.v32acc32()
  %53 = tail call noundef <32 x i8> @llvm.aie2.v32int8()
  %in0_sign = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 8
  %54 = load i32, ptr %in0_sign, align 32, !tbaa !34
  %tobool = icmp ne i32 %54, 0
  %shift_in = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 5
  %55 = load i32, ptr %shift_in, align 4, !tbaa !35
  store i32 %55, ptr %.out, align 4
  %conv.i.i.i = zext i1 %tobool to i32
  store i32 %conv.i.i.i, ptr %conv.i.i.i.out, align 4
  %incr1 = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 15
  %56 = load i32, ptr %incr1, align 4
  %idx.ext9 = trunc i32 %56 to i20
  store i20 %idx.ext9, ptr %idx.ext9.out, align 4
  %itr_left_incr2 = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 24
  %57 = load i32, ptr %itr_left_incr2, align 32
  %itr_left_wrap0 = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 22
  %58 = load i32, ptr %itr_left_wrap0, align 8
  %itr_left_incr0 = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 20
  %59 = load i32, ptr %itr_left_incr0, align 16
  %itr_left_wrap1 = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 23
  %60 = load i32, ptr %itr_left_wrap1, align 4
  %itr_left_incr1 = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 21
  %61 = load i32, ptr %itr_left_incr1, align 4
  %62 = trunc i32 %57 to i20
  store i20 %62, ptr %.out1, align 4
  %63 = trunc i32 %59 to i20
  store i20 %63, ptr %.out2, align 4
  %64 = trunc i32 %61 to i20
  store i20 %64, ptr %.out3, align 4
  %65 = trunc i32 %58 to i20
  store i20 %65, ptr %.out4, align 4
  %66 = trunc i32 %60 to i20
  store i20 %66, ptr %.out5, align 4
  %zero_ifm2 = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 12
  %67 = load i32, ptr %zero_ifm2, align 16
  %tobool17 = icmp ne i32 %67, 0
  %conv.i.i.i.i.i = zext i1 %tobool17 to i32
  store i32 %conv.i.i.i.i.i, ptr %conv.i.i.i.i.i.out, align 4
  %tobool19 = icmp ne i32 %49, 1
  %shift_out = getelementptr inbounds %struct.add2d_internal_params, ptr %params, i20 0, i32 3
  %68 = load i32, ptr %shift_out, align 4
  store i32 %68, ptr %.out6, align 4
  %conv.i.i.i46 = zext i1 %tobool19 to i32
  store i32 %conv.i.i.i46, ptr %conv.i.i.i46.out, align 4
  %69 = add i32 %51, -1
  %xtraiter = and i32 %51, 3
  store i32 %xtraiter, ptr %xtraiter.out, align 4
  %70 = icmp ult i32 %69, 3
  br i1 %70, label %for.cond.cleanup.unr-lcssa.split, label %entry.new

for.cond.cleanup.unr-lcssa.split:                 ; preds = %entry.split, %for.body
  %in_ptr1.051.unr.ce = phi ptr addrspace(5) [ %add.ptr.ascast, %entry.split ], [ %add.ptr10.3, %for.body ]
  %in_ptr2.0.in50.unr.ce = phi ptr [ %add.ptr6, %entry.split ], [ %41, %for.body ]
  %out_ptr.049.unr.ce = phi ptr addrspace(5) [ %48, %entry.split ], [ %add.ptr21.3, %for.body ]
  %itr_left_cnt0.048.unr.ce = phi i32 [ 0, %entry.split ], [ %38, %for.body ]
  %itr_left_cnt1.047.unr.ce = phi i32 [ 0, %entry.split ], [ %40, %for.body ]
  store i32 %itr_left_cnt1.047.unr.ce, ptr %itr_left_cnt1.047.unr.ce.out, align 4
  store i32 %itr_left_cnt0.048.unr.ce, ptr %itr_left_cnt0.048.unr.ce.out, align 4
  store ptr addrspace(5) %out_ptr.049.unr.ce, ptr %out_ptr.049.unr.ce.out, align 4
  store ptr %in_ptr2.0.in50.unr.ce, ptr %in_ptr2.0.in50.unr.ce.out, align 4
  store ptr addrspace(5) %in_ptr1.051.unr.ce, ptr %in_ptr1.051.unr.ce.out, align 4
  br label %for.cond.cleanup.unr-lcssa.exitStub

for.cond.cleanup.unr-lcssa.exitStub:              ; preds = %for.cond.cleanup.unr-lcssa.split
  ret void
}

attributes #0 = { nounwind memory(none) }
attributes #1 = { nounwind memory(inaccessiblemem: read) }
attributes #2 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #3 = { mustprogress noinline "no-jump-tables"="true" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }

!llvm.linker.options = !{}
!llvm.module.flags = !{!0, !1, !2}
!llvm.ident = !{!3}

!0 = !{i32 7, !"Dwarf Version", i32 4}
!1 = !{i32 2, !"Debug Info Version", i32 3}
!2 = !{i32 1, !"wchar_size", i32 4}
!3 = !{!"clang version 18.0.0git"}
!4 = !{!5, !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C++ TBAA"}
!21 = distinct !{!21, !22, !23, !24}
!22 = !{!"llvm.loop.mustprogress"}
!23 = !{!"llvm.loop.itercount.range", i32 2}
!24 = !{!"llvm.loop.unroll.disable"}
!25 = !{!26, !27, i64 40}
!26 = !{!"_ZTS21add2d_internal_params", !27, i64 0, !27, i64 4, !27, i64 8, !27, i64 12, !27, i64 16, !27, i64 20, !27, i64 24, !27, i64 28, !27, i64 32, !27, i64 36, !27, i64 40, !27, i64 44, !27, i64 48, !27, i64 52, !27, i64 56, !27, i64 60, !27, i64 64, !27, i64 68, !27, i64 72, !27, i64 76, !27, i64 80, !27, i64 84, !27, i64 88, !27, i64 92, !27, i64 96, !27, i64 100, !27, i64 104, !27, i64 108, !27, i64 112, !27, i64 116, !27, i64 120, !27, i64 124, !5, i64 128, !5, i64 129, !28, i64 130}
!27 = !{!"int", !5, i64 0}
!28 = !{!"__bf16", !5, i64 0}
!29 = !{!26, !27, i64 36}
!30 = !{!26, !27, i64 44}
!31 = !{!26, !27, i64 52}
!32 = !{!26, !27, i64 28}
!33 = !{!26, !27, i64 64}
!34 = !{!26, !27, i64 32}
!35 = !{!26, !27, i64 20}
