# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -mtriple=aie2 --verify-machineinstrs -run-pass=greedy -run-pass=virtregrewriter %s -o - | FileCheck %s

# There is only one L register available, it will then be used for the %0
# virtual register. Here we test that it is properly spilled and then reloaded.
---
name:            test_64_scarce_regs
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $x0, $r0, $r16, $p0, $l1, $l2, $l3, $l4, $l5, $l6, $l7

    ; CHECK-LABEL: name: test_64_scarce_regs
    ; CHECK: liveins: $l1, $l2, $l3, $l4, $l5, $l6, $l7, $p0, $r0, $r16, $x0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: renamable $l0 = VEXTRACT_S64 $x0, $r16
    ; CHECK-NEXT: VST_L_SPILL killed renamable $l0, %stack.0, implicit $sp :: (store (s64) into %stack.0, align 4)
    ; CHECK-NEXT: $l0 = COPY $l1
    ; CHECK-NEXT: ST_dms_sts_idx_imm $r0, $p0, 0, implicit $l0, implicit $l1, implicit $l2, implicit $l3, implicit $l4, implicit $l5, implicit $l6, implicit $l7
    ; CHECK-NEXT: renamable $l4 = VLDA_L_SPILL %stack.0, implicit $sp :: (load (s64) from %stack.0, align 4)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $l4
    %0:el = VEXTRACT_S64 $x0, $r16 ; -> only $l0 is available

    ; spill $l0 before it is re-defined and used
    $l0 = COPY $l1
    ST_dms_sts_idx_imm $r0, $p0, 0, implicit $l0, implicit $l1, implicit $l2, implicit $l3, implicit $l4, implicit $l5, implicit $l6, implicit $l7

    ; reload %0 / $l0 before PseudoRET
    PseudoRET implicit $lr, implicit %0
...

---
name:            test_64_caller_saved_through_csr
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $l4

    ; CHECK-LABEL: name: test_64_caller_saved_through_csr
    ; CHECK: liveins: $l4
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: renamable $l0 = COPY $l4
    ; CHECK-NEXT: PseudoJL 32, csr_aie2, implicit-def $lr
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $l0
    %0:el = COPY $l4
    PseudoJL 32, csr_aie2, implicit-def $lr
    PseudoRET implicit $lr, implicit %0
...

---
name:            test_64_caller_saved_spill
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $l0, $l1, $l2, $l3, $l4

    ; CHECK-LABEL: name: test_64_caller_saved_spill
    ; CHECK: liveins: $l0, $l1, $l2, $l3, $l4
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: VST_L_SPILL $l4, %stack.0, implicit $sp :: (store (s64) into %stack.0, align 4)
    ; CHECK-NEXT: PseudoJL 32, csr_aie2, implicit-def $lr
    ; CHECK-NEXT: renamable $l4 = VLDA_L_SPILL %stack.0, implicit $sp :: (load (s64) from %stack.0, align 4)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $l4, implicit $l0, implicit $l1, implicit $l2, implicit $l3
    %0:el = COPY $l4
    PseudoJL 32, csr_aie2, implicit-def $lr
    PseudoRET implicit $lr, implicit %0, implicit $l0, implicit $l1, implicit $l2, implicit $l3
...

# There is only one W register available, it will then be used for the %0
# virtual register. Here we test that it is properly spilled and then reloaded.
---
name:            test_256_scarce_regs
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $p0, $wl1, $wl2, $wl3, $wl4, $wl5, $wl6, $wl7, $wl8, $wl9, $wl10, $wl11, $wh0, $wh1, $wh2, $wh3, $wh4, $wh5, $wh6, $wh7, $wh8, $wh9, $wh10, $wh11

    ; CHECK-LABEL: name: test_256_scarce_regs
    ; CHECK: liveins: $p0, $wh0, $wh1, $wh2, $wh3, $wh4, $wh5, $wh6, $wh7, $wh8, $wh9, $wh10, $wh11, $wl1, $wl2, $wl3, $wl4, $wl5, $wl6, $wl7, $wl8, $wl9, $wl10, $wl11
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: renamable $wl0 = VLDA_dmw_lda_w_ag_idx_imm $p0, 0
    ; CHECK-NEXT: VST_dmw_sts_w_ag_spill killed renamable $wl0, %stack.0, implicit $sp :: (store (s256) into %stack.0)
    ; CHECK-NEXT: $wl0 = COPY $wl1
    ; CHECK-NEXT: VST_dmw_sts_w_ag_idx_imm $wl0, $p0, 0, implicit $wl1, implicit $wl2, implicit $wl3, implicit $wl4, implicit $wl5, implicit $wl6, implicit $wl7, implicit $wl8, implicit $wl9, implicit $wl10, implicit $wl11, implicit $wh0, implicit $wh1, implicit $wh2, implicit $wh3, implicit $wh4, implicit $wh5, implicit $wh6, implicit $wh7, implicit $wh8, implicit $wh9, implicit $wh10, implicit $wh11
    ; CHECK-NEXT: renamable $wh0 = VLDA_dmw_lda_w_ag_spill %stack.0, implicit $sp :: (load (s256) from %stack.0)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $wh0
    %0:vec256 = VLDA_dmw_lda_w_ag_idx_imm $p0, 0 ; -> only $wl0 is available

    ; spill $wl0 before it is re-defined and used
    $wl0 = COPY $wl1
    VST_dmw_sts_w_ag_idx_imm $wl0, $p0, 0, implicit $wl1, implicit $wl2, implicit $wl3, implicit $wl4, implicit $wl5, implicit $wl6, implicit $wl7, implicit $wl8, implicit $wl9, implicit $wl10, implicit $wl11, implicit $wh0, implicit $wh1, implicit $wh2, implicit $wh3, implicit $wh4, implicit $wh5, implicit $wh6, implicit $wh7, implicit $wh8, implicit $wh9, implicit $wh10, implicit $wh11

    ; reload %0 / $ wl0 before PseudoRET
    PseudoRET implicit $lr, implicit %0
...

---
name:            test_256_caller_saved
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $wl0

    ; CHECK-LABEL: name: test_256_caller_saved
    ; CHECK: liveins: $wl0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: VST_dmw_sts_w_ag_spill $wl0, %stack.0, implicit $sp :: (store (s256) into %stack.0)
    ; CHECK-NEXT: PseudoJL 32, csr_aie2, implicit-def $lr
    ; CHECK-NEXT: renamable $wh0 = VLDA_dmw_lda_w_ag_spill %stack.0, implicit $sp :: (load (s256) from %stack.0)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $wh0
    %0:vec256 = COPY $wl0
    PseudoJL 32, csr_aie2, implicit-def $lr
    PseudoRET implicit $lr, implicit %0
...

# There is only one X register available, it will then be used for the %0
# virtual register. Here we test that it is properly spilled and then reloaded.
---
name:            test_512_scarce_regs
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $bml0, $r0, $p0, $x1, $x2, $x3, $x4, $x5, $x6, $x7, $x8, $x9, $x10, $x11

    ; CHECK-LABEL: name: test_512_scarce_regs
    ; CHECK: liveins: $bml0, $p0, $r0, $x1, $x2, $x3, $x4, $x5, $x6, $x7, $x8, $x9, $x10, $x11
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: renamable $x0 = COPY $bml0
    ; CHECK-NEXT: VST_X_SPILL killed renamable $x0, %stack.0, implicit $sp :: (store (s512) into %stack.0, align 32)
    ; CHECK-NEXT: $x0 = COPY $x1
    ; CHECK-NEXT: ST_dms_sts_idx_imm $r0, $p0, 0, implicit $x0, implicit $x1, implicit $x2, implicit $x3, implicit $x4, implicit $x5, implicit $x6, implicit $x7, implicit $x8, implicit $x9, implicit $x10, implicit $x11
    ; CHECK-NEXT: renamable $x0 = VLDA_X_SPILL %stack.0, implicit $sp :: (load (s512) from %stack.0, align 32)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $x0
    %0:vec512 = COPY $bml0 ; -> only $x0 is available

    ; spill $x0 before it is re-defined and used
    $x0 = COPY $x1
    ST_dms_sts_idx_imm $r0, $p0, 0, implicit $x0, implicit $x1, implicit $x2, implicit $x3, implicit $x4, implicit $x5, implicit $x6, implicit $x7, implicit $x8, implicit $x9, implicit $x10, implicit $x11

    ; reload %0 / $x0 before PseudoRET
    PseudoRET implicit $lr, implicit %0
...

---
name:            test_512_caller_saved
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $x0

    ; CHECK-LABEL: name: test_512_caller_saved
    ; CHECK: liveins: $x0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: VST_X_SPILL $x0, %stack.0, implicit $sp :: (store (s512) into %stack.0, align 32)
    ; CHECK-NEXT: PseudoJL 32, csr_aie2, implicit-def $lr
    ; CHECK-NEXT: renamable $x0 = VLDA_X_SPILL %stack.0, implicit $sp :: (load (s512) from %stack.0, align 32)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $x0
    %0:vec512 = COPY $x0
    PseudoJL 32, csr_aie2, implicit-def $lr
    PseudoRET implicit $lr, implicit %0
...

# There is only one Y register available, it will then be used for the %0
# virtual register. Here we test that it is properly spilled and then reloaded.
---
name:            test_1024_scarce_regs
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $cm0, $r0, $p0, $y3, $y4, $y5

    ; CHECK-LABEL: name: test_1024_scarce_regs
    ; CHECK: liveins: $cm0, $p0, $r0, $y3, $y4, $y5
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: renamable $y2 = COPY $cm0
    ; CHECK-NEXT: VST_Y_SPILL killed renamable $y2, %stack.0, implicit $sp :: (store (s1024) into %stack.0, align 32)
    ; CHECK-NEXT: $y2 = COPY $y3
    ; CHECK-NEXT: ST_dms_sts_idx_imm $r0, $p0, 0, implicit $y2, implicit $y3, implicit $y4, implicit $y5
    ; CHECK-NEXT: renamable $y2 = VLDA_Y_SPILL %stack.0, implicit $sp :: (load (s1024) from %stack.0, align 32)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $y2
    %0:vec1024 = COPY $cm0 ; -> only $y2 is available

    ; spill $y2 before it is re-defined and used
    $y2 = COPY $y3
    ST_dms_sts_idx_imm $r0, $p0, 0, implicit $y2, implicit $y3, implicit $y4, implicit $y5

    ; reload %0 / $y2 before PseudoRET
    PseudoRET implicit $lr, implicit %0
...

---
name:            test_1024_caller_saved
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $y2

    ; CHECK-LABEL: name: test_1024_caller_saved
    ; CHECK: liveins: $y2
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: VST_Y_SPILL $y2, %stack.0, implicit $sp :: (store (s1024) into %stack.0, align 32)
    ; CHECK-NEXT: PseudoJL 32, csr_aie2, implicit-def $lr
    ; CHECK-NEXT: renamable $y2 = VLDA_Y_SPILL %stack.0, implicit $sp :: (load (s1024) from %stack.0, align 32)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $y2
    %0:vec1024 = COPY $y2
    PseudoJL 32, csr_aie2, implicit-def $lr
    PseudoRET implicit $lr, implicit %0
...

# There is only one q0 register available, it will then be used for the %0
# virtual register. Here we test that it is properly spilled and then reloaded.
---
name:            test_128_scarce_regs
alignment:       16
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $p0, $q1, $q2, $q3

    ; CHECK-LABEL: name: test_128_scarce_regs
    ; CHECK: liveins: $p0, $q1, $q2, $q3
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: renamable $q0 = LDA_dmv_lda_q_ag_idx_imm $p0, 0
    ; CHECK-NEXT: ST_dmv_sts_q_ag_spill killed renamable $q0, %stack.0, implicit $sp :: (store (s128) into %stack.0)
    ; CHECK-NEXT: $q0 = COPY $q1
    ; CHECK-NEXT: ST_dmv_sts_q_ag_idx_imm $q0, $p0, 0, implicit $q1, implicit $q2, implicit $q3
    ; CHECK-NEXT: renamable $q0 = LDA_dmv_lda_q_ag_spill %stack.0, implicit $sp :: (load (s128) from %stack.0)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit killed renamable $q0
    %0:mqqa = LDA_dmv_lda_q_ag_idx_imm $p0, 0 ; -> only $q0 is available

    ; spill $q0 before it is re-defined and used
    $q0 = COPY $q1
    ST_dmv_sts_q_ag_idx_imm $q0, $p0, 0, implicit $q1, implicit $q2, implicit $q3

    ; reload %0 / $ q0 before PseudoRET
    PseudoRET implicit $lr, implicit %0
...
