; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

; The clang front-end should already ensure return types larger than 16 bytes
; are returned indirectly.
; That means a [16 x i8] type still gets returned "directly", in registers+stack.
; TODO: Do we want to handle this?

%struct.S4I = type { i32, i32, i32, i32 }
%struct.S4S = type { i16, i16, i16, i16 }
%struct.SILI = type { i32, i64, i32 }
%struct.S4P = type { i32*, i32*, i32*, i32* }

declare %struct.S4I @ret_S4I()
define void @call_ret_S4I() {
  ; CHECK-LABEL: name: call_ret_S4I
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoJL @ret_S4I, csr_aie2, implicit-def $lr, implicit-def $r0, implicit-def $r1, implicit-def $r2, implicit-def $r3
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r3
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call %struct.S4I @ret_S4I()
  ret void
}

declare %struct.S4S @ret_S4S()
define void @call_ret_S4S() {
  ; CHECK-LABEL: name: call_ret_S4S
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoJL @ret_S4S, csr_aie2, implicit-def $lr, implicit-def $r0, implicit-def $r1, implicit-def $r2, implicit-def $r3
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s16) = G_TRUNC [[COPY]](s32)
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[TRUNC1:%[0-9]+]]:_(s16) = G_TRUNC [[COPY1]](s32)
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[TRUNC2:%[0-9]+]]:_(s16) = G_TRUNC [[COPY2]](s32)
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r3
  ; CHECK-NEXT:   [[TRUNC3:%[0-9]+]]:_(s16) = G_TRUNC [[COPY3]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call %struct.S4S @ret_S4S()
  ret void
}

declare %struct.SILI @ret_SILI()
define void @call_ret_SILI() {
  ; CHECK-LABEL: name: call_ret_SILI
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoJL @ret_SILI, csr_aie2, implicit-def $lr, implicit-def $r0, implicit-def $r1, implicit-def $r2, implicit-def $r3
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[MV:%[0-9]+]]:_(s64) = G_MERGE_VALUES [[COPY1]](s32), [[COPY2]](s32)
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r3
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call %struct.SILI @ret_SILI()
  ret void
}

declare %struct.S4P @ret_S4P()
define void @call_ret_S4P() {
  ; CHECK-LABEL: name: call_ret_S4P
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoJL @ret_S4P, csr_aie2, implicit-def $lr, implicit-def $p0, implicit-def $p1, implicit-def $p2, implicit-def $p3
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(p0) = COPY $p1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(p0) = COPY $p2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(p0) = COPY $p3
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  call %struct.S4P @ret_S4P()
  ret void
}
