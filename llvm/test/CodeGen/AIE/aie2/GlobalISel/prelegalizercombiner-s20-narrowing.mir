# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -mtriple aie2 -run-pass=aie2-prelegalizer-combiner --aie-s20-narrowing=true %s -verify-machineinstrs -o - | FileCheck %s


# Simple case where a 32-bit constant is truncated
---
name:            valid_trunc
legalized:       false
tracksRegLiveness: true
body:             |
  bb.1:
    ; CHECK-LABEL: name: valid_trunc
    ; CHECK: [[C:%[0-9]+]]:_(s20) = G_CONSTANT i20 1
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
    ; CHECK-NEXT: [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), [[C2]](p0), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[C]](s20)
    ; CHECK-NEXT: $p0 = COPY [[INT]](p0)
    %0:_(s32) = G_CONSTANT i32 1
    %1:_(s20) = G_TRUNC %0
    %2:_(s20) = G_CONSTANT i20 0
    %3:_(p0) = G_CONSTANT i20 0
    %13:_(p0), %14:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), %3:_(p0), %2:_(s20), %2:_(s20), %2:_(s20), %1:_(s20)
    $p0 = COPY %13
...

# Simple case where a 8-bit constant is extended. Currently, we keep the ZEXT.
---
name:            valid_ext
legalized:       false
tracksRegLiveness: true
body:             |
  bb.1:
    ; CHECK-LABEL: name: valid_ext
    ; CHECK: [[C:%[0-9]+]]:_(s20) = G_CONSTANT i20 1
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
    ; CHECK-NEXT: [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), [[C2]](p0), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[C]](s20)
    ; CHECK-NEXT: $p0 = COPY [[INT]](p0)
    %0:_(s8) = G_CONSTANT i8 1
    %1:_(s20) = G_ZEXT %0
    %2:_(s20) = G_CONSTANT i20 0
    %3:_(p0) = G_CONSTANT i20 0
    %13:_(p0), %14:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), %3:_(p0), %2:_(s20), %2:_(s20), %2:_(s20), %1:_(s20)
    $p0 = COPY %13
...

# Only one Src Node (G_LOAD) for G_PTR_ADD that is narrowed to S20 type, intermediate G_TRUNC is removed
---
name:            G_LOAD
legalized:       false
body:             |
  ; CHECK-LABEL: name: G_LOAD
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s20) = G_LOAD [[C]](p0) :: (load (s20), align 4)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[LOAD]](s20)
  ; CHECK-NEXT:   G_STORE [[C1]](s32), [[PTR_ADD]](p0) :: (store (s32))
  ; CHECK-NEXT:   G_BR %bb.1
  bb.1:
    successors: %bb.2(0x80000000); %bb.2(100.00%)
    liveins: $p0
    %0:_(p0) = COPY $p0
    %2:_(p0) = G_CONSTANT i20 0
    %7:_(s32) = G_CONSTANT i32 0
    %1:_(s32) = G_LOAD %2:_(p0) :: (load (s32))

  bb.2:
    successors: %bb.2(0x80000000); %bb.2(100.00%)

    %3:_(s20) = G_TRUNC %1:_(s32)
    %4:_(p0) = G_PTR_ADD %0:_, %3:_(s20)
    G_STORE %7:_(s32), %4:_(p0) :: (store (s32))
    G_BR %bb.2
...


# Only one Src Node (G_LOAD) for G_PTR_ADD. Multiple use of G_LOAD one of which is G_ADD which is legal for s32 type only. Optimization is rejected for this case
---
name:            G_LOAD_Multiple_Use_Neg_ADD
legalized:       false
body:             |
  ; CHECK-LABEL: name: G_LOAD_Multiple_Use_Neg_ADD
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 100
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[C]](p0) :: (load (s32))
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s32) = G_ADD [[LOAD]], [[C1]]
  ; CHECK-NEXT:   G_STORE [[ADD]](s32), %5(p0) :: (store (s32))
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s20) = G_TRUNC [[LOAD]](s32)
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[TRUNC]](s20)
  ; CHECK-NEXT:   G_STORE [[C1]](s32), [[PTR_ADD]](p0) :: (store (s32))
  ; CHECK-NEXT:   G_BR %bb.1
  bb.1:
    successors: %bb.2(0x80000000); %bb.2(100.00%)
    liveins: $p0
    %0:_(p0) = COPY $p0
    %2:_(p0) = G_CONSTANT i20 0
    %7:_(s32) = G_CONSTANT i32 100
    %1:_(s32) = G_LOAD %2:_(p0) :: (load (s32))
    %8:_(s32) = G_ADD %1:_(s32), %7:_(s32)
    G_STORE %8:_(s32), %4:_(p0) :: (store (s32))

  bb.2:
    successors: %bb.2(0x80000000); %bb.2(100.00%)

    %3:_(s20) = G_TRUNC %1:_(s32)
    %4:_(p0) = G_PTR_ADD %0:_, %3:_(s20)
    G_STORE %7:_(s32), %4:_(p0) :: (store (s32))
    G_BR %bb.2
...

# Only one Src Node (G_LOAD) for G_PTR_ADD. Multiple use of G_LOAD in G_STORE & G_PTR_ADD
---
name:            G_LOAD_Multiple_Use_PTR_ADD_and_G_STORE
legalized:       false
body:             |
  ; CHECK-LABEL: name: G_LOAD_Multiple_Use_PTR_ADD_and_G_STORE
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 100
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s20) = G_LOAD [[C]](p0) :: (load (s20), align 4)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[LOAD]](s20)
  ; CHECK-NEXT:   G_STORE [[C1]](s32), [[PTR_ADD]](p0) :: (store (s32))
  ; CHECK-NEXT:   G_STORE [[LOAD]](s20), [[PTR_ADD]](p0) :: (store (s20), align 4)
  ; CHECK-NEXT:   G_BR %bb.1
  bb.1:
    successors: %bb.2(0x80000000); %bb.2(100.00%)
    liveins: $p0
    %0:_(p0) = COPY $p0
    %2:_(p0) = G_CONSTANT i20 0
    %7:_(s32) = G_CONSTANT i32 100
    %1:_(s32) = G_LOAD %2:_(p0) :: (load (s32))

  bb.2:
    successors: %bb.2(0x80000000); %bb.2(100.00%)

    %3:_(s20) = G_TRUNC %1:_(s32)
    %4:_(p0) = G_PTR_ADD %0:_, %3:_(s20)
    G_STORE %7:_(s32), %4:_(p0) :: (store (s32))
    G_STORE %1:_(s32), %4:_(p0) :: (store (s32))
    G_BR %bb.2
...


# Multiple Src Node (G_CONSTANT / ADD_3D (%3 count0 output)), G_CONSTANT have multiple uses
---
name:              G_CONSTANT
legalized:         false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: G_CONSTANT
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   G_STORE [[C2]](s32), [[C]](p0) :: (store (s32))
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:_(s20) = G_PHI [[C1]](s20), %bb.0, %7(s20), %bb.1
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20), [[INT2:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), [[C]](p0), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[PHI]](s20), [[C1]](s20), [[C1]](s20)
  ; CHECK-NEXT:   G_BR %bb.1
  bb.1.entry:
    successors: %bb.2(0x80000000); %bb.2(100.00%)

    %5:_(p0) = G_CONSTANT i20 0
    %6:_(s20) = G_CONSTANT i20 0
    %8:_(s32) = G_CONSTANT i32 0
    G_STORE %8:_(s32), %5:_(p0) :: (store (s32))

  bb.2:
    successors: %bb.2(0x80000000); %bb.2(100.00%)

    %0:_(s32) = G_PHI %8:_(s32), %bb.1, %7:_(s32), %bb.2
    %1:_(s20) = G_TRUNC %0:_(s32)
    %2:_(p0), %3:_(s20), %4:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), %5:_(p0), %6:_(s20), %6:_(s20), %6:_(s20), %6:_(s20), %1:_(s20), %6:_(s20), %6:_(s20)
    %7:_(s32) = G_ZEXT %3:_(s20)
    G_BR %bb.2
...


# Multiple Src Node (G_CONSTANT / G_IMPLICIT_DEF / ADD_3D (%10 count0 output)), G_PHI having 3 input nodes
---
name:              G_IMPLICIT_DEF_G_PHI_with_3_input_nodes
legalized:         false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: G_IMPLICIT_DEF_G_PHI_with_3_input_nodes
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s1) = G_TRUNC [[COPY]](s32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s20) = G_IMPLICIT_DEF
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:_(s20) = G_PHI [[C1]](s20), %bb.0, [[DEF]](s20), %bb.1, %10(s20), %bb.2
  ; CHECK-NEXT:   G_BRCOND [[TRUNC]](s1), %bb.1
  ; CHECK-NEXT:   G_BR %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20), [[INT2:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), [[C]](p0), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[PHI]](s20), [[C1]](s20), [[C1]](s20)
  ; CHECK-NEXT:   G_BR %bb.1
  bb.1.entry:
    successors: %bb.2(0x80000000); %bb.2(100.00%)
    liveins: $r0
    %1:_(s32) = COPY $r0
    %0:_(s1) = G_TRUNC %1:_(s32)
    %7:_(p0) = G_CONSTANT i20 0
    %8:_(s20) = G_CONSTANT i20 0
    %10:_(s32) = G_CONSTANT i32 0
    %11:_(s32) = G_IMPLICIT_DEF

  bb.2:
    successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

    %2:_(s32) = G_PHI %10:_(s32), %bb.1, %11:_(s32), %bb.2, %9:_(s32), %bb.3
    G_BRCOND %0:_(s1), %bb.2
    G_BR %bb.3

  bb.3:
    successors: %bb.2(0x80000000); %bb.2(100.00%)

    %3:_(s20) = G_TRUNC %2:_(s32)
    %4:_(p0), %5:_(s20), %6:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), %7:_(p0), %8:_(s20), %8:_(s20), %8:_(s20), %8:_(s20), %3:_(s20), %8:_(s20), %8:_(s20)
    %9:_(s32) = G_ZEXT %5:_(s20)
    G_BR %bb.2
...


# Multiple Src Node (G_CONSTANT / G_IMPLICIT_DEF / ADD_3D (%11 count0 output) / ADD_3D (%16 count0 output))
---
name:              Const_ImplicitDef_Addr3d
legalized:         false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: Const_ImplicitDef_Addr3d
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s1) = G_TRUNC [[COPY]](s32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s20) = G_IMPLICIT_DEF
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.3(0x30000000), %bb.2(0x50000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:_(s20) = G_PHI [[C]](s20), %bb.0, %7(s20), %bb.3, %16(s20), %bb.4
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s1) = G_CONSTANT i1 true
  ; CHECK-NEXT:   G_BRCOND [[C2]](s1), %bb.3
  ; CHECK-NEXT:   G_BR %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20), [[INT2:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), [[C1]](p0), [[C]](s20), [[C]](s20), [[C]](s20), [[C]](s20), [[C]](s20), [[C]](s20), [[C]](s20)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3:
  ; CHECK-NEXT:   successors: %bb.1(0x40000000), %bb.4(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:_(s20) = G_PHI [[DEF]](s20), %bb.1, [[INT1]](s20), %bb.2
  ; CHECK-NEXT:   G_BRCOND [[TRUNC]](s1), %bb.1
  ; CHECK-NEXT:   G_BR %bb.4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[INT3:%[0-9]+]]:_(p0), [[INT4:%[0-9]+]]:_(s20), [[INT5:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), [[C1]](p0), [[C]](s20), [[C]](s20), [[C]](s20), [[C]](s20), [[PHI]](s20), [[C]](s20), [[C]](s20)
  ; CHECK-NEXT:   G_BR %bb.1
  bb.1.entry:
    successors: %bb.2(0x80000000); %bb.2(100.00%)
    liveins: $r0
    %1:_(s32) = COPY $r0
    %0:_(s1) = G_TRUNC %1:_(s32)
    %3:_(s32) = G_CONSTANT i32 0
    %8:_(p0) = G_CONSTANT i20 0
    %9:_(s20) = G_CONSTANT i20 0
    %17:_(s32) = G_IMPLICIT_DEF

  bb.2:
    successors: %bb.4(0x30000000), %bb.3(0x50000000); %bb.4(37.50%), %bb.3(62.50%)

    %2:_(s32) = G_PHI %3:_(s32), %bb.1, %11:_(s32), %bb.4, %16:_(s32), %bb.5
    %4:_(s1) = G_ICMP intpred(eq), %3:_(s32), %3:_
    G_BRCOND %4:_(s1), %bb.4
    G_BR %bb.3

  bb.3:
    successors: %bb.4(0x80000000); %bb.4(100.00%)

    %5:_(p0), %6:_(s20), %7:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), %8:_(p0), %9:_(s20), %9:_(s20), %9:_(s20), %9:_(s20), %9:_(s20), %9:_(s20), %9:_(s20)
    %10:_(s32) = G_ZEXT %6:_(s20)

  bb.4:
    successors: %bb.2(0x40000000), %bb.5(0x40000000); %bb.2(50.00%), %bb.5(50.00%)

    %11:_(s32) = G_PHI %17:_(s32), %bb.2, %10:_(s32), %bb.3
    G_BRCOND %0:_(s1), %bb.2
    G_BR %bb.5

  bb.5:
    successors: %bb.2(0x80000000); %bb.2(100.00%)

    %12:_(s20) = G_TRUNC %2:_(s32)
    %13:_(p0), %14:_(s20), %15:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), %8:_(p0), %9:_(s20), %9:_(s20), %9:_(s20), %9:_(s20), %12:_(s20), %9:_(s20), %9:_(s20)
    %16:_(s32) = G_ZEXT %14:_(s20)
    G_BR %bb.2
...


# Multiple Src Node (G_LOAD / ADD_2D (%19 count0 output))
---
name:              Add2d_Loop_constMod
legalized:         false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: Add2d_Loop_constMod
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
  ; CHECK-NEXT:   liveins: $p1, $p2, $r0, $r1, $r2, $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p1
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(p0) = COPY $p2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(s32) = COPY $r3
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 10
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 -1
  ; CHECK-NEXT:   [[ICMP:%[0-9]+]]:_(s1) = G_ICMP intpred(sle), [[COPY4]](s32), [[C]]
  ; CHECK-NEXT:   G_BRCOND [[ICMP]](s1), %bb.3
  ; CHECK-NEXT:   G_BR %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.4(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s20) = G_LOAD [[COPY2]](p0) :: (dereferenceable load (s20), align 4)
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s20) = G_TRUNC [[COPY3]](s32)
  ; CHECK-NEXT:   [[TRUNC1:%[0-9]+]]:_(s20) = G_TRUNC [[COPY1]](s32)
  ; CHECK-NEXT:   G_BR %bb.4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3:
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:_(p0) = G_PHI [[COPY]](p0), %bb.0, %14(p0), %bb.2
  ; CHECK-NEXT:   $p0 = COPY [[PHI]](p0)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4:
  ; CHECK-NEXT:   successors: %bb.2(0x04000000), %bb.4(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:_(s32) = G_PHI [[COPY4]](s32), %bb.1, %16(s32), %bb.4
  ; CHECK-NEXT:   [[PHI2:%[0-9]+]]:_(p0) = G_PHI [[COPY]](p0), %bb.1, %14(p0), %bb.4
  ; CHECK-NEXT:   [[PHI3:%[0-9]+]]:_(s20) = G_PHI [[LOAD]](s20), %bb.1, %21(s20), %bb.4
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), [[PHI2]](p0), [[C1]](s20), [[TRUNC]](s20), [[TRUNC1]](s20), [[PHI3]](s20)
  ; CHECK-NEXT:   G_STORE [[INT1]](s20), [[COPY2]](p0) :: (store (s20), align 4)
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s32) = G_ADD [[PHI1]], [[C2]]
  ; CHECK-NEXT:   [[ICMP1:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[ADD]](s32), [[C]]
  ; CHECK-NEXT:   G_BRCOND [[ICMP1]](s1), %bb.2
  ; CHECK-NEXT:   G_BR %bb.4
  bb.1.entry:
    successors: %bb.2(0x50000000), %bb.4(0x30000000); %bb.2(62.50%), %bb.4(37.50%)
    liveins: $p1, $p2, $r0, $r1, $r2, $r3
    %1:_(p0) = COPY $p1
    %2:_(s32) = COPY $r0
    %3:_(s32) = COPY $r1
    %4:_(p0) = COPY $p2
    %5:_(s32) = COPY $r2
    %6:_(s32) = COPY $r3
    %7:_(s32) = G_CONSTANT i32 0
    %18:_(s20) = G_CONSTANT i20 10
    %20:_(s32) = G_CONSTANT i32 -1
    %8:_(s1) = G_ICMP intpred(sgt), %6:_(s32), %7:_
    G_BRCOND %8:_(s1), %bb.2
    G_BR %bb.4

  bb.2:
    successors: %bb.5(0x80000000); %bb.5(100.00%)

    %9:_(s32) = G_LOAD %4:_(p0) :: (dereferenceable load (s32))
    %10:_(s20) = G_TRUNC %5:_(s32)
    %11:_(s20) = G_TRUNC %3:_(s32)
    G_BR %bb.5

  bb.3:
    successors: %bb.4(0x80000000); %bb.4(100.00%)


  bb.4:

    %0:_(p0) = G_PHI %1:_(p0), %bb.1, %16:_(p0), %bb.3
    $p0 = COPY %0:_(p0)
    PseudoRET implicit $lr, implicit $p0

  bb.5:
    successors: %bb.3(0x04000000), %bb.5(0x7c000000); %bb.3(3.12%), %bb.5(96.88%)

    %12:_(s32) = G_PHI %6:_(s32), %bb.2, %21:_(s32), %bb.5
    %13:_(p0) = G_PHI %1:_(p0), %bb.2, %16:_(p0), %bb.5
    %14:_(s32) = G_PHI %9:_(s32), %bb.2, %19:_(s32), %bb.5
    %15:_(s20) = G_TRUNC %14:_(s32)
    %16:_(p0), %17:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), %13:_(p0), %18:_(s20), %10:_(s20), %11:_(s20), %15:_(s20)
    %19:_(s32) = G_ZEXT %17:_(s20)
    G_STORE %19:_(s32), %4:_(p0) :: (store (s32))
    %21:_(s32) = G_ADD %12:_, %20:_
    %22:_(s1) = G_ICMP intpred(eq), %21:_(s32), %7:_
    G_BRCOND %22:_(s1), %bb.3
    G_BR %bb.5
...

# Multiple Src Node (G_CONSTANT 2 valid use / ADD_3D (%9 count0 output)) & loop of G_PHI nodes
---
name:              G_PHI_Loop
legalized:         false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: G_PHI_Loop
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s1) = G_TRUNC [[COPY]](s32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.3(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:_(s20) = G_PHI [[C1]](s20), %bb.0, %6(s20), %bb.3
  ; CHECK-NEXT:   G_BRCOND [[TRUNC]](s1), %bb.3
  ; CHECK-NEXT:   G_BR %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20), [[INT2:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), [[C]](p0), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[PHI]](s20)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:_(s20) = G_PHI [[C1]](s20), %bb.1, [[INT1]](s20), %bb.2
  ; CHECK-NEXT:   G_BR %bb.1
  bb.1.entry:
    successors: %bb.2(0x80000000); %bb.2(100.00%)
    liveins: $r0
    %1:_(s32) = COPY $r0
    %0:_(s1) = G_TRUNC %1:_(s32)
    %7:_(p0) = G_CONSTANT i20 0
    %8:_(s20) = G_CONSTANT i20 0
    %12:_(s32) = G_CONSTANT i32 0

  bb.2:
    successors: %bb.4(0x40000000), %bb.3(0x40000000); %bb.4(50.00%), %bb.3(50.00%)

    %2:_(s32) = G_PHI %12:_(s32), %bb.1, %10:_(s32), %bb.4
    G_BRCOND %0:_(s1), %bb.4
    G_BR %bb.3

  bb.3:
    successors: %bb.4(0x80000000); %bb.4(100.00%)

    %3:_(s20) = G_TRUNC %2:_(s32)
    %4:_(p0), %5:_(s20), %6:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), %7:_(p0), %8:_(s20), %8:_(s20), %8:_(s20), %8:_(s20), %8:_(s20), %8:_(s20), %3:_(s20)
    %9:_(s32) = G_ZEXT %5:_(s20)

  bb.4:
    successors: %bb.2(0x80000000); %bb.2(100.00%)

    %10:_(s32) = G_PHI %12:_(s32), %bb.2, %9:_(s32), %bb.3
    %11:_(s32) = G_LOAD %7:_(p0) :: (load (s32))
    G_BR %bb.2
...

# Only one Src Node (G_LOAD) for G_PTR_ADD. Multiple use of G_LOAD one of which is G_SELECT which is legal for s32 type only. Optimization is rejected for this case
---
name:            G_LOAD_Multiple_Use_Neg_SELECT
legalized:       false
body:             |
  ; CHECK-LABEL: name: G_LOAD_Multiple_Use_Neg_SELECT
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $p0, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s1) = G_TRUNC [[COPY1]](s32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 100
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[C]](p0) :: (load (s32))
  ; CHECK-NEXT:   [[SELECT:%[0-9]+]]:_(s32) = G_SELECT [[TRUNC]](s1), [[LOAD]], [[C1]]
  ; CHECK-NEXT:   G_STORE [[SELECT]](s32), %7(p0) :: (store (s32))
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[TRUNC1:%[0-9]+]]:_(s20) = G_TRUNC [[LOAD]](s32)
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[TRUNC1]](s20)
  ; CHECK-NEXT:   G_STORE [[C1]](s32), [[PTR_ADD]](p0) :: (store (s32))
  ; CHECK-NEXT:   G_BR %bb.1
  bb.1:
    successors: %bb.2(0x80000000); %bb.2(100.00%)
    liveins: $p0, $r0
    %0:_(p0) = COPY $p0
    %9:_(s32) = COPY $r0
    %10:_(s1) = G_TRUNC %9:_(s32)
    %2:_(p0) = G_CONSTANT i20 0
    %7:_(s32) = G_CONSTANT i32 100
    %1:_(s32) = G_LOAD %2:_(p0) :: (load (s32))
    %8:_(s32) = G_SELECT %10:_(s1), %1:_(s32), %7:_(s32)
    G_STORE %8:_(s32), %4:_(p0) :: (store (s32))

  bb.2:
    successors: %bb.2(0x80000000); %bb.2(100.00%)

    %3:_(s20) = G_TRUNC %1:_(s32)
    %4:_(p0) = G_PTR_ADD %0:_, %3:_(s20)
    G_STORE %7:_(s32), %4:_(p0) :: (store (s32))
    G_BR %bb.2
...

# Currently we do not turn %3:_(s32) = G_ZEXT %11:_(s8) into
# %3:_(s20) = G_ZEXT %11:_(s8) and reject narrowing.
---
name:            phi_from_s8_add
legalized:       false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: phi_from_s8_add
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s8) = G_TRUNC [[COPY]](s32)
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s8) = G_ADD [[TRUNC]], [[TRUNC]]
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[ADD]](s8)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:_(s32) = G_PHI [[ZEXT]](s32), %bb.0, %7(s32), %bb.1
  ; CHECK-NEXT:   [[TRUNC1:%[0-9]+]]:_(s20) = G_TRUNC [[PHI]](s32)
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), [[C]](p0), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[TRUNC1]](s20)
  ; CHECK-NEXT:   [[ZEXT1:%[0-9]+]]:_(s32) = G_ZEXT [[INT1]](s20)
  ; CHECK-NEXT:   G_BR %bb.1
  bb.0.entry:
    successors: %bb.1(0x80000000); %bb.1(100.00%)
    liveins: $r0
    %0:_(s32) = COPY $r0
    %10:_(s8) = G_TRUNC %0
    %11:_(s8) = G_ADD %10, %10
    %1:_(p0) = G_CONSTANT i20 0
    %2:_(s20) = G_CONSTANT i20 0
    %3:_(s32) = G_ZEXT %11:_(s8)

  bb.1:
    successors: %bb.1(0x80000000); %bb.1(100.00%)
    %4:_(s32) = G_PHI %3:_(s32), %bb.0, %5:_(s32), %bb.1
    %6:_(s20) = G_TRUNC %4:_(s32)
    %7:_(p0), %8:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), %1:_(p0), %2:_(s20), %2:_(s20), %2:_(s20), %6:_(s20)
    %5:_(s32) = G_ZEXT %8:_(s20)
    G_BR %bb.1
...

---
name:            phi_from_mod_reg
legalized:       false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: phi_from_mod_reg
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $dc0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s20) = COPY $dc0
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:_(s20) = G_PHI [[COPY]](s20), %bb.0, %8(s20), %bb.1
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), [[C]](p0), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[PHI]](s20)
  ; CHECK-NEXT:   G_BR %bb.1
  bb.0.entry:
    successors: %bb.1(0x80000000); %bb.1(100.00%)
    liveins: $dc0
    %0:_(s20) = COPY $dc0
    %1:_(p0) = G_CONSTANT i20 0
    %2:_(s20) = G_CONSTANT i20 0
    %3:_(s32) = G_ZEXT %0:_(s20)

  bb.1:
    successors: %bb.1(0x80000000); %bb.1(100.00%)
    %4:_(s32) = G_PHI %3:_(s32), %bb.0, %5:_(s32), %bb.1
    %6:_(s20) = G_TRUNC %4:_(s32)
    %7:_(p0), %8:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), %1:_(p0), %2:_(s20), %2:_(s20), %2:_(s20), %6:_(s20)
    %5:_(s32) = G_ZEXT %8:_(s20)
    G_BR %bb.1
...

# Note that we currently do not narrow here because of the S32 phys reg copy.
# We cannot easily "adapt" this instruction like we do for G_LOAD or G_CONSTANT.
# We would have to insert a G_TRUNC %0 to be able to narrow the rest of the user
# tree until add.2d.
---
name:            phi_from_gpr
legalized:       false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: phi_from_gpr
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:_(s32) = G_PHI [[COPY]](s32), %bb.0, %4(s32), %bb.1
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s20) = G_TRUNC [[PHI]](s32)
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), [[C]](p0), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[TRUNC]](s20)
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[INT1]](s20)
  ; CHECK-NEXT:   G_BR %bb.1
  bb.0.entry:
    successors: %bb.1(0x80000000); %bb.1(100.00%)
    liveins: $r0
    %0:_(s32) = COPY $r0
    %1:_(p0) = G_CONSTANT i20 0
    %2:_(s20) = G_CONSTANT i20 0

  bb.1:
    successors: %bb.1(0x80000000); %bb.1(100.00%)
    %4:_(s32) = G_PHI %0:_(s32), %bb.0, %5:_(s32), %bb.1
    %6:_(s20) = G_TRUNC %4:_(s32)
    %7:_(p0), %8:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), %1:_(p0), %2:_(s20), %2:_(s20), %2:_(s20), %6:_(s20)
    %5:_(s32) = G_ZEXT %8:_(s20)
    G_BR %bb.1
...

# A somewhat weird (but valid) test obtained from llvm-reduce.
# It has this difficulties:
# - The %12 source value is used for two different operands of the ptr.add
# - A phys reg copy is used as a source: %0:_(s20) = COPY $p0
---
name:            connected_phis
legalized:       false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: connected_phis
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s20) = COPY $p0
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:_(s20) = G_PHI %11(s20), %bb.1, [[C1]](s20), %bb.0
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:_(s20) = G_PHI [[C1]](s20), %bb.1, [[COPY]](s20), %bb.0
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20), [[INT2:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), [[C]](p0), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[C1]](s20), [[PHI]](s20), [[C1]](s20), [[PHI1]](s20)
  ; CHECK-NEXT:   G_BR %bb.1
  bb.1:
    successors: %bb.2(0x80000000)
    liveins: $p0
    %0:_(s20) = COPY $p0
    %9:_(p0) = G_CONSTANT i20 0
    %10:_(s20) = G_CONSTANT i20 0
    %12:_(s32) = G_CONSTANT i32 0
    %1:_(s32) = G_ZEXT %0(s20)

  bb.2:
    successors: %bb.2(0x80000000)
    %2:_(s32) = G_PHI %11(s32), %bb.2, %12(s32), %bb.1
    %3:_(s32) = G_PHI %12(s32), %bb.2, %1(s32), %bb.1
    %4:_(s20) = G_TRUNC %2(s32)
    %5:_(s20) = G_TRUNC %3(s32)
    %6:_(p0), %7:_(s20), %8:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.3d), %9(p0), %10(s20), %10(s20), %10(s20), %10(s20), %4(s20), %10(s20), %5(s20)
    %11:_(s32) = G_ZEXT %7(s20)
    G_BR %bb.2
...

# Here the two PHI nodes share %15 as an input, but only one can be narrowed
# to S20 because it is consumed by aie2.add.2d. Doing the narrowing would
# require rewriting all sources, including %15. This isn't allowed because the
# second PHI node needs S32 precision.
---
name:            connected_phis_cannot_narrow
legalized:       false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: connected_phis_cannot_narrow
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 2
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s20) = G_CONSTANT i20 0
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:_(s32) = G_PHI %5(s32), %bb.1, [[C]](s32), %bb.0
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:_(s32) = G_PHI %5(s32), %bb.1, [[C1]](s32), %bb.0
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s20) = G_TRUNC [[PHI]](s32)
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(p0), [[INT1:%[0-9]+]]:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), [[C3]](p0), [[C2]](s20), [[C2]](s20), [[C2]](s20), [[TRUNC]](s20)
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[INT1]](s20)
  ; CHECK-NEXT:   $r0 = COPY [[PHI1]](s32)
  ; CHECK-NEXT:   G_BR %bb.1
  bb.1:
    successors: %bb.2(0x80000000)
    liveins: $p0
    %0:_(s32) = G_CONSTANT i32 1
    %1:_(s32) = G_CONSTANT i32 2
    %2:_(s20) = G_CONSTANT i20 0
    %3:_(p0) = G_CONSTANT i20 0

  bb.2:
    successors: %bb.2(0x80000000)
    %10:_(s32) = G_PHI %15(s32), %bb.2, %0(s32), %bb.1
    %11:_(s32) = G_PHI %15(s32), %bb.2, %1(s32), %bb.1
    %12:_(s20) = G_TRUNC %10(s32)
    %13:_(p0), %14:_(s20) = G_INTRINSIC intrinsic(@llvm.aie2.add.2d), %3:_(p0), %2:_(s20), %2:_(s20), %2:_(s20), %12:_(s20)
    %15:_(s32) = G_ZEXT %14(s20)
    $r0 = COPY %11
    G_BR %bb.2
...
