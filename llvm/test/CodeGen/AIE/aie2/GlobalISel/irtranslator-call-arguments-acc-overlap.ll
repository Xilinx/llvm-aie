; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

; The cm0 reg is used by the result type, and it overlaps with amll0.
; Therefore, %a0 cannot be passed in amll0
declare <16 x i64> @retcc_reserved_am(<4 x i64> %a0)
define void @call_retcc_reserved_am() {
  ; CHECK-LABEL: name: call_retcc_reserved_am
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<4 x s64>) = G_BUILD_VECTOR [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0
  ; CHECK-NEXT:   $amll1 = COPY [[BUILD_VECTOR]](<4 x s64>)
  ; CHECK-NEXT:   JL @retcc_reserved_am, csr_aie2, implicit-def $lr, implicit $amll1, implicit-def $cm0
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<16 x s64>) = COPY $cm0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call <16 x i64> @retcc_reserved_am(<4 x i64> zeroinitializer)
  ret void
}

; The cm0 reg is used by the result type, and it overlaps with bml0.
; Therefore, %a0 cannot be passed in bml0
declare <16 x i64> @retcc_reserved_bm(<8 x i64> %a0)
define void @call_retcc_reserved_bm() {
  ; CHECK-LABEL: name: call_retcc_reserved_bm
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<8 x s64>) = G_BUILD_VECTOR [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0
  ; CHECK-NEXT:   $bml1 = COPY [[BUILD_VECTOR]](<8 x s64>)
  ; CHECK-NEXT:   JL @retcc_reserved_bm, csr_aie2, implicit-def $lr, implicit $bml1, implicit-def $cm0
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<16 x s64>) = COPY $cm0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call <16 x i64> @retcc_reserved_bm(<8 x i64> zeroinitializer)
  ret void
}

; The cm0 reg is used by the result type.
; Therefore, %a0 cannot be passed in cm0
declare <16 x i64> @retcc_reserved_cm(<16 x i64> %a1)
define void @call_retcc_reserved_cm() {
  ; CHECK-LABEL: name: call_retcc_reserved_cm
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<16 x s64>) = G_BUILD_VECTOR [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64), [[C]](s64)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0
  ; CHECK-NEXT:   $cm1 = COPY [[BUILD_VECTOR]](<16 x s64>)
  ; CHECK-NEXT:   JL @retcc_reserved_cm, csr_aie2, implicit-def $lr, implicit $cm1, implicit-def $cm0
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<16 x s64>) = COPY $cm0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call <16 x i64> @retcc_reserved_cm(<16 x i64> zeroinitializer)
  ret void
}
