; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

declare void @callee()

define void @test_call() {
  ; CHECK-LABEL: name: test_call
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoJL @callee, csr_aie2, implicit-def $lr
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee()
  ret void
}

define void @test_indirect_call(void()* %func) {
  ; CHECK-LABEL: name: test_indirect_call
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:ep(p0) = COPY $p0
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoJL_IND [[COPY]](p0), csr_aie2, implicit-def $lr
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void %func()
  ret void
}

declare void @callee_i32(i32 %a)
define void @test_call_i32() {
  ; CHECK-LABEL: name: test_call_i32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @callee_i32, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_i32(i32 0)
  ret void
}

declare void @callee_i64(i64 %a)
define void @test_call_i64() {
  ; CHECK-LABEL: name: test_call_i64
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C]](s64)
  ; CHECK-NEXT:   $r0 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   PseudoJL @callee_i64, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_i64(i64 0)
  ret void
}

declare void @take_i1(i1)
define void @test_abi_exts_call_i1(i1* %addr) {
  ; CHECK-LABEL: name: test_abi_exts_call_i1
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s1) = G_LOAD [[COPY]](p0) :: (load (s1) from %ir.addr)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[LOAD]](s1)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoJL @take_i1, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[SEXT:%[0-9]+]]:_(s32) = G_SEXT [[LOAD]](s1)
  ; CHECK-NEXT:   $r0 = COPY [[SEXT]](s32)
  ; CHECK-NEXT:   PseudoJL @take_i1, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[LOAD]](s1)
  ; CHECK-NEXT:   $r0 = COPY [[ZEXT]](s32)
  ; CHECK-NEXT:   PseudoJL @take_i1, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  %val = load i1, i1* %addr
  call void @take_i1(i1 %val)
  call void @take_i1(i1 signext %val)
  call void @take_i1(i1 zeroext %val)
  ret void
}

declare void @take_i8(i8)
define void @test_abi_exts_call_i8(i8* %addr) {
  ; CHECK-LABEL: name: test_abi_exts_call_i8
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s8) = G_LOAD [[COPY]](p0) :: (load (s8) from %ir.addr)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[LOAD]](s8)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoJL @take_i8, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[SEXT:%[0-9]+]]:_(s32) = G_SEXT [[LOAD]](s8)
  ; CHECK-NEXT:   $r0 = COPY [[SEXT]](s32)
  ; CHECK-NEXT:   PseudoJL @take_i8, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[LOAD]](s8)
  ; CHECK-NEXT:   $r0 = COPY [[ZEXT]](s32)
  ; CHECK-NEXT:   PseudoJL @take_i8, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  %val = load i8, i8* %addr
  call void @take_i8(i8 %val)
  call void @take_i8(i8 signext %val)
  call void @take_i8(i8 zeroext %val)
  ret void
}

declare void @take_i16(i16)
define void @test_abi_exts_call_i16(i16* %addr) {
  ; CHECK-LABEL: name: test_abi_exts_call_i16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $p0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s16) = G_LOAD [[COPY]](p0) :: (load (s16) from %ir.addr)
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[LOAD]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoJL @take_i16, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[SEXT:%[0-9]+]]:_(s32) = G_SEXT [[LOAD]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[SEXT]](s32)
  ; CHECK-NEXT:   PseudoJL @take_i16, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[LOAD]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ZEXT]](s32)
  ; CHECK-NEXT:   PseudoJL @take_i16, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  %val = load i16, i16* %addr
  call void @take_i16(i16 %val)
  call void @take_i16(i16 signext %val)
  call void @take_i16(i16 zeroext %val)
  ret void
}

declare void @callee_float(float %a)
define void @test_call_float() {
  ; CHECK-LABEL: name: test_call_float
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_FCONSTANT float 0.000000e+00
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @callee_float, csr_aie2, implicit-def $lr, implicit $r0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_float(float 0.)
  ret void
}

declare void @callee_double(double %a)
define void @test_call_double() {
  ; CHECK-LABEL: name: test_call_double
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s64) = G_FCONSTANT double 0.000000e+00
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C]](s64)
  ; CHECK-NEXT:   $r0 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   PseudoJL @callee_double, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_double(double 0.)
  ret void
}

declare void @multiple_args_callee(i32, i64)
define void @test_multiple_args(i64 %in) {
  ; CHECK-LABEL: name: test_multiple_args
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[MV:%[0-9]+]]:_(s64) = G_MERGE_VALUES [[COPY]](s32), [[COPY1]](s32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 42
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[MV]](s64)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   PseudoJL @multiple_args_callee, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @multiple_args_callee(i32 42, i64 %in)
  ret void
}

declare void @test_stack_slots_i1([8 x i32] %regs, i1)
define void @test_call_stack_i1() {
  ; CHECK-LABEL: name: test_call_stack_i1
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s1) = G_CONSTANT i1 false
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[C1]](s1)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C2]](s32)
  ; CHECK-NEXT:   G_STORE [[ZEXT]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @test_stack_slots_i1, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_i1([8 x i32] zeroinitializer, i1 zeroext false)
  ret void
}

declare void @test_stack_slots_i8([8 x i32] %regs, i8)
define void @test_call_stack_i8() {
  ; CHECK-LABEL: name: test_call_stack_i8
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s8) = G_CONSTANT i8 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[C1]](s8)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C2]](s32)
  ; CHECK-NEXT:   G_STORE [[ANYEXT]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @test_stack_slots_i8, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[SEXT:%[0-9]+]]:_(s32) = G_SEXT [[C1]](s8)
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C3]](s32)
  ; CHECK-NEXT:   G_STORE [[SEXT]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @test_stack_slots_i8, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[C1]](s8)
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY2]], [[C4]](s32)
  ; CHECK-NEXT:   G_STORE [[ZEXT]](s32), [[PTR_ADD2]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @test_stack_slots_i8, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_i8([8 x i32] zeroinitializer, i8 0)
  call void @test_stack_slots_i8([8 x i32] zeroinitializer, i8 signext 0)
  call void @test_stack_slots_i8([8 x i32] zeroinitializer, i8 zeroext 0)
  ret void
}

declare void @test_stack_slots_i16([8 x i32] %regs, i16)
define void @test_call_stack_i16() {
  ; CHECK-LABEL: name: test_call_stack_i16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[C1]](s16)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C2]](s32)
  ; CHECK-NEXT:   G_STORE [[ANYEXT]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @test_stack_slots_i16, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[SEXT:%[0-9]+]]:_(s32) = G_SEXT [[C1]](s16)
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C3]](s32)
  ; CHECK-NEXT:   G_STORE [[SEXT]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @test_stack_slots_i16, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[C1]](s16)
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY2]], [[C4]](s32)
  ; CHECK-NEXT:   G_STORE [[ZEXT]](s32), [[PTR_ADD2]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @test_stack_slots_i16, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_i16([8 x i32] zeroinitializer, i16 0)
  call void @test_stack_slots_i16([8 x i32] zeroinitializer, i16 signext 0)
  call void @test_stack_slots_i16([8 x i32] zeroinitializer, i16 zeroext 0)
  ret void
}

declare void @test_stack_slots_i32([8 x i32] %regs, i32)
define void @test_call_stack_i32() {
  ; CHECK-LABEL: name: test_call_stack_i32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[C]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @test_stack_slots_i32, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_i32([8 x i32] zeroinitializer, i32 0)
  ret void
}

declare void @test_stack_slots_i64([8 x i32] %regs, i64)
define void @test_call_stack_i64() {
  ; CHECK-LABEL: name: test_call_stack_i64
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s64) = G_CONSTANT i64 9
  ; CHECK-NEXT:   ADJCALLSTACKUP 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C1]](s64)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 -8
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C2]](s32)
  ; CHECK-NEXT:   G_STORE [[UV]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 8)
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C3]](s32)
  ; CHECK-NEXT:   G_STORE [[UV1]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @test_stack_slots_i64, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_i64([8 x i32] zeroinitializer, i64 9)
  ret void
}

declare void @test_stack_slots_ptr(i32* %ptr1, i32* %ptr2, i32* %ptr3,
                                   i32* %ptr4, i32* %ptr5, i32* %ptr6,
                                   i32* %ptr_stack)
define void @test_call_stack_ptr() {
  ; CHECK-LABEL: name: test_call_stack_ptr
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[C]](p0), [[PTR_ADD]](p0) :: (store (p0) into stack - 4, align 4, basealign 32)
  ; CHECK-NEXT:   $p0 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p1 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p2 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p3 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p4 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p5 = COPY [[C]](p0)
  ; CHECK-NEXT:   PseudoJL @test_stack_slots_ptr, csr_aie2, implicit-def $lr, implicit $p0, implicit $p1, implicit $p2, implicit $p3, implicit $p4, implicit $p5
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @test_stack_slots_ptr(i32* null, i32* null, i32* null,
                                  i32* null, i32* null, i32* null,
                                  i32* null)
  ret void
}

; FIXME
; %stack crosses the Stack-Reg boundary (for AIE2), it should go on the stack.
; %r7 can be passed "out-of-order" in the remaining r7 GPR.
declare void @cross_stack_reg_boundary(i64 %r01, i64 %r23, i64 %r45, i32 %r6, i64 %stack, i32 %r7)
define void @test_cross_stack_reg_boundary() {
  ; CHECK-LABEL: name: test_cross_stack_reg_boundary
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 1
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s64) = G_CONSTANT i64 2
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s64) = G_CONSTANT i64 3
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 4
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s64) = G_CONSTANT i64 5
  ; CHECK-NEXT:   [[C5:%[0-9]+]]:_(s32) = G_CONSTANT i32 6
  ; CHECK-NEXT:   ADJCALLSTACKUP 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C]](s64)
  ; CHECK-NEXT:   [[UV2:%[0-9]+]]:_(s32), [[UV3:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C1]](s64)
  ; CHECK-NEXT:   [[UV4:%[0-9]+]]:_(s32), [[UV5:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C2]](s64)
  ; CHECK-NEXT:   [[UV6:%[0-9]+]]:_(s32), [[UV7:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C4]](s64)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C6:%[0-9]+]]:_(s32) = G_CONSTANT i32 -8
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C6]](s32)
  ; CHECK-NEXT:   G_STORE [[UV6]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 8)
  ; CHECK-NEXT:   [[C7:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C7]](s32)
  ; CHECK-NEXT:   G_STORE [[UV7]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[UV2]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[UV3]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[UV4]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[UV5]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C3]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C5]](s32)
  ; CHECK-NEXT:   PseudoJL @cross_stack_reg_boundary, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @cross_stack_reg_boundary(i64 1, i64 2, i64 3, i32 4, i64 5, i32 6)
  ret void
}

; r0 and r1 are reserved by the RetCC
; (AIE2) Parameters are now passed from r2
declare i64 @retcc_reserved_GPRs(i32 %r2)
define void @test_retcc_reserved_GPRs() {
  ; CHECK-LABEL: name: test_retcc_reserved_GPRs
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @retcc_reserved_GPRs, csr_aie2, implicit-def $lr, implicit $r2, implicit-def $r0, implicit-def $r1
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[MV:%[0-9]+]]:_(s64) = G_MERGE_VALUES [[COPY]](s32), [[COPY1]](s32)
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call i64 @retcc_reserved_GPRs(i32 1)
  ret void
}

; p0 is reserved by the RetCC
; Parameters are now passed from p1
declare i32* @retcc_reserved_PTRs(i32* %p1)
define void @test_retcc_reserved_PTRs() {
  ; CHECK-LABEL: name: test_retcc_reserved_PTRs
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $p1 = COPY [[C]](p0)
  ; CHECK-NEXT:   PseudoJL @retcc_reserved_PTRs, csr_aie2, implicit-def $lr, implicit $p1, implicit-def $p0
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call i32* @retcc_reserved_PTRs(i32* null)
  ret void
}
