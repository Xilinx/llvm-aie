; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

%struct.S4I = type { i32, i32, i32, i32 }
%struct.SLII = type { i64, i32 }
%struct.S4P = type { i32*, i32*, i32*, i32* }
%struct.S2I2P = type { i32, i32, i32*, i32* }

@G1 = global i32 0
@G2 = global i32 0
@G3 = global i32 0
@G4 = global i32 0

; Pass structs only containing integers
; The first two struct should be passed in $r0-$r7
; The last one in [SP-4, SP-20[
declare void @pass_3S4I(%struct.S4I, %struct.S4I, %struct.S4I)
define void @call_pass_3S4I() {
  ; CHECK-LABEL: name: call_pass_3S4I
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 2
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 4
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 5
  ; CHECK-NEXT:   [[C5:%[0-9]+]]:_(s32) = G_CONSTANT i32 6
  ; CHECK-NEXT:   [[C6:%[0-9]+]]:_(s32) = G_CONSTANT i32 7
  ; CHECK-NEXT:   [[C7:%[0-9]+]]:_(s32) = G_CONSTANT i32 8
  ; CHECK-NEXT:   ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C8:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C8]](s32)
  ; CHECK-NEXT:   G_STORE [[C]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   [[C9:%[0-9]+]]:_(s32) = G_CONSTANT i32 -8
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C9]](s32)
  ; CHECK-NEXT:   G_STORE [[C1]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 8)
  ; CHECK-NEXT:   [[C10:%[0-9]+]]:_(s32) = G_CONSTANT i32 -12
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C10]](s32)
  ; CHECK-NEXT:   G_STORE [[C2]](s32), [[PTR_ADD2]](p0) :: (store (s32) into stack - 12, basealign 8)
  ; CHECK-NEXT:   [[C11:%[0-9]+]]:_(s32) = G_CONSTANT i32 -16
  ; CHECK-NEXT:   [[PTR_ADD3:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C11]](s32)
  ; CHECK-NEXT:   G_STORE [[C3]](s32), [[PTR_ADD3]](p0) :: (store (s32) into stack - 16)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C1]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C2]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C3]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C4]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C5]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C6]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C7]](s32)
  ; CHECK-NEXT:   PseudoJL @pass_3S4I, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  call void @pass_3S4I(%struct.S4I { i32 1, i32 2, i32 3, i32 4 },
                       %struct.S4I { i32 5, i32 6, i32 7, i32 8 },
                       %struct.S4I { i32 1, i32 2, i32 3, i32 4 })
  ret void
}

declare void @pass_2S4P(%struct.S4P, %struct.S4P)
define void @call_pass_2S4P() {
  ; CHECK-LABEL: name: call_pass_2S4P
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @G1
  ; CHECK-NEXT:   [[GV1:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @G2
  ; CHECK-NEXT:   [[GV2:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @G3
  ; CHECK-NEXT:   [[GV3:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @G4
  ; CHECK-NEXT:   ADJCALLSTACKUP 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C]](s32)
  ; CHECK-NEXT:   G_STORE [[GV2]](p0), [[PTR_ADD]](p0) :: (store (s20) into stack - 4, align 4, basealign 32)
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -8
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[GV3]](p0), [[PTR_ADD1]](p0) :: (store (s20) into stack - 8, align 4)
  ; CHECK-NEXT:   $p0 = COPY [[GV]](p0)
  ; CHECK-NEXT:   $p1 = COPY [[GV1]](p0)
  ; CHECK-NEXT:   $p2 = COPY [[GV2]](p0)
  ; CHECK-NEXT:   $p3 = COPY [[GV3]](p0)
  ; CHECK-NEXT:   $p4 = COPY [[GV]](p0)
  ; CHECK-NEXT:   $p5 = COPY [[GV1]](p0)
  ; CHECK-NEXT:   PseudoJL @pass_2S4P, csr_aie2, implicit-def $lr, implicit $p0, implicit $p1, implicit $p2, implicit $p3, implicit $p4, implicit $p5
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  call void @pass_2S4P(%struct.S4P { i32* @G1, i32* @G2, i32* @G3, i32* @G4 }, %struct.S4P { i32* @G1, i32* @G2, i32* @G3, i32* @G4 })
  ret void
}

declare void @pass_2S2I2P(%struct.S2I2P, %struct.S2I2P)
define void @call_pass_2S2I2P() {
  ; CHECK-LABEL: name: call_pass_2S2I2P
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 2
  ; CHECK-NEXT:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @G1
  ; CHECK-NEXT:   [[GV1:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @G2
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 4
  ; CHECK-NEXT:   [[GV2:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @G3
  ; CHECK-NEXT:   [[GV3:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @G4
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C1]](s32)
  ; CHECK-NEXT:   $p0 = COPY [[GV]](p0)
  ; CHECK-NEXT:   $p1 = COPY [[GV1]](p0)
  ; CHECK-NEXT:   $r2 = COPY [[C2]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C3]](s32)
  ; CHECK-NEXT:   $p2 = COPY [[GV2]](p0)
  ; CHECK-NEXT:   $p3 = COPY [[GV3]](p0)
  ; CHECK-NEXT:   PseudoJL @pass_2S2I2P, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $p0, implicit $p1, implicit $r2, implicit $r3, implicit $p2, implicit $p3
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  call void @pass_2S2I2P(%struct.S2I2P { i32 1, i32 2, i32* @G1, i32* @G2 }, %struct.S2I2P { i32 3, i32 4, i32* @G3, i32* @G4 })
  ret void
}

; Pass a struct on the reg-stack boundary, it will be passed partly in
; registers, partly on the stack.
declare void @pass_S4I_boundary([6 x i32], %struct.S4I)
define void @call_pass_S4I_boundary() {
  ; CHECK-LABEL: name: call_pass_S4I_boundary
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 2
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 4
  ; CHECK-NEXT:   ADJCALLSTACKUP 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C5:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C5]](s32)
  ; CHECK-NEXT:   G_STORE [[C3]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   [[C6:%[0-9]+]]:_(s32) = G_CONSTANT i32 -8
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C6]](s32)
  ; CHECK-NEXT:   G_STORE [[C4]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 8)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C1]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C2]](s32)
  ; CHECK-NEXT:   PseudoJL @pass_S4I_boundary, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  call void @pass_S4I_boundary([6 x i32] zeroinitializer, %struct.S4I { i32 1, i32 2, i32 3, i32 4 })
  ret void
}

; %struct.SLII crosses the register-stack boundary
; The long int isn't split between reg and stack, but moved entirely to the
; stack. The last element of the struct fits in the last free register, so
; it is moved there (not preserving the struct ordering).
; 5 -> $r7
; (i64)4 -> [SP-4, SP-12[
declare void @pass_SLII_boundary([7 x i32], %struct.SLII)
define void @call_pass_SLII_boundary() {
  ; CHECK-LABEL: name: call_pass_SLII_boundary
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s64) = G_CONSTANT i64 4
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 5
  ; CHECK-NEXT:   ADJCALLSTACKUP 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C1]](s64)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 -8
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C3]](s32)
  ; CHECK-NEXT:   G_STORE [[UV]](s32), [[PTR_ADD]](p0) :: (store (s32) into stack - 8)
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C4]](s32)
  ; CHECK-NEXT:   G_STORE [[UV1]](s32), [[PTR_ADD1]](p0) :: (store (s32) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r5 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r6 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r7 = COPY [[C2]](s32)
  ; CHECK-NEXT:   PseudoJL @pass_SLII_boundary, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 8, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @pass_SLII_boundary([7 x i32] zeroinitializer, %struct.SLII { i64 4, i32 5 })
  ret void
}

; (AIE2) r0,r1,r2,r3 are reserved by the result type.
;        Parameters are passed from r4
declare %struct.S4I @retcc_reserved_GPRs(i32)
define void @test_retcc_reserved_GPRs() {
  ; CHECK-LABEL: name: test_retcc_reserved_GPRs
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r4 = COPY [[C]](s32)
  ; CHECK-NEXT:   PseudoJL @retcc_reserved_GPRs, csr_aie2, implicit-def $lr, implicit $r4, implicit-def $r0, implicit-def $r1, implicit-def $r2, implicit-def $r3
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r3
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call %struct.S4I @retcc_reserved_GPRs(i32 1)
  ret void
}
