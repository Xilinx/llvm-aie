; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
;  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
;  See https://llvm.org/LICENSE.txt for license information.
;  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; Modifications (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 --issue-limit=1 -verify-machineinstrs -o - < %s \
; RUN:   | FileCheck %s

define void @test_simple_dyn_alloca(i32 noundef %n) {
; CHECK-LABEL: test_simple_dyn_alloca:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    paddb [sp], #32; nopa ; nops ; nopxm ; nopv
; CHECK-NEXT:    mova r1, #2; nopx
; CHECK-NEXT:    st p7, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    mov p7, sp
; CHECK-NEXT:    mov p1, sp
; CHECK-NEXT:    lshl r0, r0, r1
; CHECK-NEXT:    mova r1, #-32
; CHECK-NEXT:    st lr, [sp, #-28] // 4-byte Folded Spill
; CHECK-NEXT:    padda [p7], #-32
; CHECK-NEXT:    add r0, r0, #31
; CHECK-NEXT:    jl #extern_call
; CHECK-NEXT:    mov p0, p1 // Delay Slot 5
; CHECK-NEXT:    and r0, r0, r1 // Delay Slot 4
; CHECK-NEXT:    mov m0, r0 // Delay Slot 3
; CHECK-NEXT:    paddb [p1], m0 // Delay Slot 2
; CHECK-NEXT:    mov sp, p1 // Delay Slot 1
; CHECK-NEXT:    nopa ; nopb ; nopx ; mov sp, p7; nops
; CHECK-NEXT:    lda lr, [sp, #-28] // 4-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda p7, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-32 // Delay Slot 1
entry:
  %0 = trunc i32 %n to i20
  %vla = alloca i32, i20 %0, align 4
  call void @extern_call(ptr nonnull %vla)
  ret void
}

define void @test_loop_dyn_alloca(i32 noundef %n) {
; CHECK-LABEL: test_loop_dyn_alloca:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #64; nopxm
; CHECK-NEXT:    st p7, [sp, #-64] // 4-byte Folded Spill
; CHECK-NEXT:    mov p7, sp
; CHECK-NEXT:    st r16, [sp, #-36] // 4-byte Folded Spill
; CHECK-NEXT:    mova r16, #1
; CHECK-NEXT:    st r17, [sp, #-40] // 4-byte Folded Spill
; CHECK-NEXT:    mova r17, #0
; CHECK-NEXT:    st r18, [sp, #-44] // 4-byte Folded Spill
; CHECK-NEXT:    mova r18, #10
; CHECK-NEXT:    st r19, [sp, #-48] // 4-byte Folded Spill
; CHECK-NEXT:    mova r19, #2
; CHECK-NEXT:    st r20, [sp, #-52] // 4-byte Folded Spill
; CHECK-NEXT:    mova r20, #-32
; CHECK-NEXT:    st r21, [sp, #-56] // 4-byte Folded Spill
; CHECK-NEXT:    mova r21, #0
; CHECK-NEXT:    st lr, [sp, #-32] // 4-byte Folded Spill
; CHECK-NEXT:    st p6, [sp, #-60] // 4-byte Folded Spill
; CHECK-NEXT:    padda [p7], #-64
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB1_1: // %for.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    nopa ; nopx ; mov p6, sp
; CHECK-NEXT:    mov p1, sp
; CHECK-NEXT:    lshl r0, r17, r19
; CHECK-NEXT:    add r1, r0, #31
; CHECK-NEXT:    jl #extern_call
; CHECK-NEXT:    mov p0, p1 // Delay Slot 5
; CHECK-NEXT:    and r2, r1, r20 // Delay Slot 4
; CHECK-NEXT:    mov m0, r2 // Delay Slot 3
; CHECK-NEXT:    paddb [p1], m0 // Delay Slot 2
; CHECK-NEXT:    mov sp, p1 // Delay Slot 1
; CHECK-NEXT:    nopa ; nopb ; add r17, r17, #1; nopm ; nops
; CHECK-NEXT:    ltu r3, r17, r16
; CHECK-NEXT:    xor r4, r17, r18
; CHECK-NEXT:    add r21, r21, r3
; CHECK-NEXT:    or r5, r4, r21
; CHECK-NEXT:    jnz r5, #.LBB1_1
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov sp, p6 // Delay Slot 1
; CHECK-NEXT:  // %bb.2: // %for.cond.cleanup
; CHECK-NEXT:    nopa ; nopb ; nopx ; mov sp, p7
; CHECK-NEXT:    lda p7, [sp, #-64] // 4-byte Folded Reload
; CHECK-NEXT:    lda p6, [sp, #-60] // 4-byte Folded Reload
; CHECK-NEXT:    lda lr, [sp, #-32] // 4-byte Folded Reload
; CHECK-NEXT:    lda r21, [sp, #-56] // 4-byte Folded Reload
; CHECK-NEXT:    lda r20, [sp, #-52] // 4-byte Folded Reload
; CHECK-NEXT:    lda r19, [sp, #-48] // 4-byte Folded Reload
; CHECK-NEXT:    lda r18, [sp, #-44] // 4-byte Folded Reload
; CHECK-NEXT:    lda r17, [sp, #-40] // 4-byte Folded Reload
; CHECK-NEXT:    lda r16, [sp, #-36] // 4-byte Folded Reload
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-64 // Delay Slot 1
entry:
  br label %for.body

for.cond.cleanup:
  ret void

for.body:
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %0 = call ptr @llvm.stacksave()
  %vla = alloca i32, i64 %indvars.iv, align 4
  call void @extern_call(ptr noundef nonnull %vla)
  call void @llvm.stackrestore(ptr %0)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 10
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define  void @test_huge_stack(i32 noundef %n) #0 {
; CHECK-LABEL: test_huge_stack:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #40064; nopx
; CHECK-NEXT:    movxm m0, #-40064
; CHECK-NEXT:    mova r1, #0
; CHECK-NEXT:    mova r2, #2
; CHECK-NEXT:    mova r3, #-32
; CHECK-NEXT:    st p7, [sp, #-40064] // 4-byte Folded Spill
; CHECK-NEXT:    mov p7, sp
; CHECK-NEXT:    mov p1, sp
; CHECK-NEXT:    st lr, [sp, #-40052] // 4-byte Folded Spill
; CHECK-NEXT:    st r16, [sp, #-40056] // 4-byte Folded Spill
; CHECK-NEXT:    st p6, [sp, #-40060] // 4-byte Folded Spill
; CHECK-NEXT:    padda [p7], m0
; CHECK-NEXT:    movxm m0, #-40048
; CHECK-NEXT:    mov p0, p7
; CHECK-NEXT:    mov p2, p7
; CHECK-NEXT:    mov p6, p7
; CHECK-NEXT:    paddb [p0], m0
; CHECK-NEXT:    paddb [p6], #-32
; CHECK-NEXT:    movxm m0, #-40032
; CHECK-NEXT:    st r0, [p0, #0]
; CHECK-NEXT:    lda r0, [p0, #0]
; CHECK-NEXT:    paddb [p2], m0
; CHECK-NEXT:    mov p0, sp
; CHECK-NEXT:    mov r16, p2
; CHECK-NEXT:    st p0, [p6, #0]
; CHECK-NEXT:    mov p0, p7
; CHECK-NEXT:    paddb [p0], #-24
; CHECK-NEXT:    lshl r2, r0, r2
; CHECK-NEXT:    st r0, [p0], #4
; CHECK-NEXT:    add r2, r2, #31
; CHECK-NEXT:    st r1, [p0, #0]
; CHECK-NEXT:    jl #extern_call
; CHECK-NEXT:    mov p0, p1 // Delay Slot 5
; CHECK-NEXT:    and r2, r2, r3 // Delay Slot 4
; CHECK-NEXT:    mov m0, r2 // Delay Slot 3
; CHECK-NEXT:    paddb [p1], m0 // Delay Slot 2
; CHECK-NEXT:    mov sp, p1 // Delay Slot 1
; CHECK-NEXT:    nopb ; nopa ; nops ; jl #extern_call; nopv
; CHECK-NEXT:    nopa ; nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov p0, r16 // Delay Slot 1
; CHECK-NEXT:    lda p0, [p6, #0]; nopx
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov sp, p0
; CHECK-NEXT:    mov sp, p7
; CHECK-NEXT:    lda lr, [sp, #-40052] // 4-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda p7, [sp, #-40064] // 4-byte Folded Reload
; CHECK-NEXT:    lda p6, [sp, #-40060] // 4-byte Folded Reload
; CHECK-NEXT:    lda r16, [sp, #-40056] // 4-byte Folded Reload
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-40064 // Delay Slot 1
entry:
  %n.addr = alloca i32, align 4
  %t = alloca [10000 x i32], align 16
  %saved_stack = alloca ptr, align 8
  %__vla_expr0 = alloca i64, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %1 = zext i32 %0 to i64
  %2 = call ptr @llvm.stacksave()
  store ptr %2, ptr %saved_stack, align 8
  %vla = alloca i32, i64 %1, align 16
  store i64 %1, ptr %__vla_expr0, align 8
  call void @extern_call(ptr noundef %vla)
  %arraydecay = getelementptr inbounds [10000 x i32], ptr %t, i64 0, i64 0
  call void @extern_call(ptr noundef %arraydecay)
  %3 = load ptr, ptr %saved_stack, align 8
  call void @llvm.stackrestore(ptr %3)
  ret void
}

declare void @extern_call(ptr)
declare ptr @llvm.stacksave() #0
declare void @llvm.stackrestore(ptr) #0

attributes #0 = { mustprogress nocallback nofree nosync nounwind willreturn }
