; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2 --issue-limit=1 %s -o - | FileCheck %s
%class.bfloat16 = type { bfloat }

define dso_local %class.bfloat16 @_Z13test_bfloat168bfloat16(%class.bfloat16 returned %arg.coerce)  {
; CHECK-LABEL: _Z13test_bfloat168bfloat16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r0, r1 // Delay Slot 1
entry:
  ret %class.bfloat16 %arg.coerce
}

define dso_local %class.bfloat16 @_Z13test_ext_elemf(float noundef %x) {
; CHECK-LABEL: _Z13test_ext_elemf:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov r2, r16
; CHECK-NEXT:    mova r16, #0
; CHECK-NEXT:    mov r29, r16
; CHECK-NEXT:    vinsert.32 x0, x0, r29, r1
; CHECK-NEXT:    vmov bmh0, x0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    vconv.bf16.fp32 wl0, bmh0 // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vextract.s16 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r2 // Delay Slot 1
entry:
  %0 = tail call <8 x i64> @llvm.aie2.v16accfloat()
  %1 = tail call <8 x i64> @llvm.aie2.vinsert32.accfloat(<8 x i64> %0, i32 0, float %x)
  %2 = tail call <16 x bfloat> @llvm.aie2.v16accfloat.to.v16bf16(<8 x i64> %1)
  %3 = tail call <16 x bfloat> @llvm.aie2.v16bfloat16()
  %4 = tail call <32 x bfloat> @llvm.aie2.concat.bf512.bf256(<16 x bfloat> %2, <16 x bfloat> %3)
  %5 = bitcast <32 x bfloat> %4 to <32 x i16>
  %6 = tail call i32 @llvm.aie2.vextract.elem16.I512(<32 x i16> %5, i32 0, i32 1)
  %elem.0.extract.trunc.i.i.i.i = trunc i32 %6 to i16
  %7 = bitcast i16 %elem.0.extract.trunc.i.i.i.i to bfloat
  %.fca.0.insert = insertvalue %class.bfloat16 poison, bfloat %7, 0
  ret %class.bfloat16 %.fca.0.insert
}

declare i32 @llvm.aie2.vextract.elem16.I512(<32 x i16>, i32, i32)
declare <8 x i64> @llvm.aie2.vinsert32.accfloat(<8 x i64>, i32, float)
declare <32 x bfloat> @llvm.aie2.concat.bf512.bf256(<16 x bfloat>, <16 x bfloat>)
declare <16 x bfloat> @llvm.aie2.v16accfloat.to.v16bf16(<8 x i64>)
declare <8 x i64> @llvm.aie2.v16accfloat()
declare <16 x bfloat> @llvm.aie2.v16bfloat16()
declare float @llvm.aie2.bfloat16.to.float(bfloat)
