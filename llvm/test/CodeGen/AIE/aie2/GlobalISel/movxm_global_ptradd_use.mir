# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -mtriple aie2 -run-pass=aie2-prelegalizer-combiner -aie2prelegalizercombiner-only-enable-rule="combine_globalval_offset" %s -verify-machineinstrs -o - | FileCheck %s
--- |
  %struct.anon = type { i16, i16, i8, i32 }

  @Y = internal global %struct.anon zeroinitializer, align 4

  define dso_local ptr @movxm_ptr_add_use() #0 {
  entry:
    %0 = load i16, ptr @Y, align 4
    %conv = sext i16 %0 to i32
    %1 = load i16, ptr getelementptr inbounds (%struct.anon, ptr @Y, i32 0, i32 1), align 2
    %conv1 = sext i16 %1 to i32
    %add = add nsw i32 %conv, %conv1
    %2 = load i8, ptr getelementptr inbounds (%struct.anon, ptr @Y, i32 0, i32 2), align 4
    %conv2 = sext i8 %2 to i32
    %add3 = add nsw i32 %add, %conv2
    store i32 %add3, ptr getelementptr inbounds (%struct.anon, ptr @Y, i32 0, i32 3), align 4
    ret ptr getelementptr inbounds (%struct.anon, ptr @Y, i32 0, i32 3)
  }

...
---
name:            movxm_ptr_add_use
legalized:       false
body:             |
  bb.1.entry:
    ; CHECK-LABEL: name: movxm_ptr_add_use
    ; CHECK: [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE target-flags(aie2-global) @Y + 4
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s20) = G_CONSTANT i20 -4
    ; CHECK-NEXT: [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[GV]], [[C]](s20)
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s20) = G_CONSTANT i20 4
    ; CHECK-NEXT: [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[GV]], [[C1]](s20)
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s20) = G_CONSTANT i20 -2
    ; CHECK-NEXT: [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[GV]], [[C2]](s20)
    ; CHECK-NEXT: [[SEXTLOAD:%[0-9]+]]:_(s32) = G_SEXTLOAD [[PTR_ADD]](p0) :: (dereferenceable load (s16) from @Y, align 4)
    ; CHECK-NEXT: [[SEXTLOAD1:%[0-9]+]]:_(s32) = G_SEXTLOAD [[PTR_ADD2]](p0) :: (dereferenceable load (s16) from `ptr getelementptr inbounds (%struct.anon, ptr @Y, i32 0, i32 1)`)
    ; CHECK-NEXT: [[ADD:%[0-9]+]]:_(s32) = nsw G_ADD [[SEXTLOAD]], [[SEXTLOAD1]]
    ; CHECK-NEXT: [[SEXTLOAD2:%[0-9]+]]:_(s32) = G_SEXTLOAD [[GV]](p0) :: (dereferenceable load (s8) from `ptr getelementptr inbounds (%struct.anon, ptr @Y, i32 0, i32 2)`, align 4)
    ; CHECK-NEXT: [[ADD1:%[0-9]+]]:_(s32) = nsw G_ADD [[ADD]], [[SEXTLOAD2]]
    ; CHECK-NEXT: G_STORE [[ADD1]](s32), [[PTR_ADD1]](p0) :: (store (s32) into `ptr getelementptr inbounds (%struct.anon, ptr @Y, i32 0, i32 3)`)
    ; CHECK-NEXT: $p0 = COPY [[PTR_ADD1]](p0)
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit $p0
    %1:_(p0) = G_GLOBAL_VALUE @Y
    %2:_(s20) = G_CONSTANT i20 8
    %0:_(p0) = G_PTR_ADD %1, %2(s20)
    %7:_(s20) = G_CONSTANT i20 2
    %6:_(p0) = G_PTR_ADD %1, %7(s20)
    %12:_(s20) = G_CONSTANT i20 4
    %11:_(p0) = G_PTR_ADD %1, %12(s20)
    %3:_(s16) = G_LOAD %1(p0) :: (dereferenceable load (s16) from @Y, align 4)
    %4:_(s32) = G_SEXT %3(s16)
    %5:_(s16) = G_LOAD %6(p0) :: (dereferenceable load (s16) from `ptr getelementptr inbounds (%struct.anon, ptr @Y, i32 0, i32 1)`)
    %8:_(s32) = G_SEXT %5(s16)
    %9:_(s32) = nsw G_ADD %4, %8
    %10:_(s8) = G_LOAD %11(p0) :: (dereferenceable load (s8) from `ptr getelementptr inbounds (%struct.anon, ptr @Y, i32 0, i32 2)`, align 4)
    %13:_(s32) = G_SEXT %10(s8)
    %14:_(s32) = nsw G_ADD %9, %13
    G_STORE %14(s32), %0(p0) :: (store (s32) into `ptr getelementptr inbounds (%struct.anon, ptr @Y, i32 0, i32 3)`)
    $p0 = COPY %0(p0)
    PseudoRET implicit $lr, implicit $p0

...
