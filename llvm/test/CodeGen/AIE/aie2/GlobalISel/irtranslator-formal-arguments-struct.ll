; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --print-fixed-stack
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

%struct.S4I = type { i32, i32, i32, i32 }
%struct.SLII = type { i64, i32 }
%struct.S4P = type { i32*, i32*, i32*, i32* }
%struct.S2I2P = type { i32, i32, i32*, i32* }

@g_ptr_32 = global i32 0

; Check that structs passed by value are used properly:
; extractvalue %struct.S4I %b, 3 should be in $r7
; extractvalue %struct.S4I %c, 3 should be in [sp, #-16]
define void @use_3S4I(%struct.S4I %a, %struct.S4I %b, %struct.S4I %c) {
  ; CHECK-LABEL: name: use_3S4I
  ; CHECK: fixedStack:
  ; CHECK-NEXT:   - { id: 0, type: default, offset: -16, size: 4, alignment: 16, stack-id: default, 
  ; CHECK-NEXT:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true, 
  ; CHECK-NEXT:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK-NEXT:   - { id: 1, type: default, offset: -12, size: 4, alignment: 4, stack-id: default, 
  ; CHECK-NEXT:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true, 
  ; CHECK-NEXT:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK-NEXT:   - { id: 2, type: default, offset: -8, size: 4, alignment: 8, stack-id: default, 
  ; CHECK-NEXT:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true, 
  ; CHECK-NEXT:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK-NEXT:   - { id: 3, type: default, offset: -4, size: 4, alignment: 4, stack-id: default, 
  ; CHECK-NEXT:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true, 
  ; CHECK-NEXT:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(s32) = COPY $r4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(s32) = COPY $r5
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(s32) = COPY $r6
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(s32) = COPY $r7
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.3
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s32) from %fixed-stack.3)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.2
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX1]](p0) :: (invariant load (s32) from %fixed-stack.2, align 8)
  ; CHECK-NEXT:   [[FRAME_INDEX2:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD2:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX2]](p0) :: (invariant load (s32) from %fixed-stack.1)
  ; CHECK-NEXT:   [[FRAME_INDEX3:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD3:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX3]](p0) :: (invariant load (s32) from %fixed-stack.0, align 16)
  ; CHECK-NEXT:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @g_ptr_32
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s32) = G_ADD [[LOAD3]], [[COPY7]]
  ; CHECK-NEXT:   G_STORE [[ADD]](s32), [[GV]](p0) :: (store (s32) into @g_ptr_32)
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  %b.3.extract = extractvalue %struct.S4I %b, 3
  %c.3.extract = extractvalue %struct.S4I %c, 3
  %res = add i32 %c.3.extract, %b.3.extract
  store i32 %res, i32* @g_ptr_32
  ret void
}

define void @pass_2S4P(%struct.S4P, %struct.S4P) {
  ; CHECK-LABEL: name: pass_2S4P
  ; CHECK: fixedStack:
  ; CHECK-NEXT:   - { id: 0, type: default, offset: -8, size: 3, alignment: 8, stack-id: default, 
  ; CHECK-NEXT:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true, 
  ; CHECK-NEXT:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK-NEXT:   - { id: 1, type: default, offset: -4, size: 3, alignment: 4, stack-id: default, 
  ; CHECK-NEXT:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true, 
  ; CHECK-NEXT:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $p0, $p1, $p2, $p3, $p4, $p5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(p0) = COPY $p1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(p0) = COPY $p2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(p0) = COPY $p3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(p0) = COPY $p4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(p0) = COPY $p5
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(p0) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s20) from %fixed-stack.1, align 4)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(p0) = G_LOAD [[FRAME_INDEX1]](p0) :: (invariant load (s20) from %fixed-stack.0, align 8)
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  ret void
}

define void @pass_2S2I2P(%struct.S2I2P, %struct.S2I2P) {
  ; CHECK-LABEL: name: pass_2S2I2P
  ; CHECK: fixedStack:
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $p0, $p1, $p2, $p3, $r0, $r1, $r2, $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(p0) = COPY $p0
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(p0) = COPY $p1
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(s32) = COPY $r3
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(p0) = COPY $p2
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(p0) = COPY $p3
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  ret void
}

; Pass a struct on the reg-stack boundary, it will be passed partly in
; registers, partly on the stack.
define void @use_S4I_boundary([6 x i32] %a, %struct.S4I %s) {
  ; CHECK-LABEL: name: use_S4I_boundary
  ; CHECK: fixedStack:
  ; CHECK-NEXT:   - { id: 0, type: default, offset: -8, size: 4, alignment: 8, stack-id: default, 
  ; CHECK-NEXT:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true, 
  ; CHECK-NEXT:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK-NEXT:   - { id: 1, type: default, offset: -4, size: 4, alignment: 4, stack-id: default, 
  ; CHECK-NEXT:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true, 
  ; CHECK-NEXT:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(s32) = COPY $r4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(s32) = COPY $r5
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(s32) = COPY $r6
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(s32) = COPY $r7
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s32) from %fixed-stack.1)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX1]](p0) :: (invariant load (s32) from %fixed-stack.0, align 8)
  ; CHECK-NEXT:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @g_ptr_32
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s32) = G_ADD [[COPY6]], [[LOAD1]]
  ; CHECK-NEXT:   G_STORE [[ADD]](s32), [[GV]](p0) :: (store (s32) into @g_ptr_32)
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  %s.0.extract = extractvalue %struct.S4I %s, 0
  %s.3.extract = extractvalue %struct.S4I %s, 3
  %res = add i32 %s.0.extract, %s.3.extract
  store i32 %res, i32* @g_ptr_32
  ret void
}

; %struct.SLII crosses the register-stack boundary
; The long int isn't split between reg and stack, but moved entirely to the
; stack. The last element of the struct fits in the last free register, so
; it is moved there (not preserving the struct ordering).
define void @use_SLII_boundary([7 x i32] %a, %struct.SLII %s) {
  ; CHECK-LABEL: name: use_SLII_boundary
  ; CHECK: fixedStack:
  ; CHECK-NEXT:   - { id: 0, type: default, offset: -4, size: 4, alignment: 4, stack-id: default, 
  ; CHECK-NEXT:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true, 
  ; CHECK-NEXT:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK-NEXT:   - { id: 1, type: default, offset: -8, size: 4, alignment: 8, stack-id: default, 
  ; CHECK-NEXT:       isImmutable: true, isAliased: false, callee-saved-register: '', callee-saved-restored: true, 
  ; CHECK-NEXT:       debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3, $r4, $r5, $r6, $r7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(s32) = COPY $r3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(s32) = COPY $r4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(s32) = COPY $r5
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(s32) = COPY $r6
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s32) from %fixed-stack.1, align 8)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX1]](p0) :: (invariant load (s32) from %fixed-stack.0)
  ; CHECK-NEXT:   [[MV:%[0-9]+]]:_(s64) = G_MERGE_VALUES [[LOAD]](s32), [[LOAD1]](s32)
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(s32) = COPY $r7
  ; CHECK-NEXT:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @g_ptr_32
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s32) = G_TRUNC [[MV]](s64)
  ; CHECK-NEXT:   G_STORE [[TRUNC]](s32), [[GV]](p0) :: (store (s32) into @g_ptr_32)
  ; CHECK-NEXT:   PseudoRET implicit $lr
entry:
  %s.0.extract = extractvalue %struct.SLII %s, 0
  %tmp = trunc i64 %s.0.extract to i32
  store i32 %tmp, i32* @g_ptr_32
  ret void
}

; (AIE2) r0,r1,r2,r3 are reserved by the result type.
;        Parameters are passed from r4
define %struct.S4I @retcc_reserved_GPRs(i32 %val) {
  ; CHECK-LABEL: name: retcc_reserved_GPRs
  ; CHECK: fixedStack:
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r4
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s32) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   $r0 = COPY [[COPY]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[COPY]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[COPY]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[COPY]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3
  %s1 = insertvalue %struct.S4I undef, i32 %val, 0
  %s2 = insertvalue %struct.S4I %s1, i32 %val, 1
  %s3 = insertvalue %struct.S4I %s2, i32 %val, 2
  %s4 = insertvalue %struct.S4I %s3, i32 %val, 3
  ret %struct.S4I %s4
}
