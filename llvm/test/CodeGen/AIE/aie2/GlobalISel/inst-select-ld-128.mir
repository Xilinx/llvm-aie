# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc -mtriple aie2 -run-pass=instruction-select %s -verify-machineinstrs -o - | FileCheck %s
---
name:            mask_load_spill_addressing
legalized:       true
regBankSelected: true
stack:
  - { id: 0, name: "", offset: 0, size: 16, alignment: 16}
body:             |
  bb.1.entry:
    ; CHECK-LABEL: name: mask_load_spill_addressing
    ; CHECK: [[LDA_dmv_lda_q_ag_spill:%[0-9]+]]:vec128 = LDA_dmv_lda_q_ag_spill %stack.0, implicit $sp :: (volatile dereferenceable load (<4 x s32>))
    ; CHECK-NEXT: $q0 = COPY [[LDA_dmv_lda_q_ag_spill]]
    %1:ptrregbank(p0) = G_FRAME_INDEX %stack.0
    %2:vregbank(<4 x s32>) = G_LOAD %1(p0) :: (volatile dereferenceable load (<4 x s32>))
    $q0 = COPY %2(<4 x s32>)

...
---
name:            vector_vlda_128
legalized:       true
regBankSelected: true
body:             |
  bb.1.entry:
    ; CHECK-LABEL: name: vector_vlda_128
    ; CHECK: [[MOV_PD_imm10_pseudo:%[0-9]+]]:ep = MOV_PD_imm10_pseudo 0
    ; CHECK-NEXT: [[VLDA_128_:%[0-9]+]]:mwa = VLDA_128 [[MOV_PD_imm10_pseudo]] :: (load (<4 x s32>) from `ptr null`)
    ; CHECK-NEXT: $q0 = COPY [[VLDA_128_]]
    %2:ptrregbank(p0) = G_CONSTANT i20 0
    %1:vregbank(<4 x s32>) = G_LOAD %2(p0) :: (load (<4 x s32>) from `ptr null`)
    $q0 = COPY %1(<4 x s32>)

...

---
name:           postinc_load_imm
legalized:       true
regBankSelected: true
body:             |
  bb.0.entry:
    liveins: $p0, $p1

    ; CHECK-LABEL: name: postinc_load_imm
    ; CHECK: liveins: $p0, $p1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:ep = COPY $p1
    ; CHECK-NEXT: [[LDA_dmv_lda_q_ag_pstm_nrm_imm:%[0-9]+]]:vec128, [[LDA_dmv_lda_q_ag_pstm_nrm_imm1:%[0-9]+]]:ep = LDA_dmv_lda_q_ag_pstm_nrm_imm [[COPY]], 0 :: (load (<4 x s32>))
    ; CHECK-NEXT: [[LDA_dmv_lda_q_ag_pstm_nrm_imm2:%[0-9]+]]:vec128, [[LDA_dmv_lda_q_ag_pstm_nrm_imm3:%[0-9]+]]:ep = LDA_dmv_lda_q_ag_pstm_nrm_imm [[COPY]], -1024 :: (load (<4 x s32>))
    ; CHECK-NEXT: [[LDA_dmv_lda_q_ag_pstm_nrm_imm4:%[0-9]+]]:vec128, [[LDA_dmv_lda_q_ag_pstm_nrm_imm5:%[0-9]+]]:ep = LDA_dmv_lda_q_ag_pstm_nrm_imm [[COPY]], 1008 :: (load (<4 x s32>))
    ; CHECK-NEXT: [[LDA_dmv_lda_q_ag_pstm_nrm_imm6:%[0-9]+]]:vec128, [[LDA_dmv_lda_q_ag_pstm_nrm_imm7:%[0-9]+]]:ep = LDA_dmv_lda_q_ag_pstm_nrm_imm [[COPY]], -256 :: (load (<4 x s32>))
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit [[LDA_dmv_lda_q_ag_pstm_nrm_imm]], implicit [[LDA_dmv_lda_q_ag_pstm_nrm_imm2]], implicit [[LDA_dmv_lda_q_ag_pstm_nrm_imm4]], implicit [[LDA_dmv_lda_q_ag_pstm_nrm_imm6]]
    %0:ptrregbank(p0) = COPY $p1
    %1:modregbank(s20) = G_CONSTANT i20 0
    %2:modregbank(s20) = G_CONSTANT i20 -1024
    %3:modregbank(s20) = G_CONSTANT i20 1008
    %4:modregbank(s20) = G_CONSTANT i20 -256
    %5:ptrregbank(p0) = G_PTR_ADD %0, %1(s20)
    %6:ptrregbank(p0) = G_PTR_ADD %0, %2(s20)
    %7:ptrregbank(p0) = G_PTR_ADD %0, %3(s20)
    %8:ptrregbank(p0) = G_PTR_ADD %0, %4(s20)
    %9:vregbank(<4 x s32>), %10:ptrregbank(p0) = G_AIE_POSTINC_LOAD %0(p0), %1 :: (load (<4 x s32>))
    %11:vregbank(<4 x s32>), %12:ptrregbank(p0) = G_AIE_POSTINC_LOAD %0(p0), %2 :: (load (<4 x s32>))
    %13:vregbank(<4 x s32>), %14:ptrregbank(p0) = G_AIE_POSTINC_LOAD %0(p0), %3 :: (load (<4 x s32>))
    %15:vregbank(<4 x s32>), %16:ptrregbank(p0) = G_AIE_POSTINC_LOAD %0(p0), %4 :: (load (<4 x s32>))
    PseudoRET implicit $lr, implicit %9, implicit %11, implicit %13, implicit %15

...

---
name:           postinc_load_no_imm
legalized:       true
regBankSelected: true
body:             |
  bb.0.entry:
    liveins: $p0, $p1

    ; CHECK-LABEL: name: postinc_load_no_imm
    ; CHECK: liveins: $p0, $p1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:ep = COPY $p1
    ; CHECK-NEXT: [[MOVXM_lng_cg:%[0-9]+]]:em_as_32bit = MOVXM_lng_cg 1024
    ; CHECK-NEXT: [[MOVXM_lng_cg1:%[0-9]+]]:em_as_32bit = MOVXM_lng_cg 1123
    ; CHECK-NEXT: [[VLDB_128_ag_pstm_nrm:%[0-9]+]]:mwa, [[VLDB_128_ag_pstm_nrm1:%[0-9]+]]:ep = VLDB_128_ag_pstm_nrm [[COPY]], [[MOVXM_lng_cg]] :: (load (<4 x s32>))
    ; CHECK-NEXT: [[VLDB_128_ag_pstm_nrm2:%[0-9]+]]:mwa, [[VLDB_128_ag_pstm_nrm3:%[0-9]+]]:ep = VLDB_128_ag_pstm_nrm [[COPY]], [[MOVXM_lng_cg1]] :: (load (<4 x s32>))
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit [[VLDB_128_ag_pstm_nrm]], implicit [[VLDB_128_ag_pstm_nrm2]]
    %0:ptrregbank(p0) = COPY $p1
    %1:modregbank(s20) = G_CONSTANT i20 1024
    %2:modregbank(s20) = G_CONSTANT i20 1123
    %3:vregbank(<4 x s32>), %5:ptrregbank(p0) = G_AIE_POSTINC_LOAD %0(p0), %1 :: (load (<4 x s32>))
    %6:vregbank(<4 x s32>), %7:ptrregbank(p0) = G_AIE_POSTINC_LOAD %0(p0), %2 :: (load (<4 x s32>))
    PseudoRET implicit $lr, implicit %3, implicit %6

...

---
name: post-inc-2d-vector-ldb-v
legalized:       true
regBankSelected: true
tracksRegLiveness: true
body: |
  bb.0:
    liveins: $p0
    ; CHECK-LABEL: name: post-inc-2d-vector-ldb-v
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:ep = COPY $p0
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo:%[0-9]+]]:em = MOV_PD_imm10_pseudo 1
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo1:%[0-9]+]]:edj = MOV_PD_imm10_pseudo 2
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo2:%[0-9]+]]:edn = MOV_PD_imm10_pseudo 3
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo3:%[0-9]+]]:edc = MOV_PD_imm10_pseudo 4
    ; CHECK-NEXT: [[REG_SEQUENCE:%[0-9]+]]:ed = REG_SEQUENCE [[MOV_PD_imm10_pseudo]], %subreg.sub_mod, [[MOV_PD_imm10_pseudo2]], %subreg.sub_dim_size, [[MOV_PD_imm10_pseudo1]], %subreg.sub_dim_stride, [[MOV_PD_imm10_pseudo3]], %subreg.sub_dim_count
    ; CHECK-NEXT: [[VLDB_2D_128_:%[0-9]+]]:mwa, [[VLDB_2D_128_1:%[0-9]+]]:ep, [[VLDB_2D_128_2:%[0-9]+]]:edc = VLDB_2D_128 [[COPY]], [[REG_SEQUENCE]] :: (load (<4 x s32>))
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit [[VLDB_2D_128_]]
    %0:ptrregbank(p0) = COPY $p0
    %1:em(s20) = G_CONSTANT i20 1
    %2:edj(s20) = G_CONSTANT i20 2
    %3:edn(s20) = G_CONSTANT i20 3
    %4:edc(s20) = G_CONSTANT i20 4
    %5:vregbank(<4 x s32>), %6:ptrregbank(p0), %7:modregbank(s20) = G_AIE_POSTINC_2D_LOAD %0, %1, %2, %3, %4 :: (load (<4 x s32>))
    PseudoRET implicit $lr, implicit %5
...

---
name: post-inc-3d-vector-ldb-v
legalized:       true
regBankSelected: true
tracksRegLiveness: true
body: |
  bb.0:
    liveins: $p0
    ; CHECK-LABEL: name: post-inc-3d-vector-ldb-v
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:ep = COPY $p0
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo:%[0-9]+]]:em = MOV_PD_imm10_pseudo 1
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo1:%[0-9]+]]:edj = MOV_PD_imm10_pseudo 2
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo2:%[0-9]+]]:edj = MOV_PD_imm10_pseudo 3
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo3:%[0-9]+]]:edn = MOV_PD_imm10_pseudo 4
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo4:%[0-9]+]]:edn = MOV_PD_imm10_pseudo 5
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo5:%[0-9]+]]:edc = MOV_PD_imm10_pseudo 6
    ; CHECK-NEXT: [[MOV_PD_imm10_pseudo6:%[0-9]+]]:edc = MOV_PD_imm10_pseudo 7
    ; CHECK-NEXT: [[REG_SEQUENCE:%[0-9]+]]:eds = REG_SEQUENCE [[MOV_PD_imm10_pseudo]], %subreg.sub_mod, [[MOV_PD_imm10_pseudo3]], %subreg.sub_dim_size, [[MOV_PD_imm10_pseudo1]], %subreg.sub_dim_stride, [[MOV_PD_imm10_pseudo5]], %subreg.sub_dim_count, [[MOV_PD_imm10_pseudo4]], %subreg.sub_hi_dim_then_sub_dim_size, [[MOV_PD_imm10_pseudo2]], %subreg.sub_hi_dim_then_sub_dim_stride, [[MOV_PD_imm10_pseudo6]], %subreg.sub_hi_dim_then_sub_dim_count
    ; CHECK-NEXT: [[VLDB_3D_128_:%[0-9]+]]:mwa, [[VLDB_3D_128_1:%[0-9]+]]:ep, [[VLDB_3D_128_2:%[0-9]+]]:edc, [[VLDB_3D_128_3:%[0-9]+]]:edc = VLDB_3D_128 [[COPY]], [[REG_SEQUENCE]] :: (load (<4 x s32>))
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit [[VLDB_3D_128_]]
    %0:ptrregbank(p0) = COPY $p0
    %1:em(s20) = G_CONSTANT i20 1
    %2:edj(s20) = G_CONSTANT i20 2
    %3:edj(s20) = G_CONSTANT i20 3
    %4:edn(s20) = G_CONSTANT i20 4
    %5:edn(s20) = G_CONSTANT i20 5
    %6:edc(s20) = G_CONSTANT i20 6
    %7:edc(s20) = G_CONSTANT i20 7
    %8:vregbank(<4 x s32>), %9:ptrregbank(p0), %10:modregbank(s20), %11:modregbank(s20) = G_AIE_POSTINC_3D_LOAD %0, %1, %2, %3, %4, %6, %5, %7 :: (load (<4 x s32>))
    PseudoRET implicit $lr, implicit %8

...

---
name:            VEC128_AIE_OFFSET_LOAD
alignment:       16
legalized:       true
regBankSelected: true
body:             |
  bb.1.entry:
    liveins: $p0
    ; CHECK-LABEL: name: VEC128_AIE_OFFSET_LOAD
    ; CHECK: liveins: $p0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:ep = COPY $p0
    ; CHECK-NEXT: [[MOV_PD_imm11_pseudo:%[0-9]+]]:edj = MOV_PD_imm11_pseudo 512
    ; CHECK-NEXT: [[MOVXM_lng_cg:%[0-9]+]]:edj_as_32bit = MOVXM_lng_cg 1024
    ; CHECK-NEXT: [[LDA_dmv_lda_q_ag_idx_imm:%[0-9]+]]:vec128 = LDA_dmv_lda_q_ag_idx_imm [[COPY]], 32 :: (load (<4 x s32>))
    ; CHECK-NEXT: [[LDA_dmv_lda_q_ag_idx_imm1:%[0-9]+]]:vec128 = LDA_dmv_lda_q_ag_idx_imm [[COPY]], 496 :: (load (<4 x s32>))
    ; CHECK-NEXT: [[LDA_dmv_lda_q_ag_idx_imm2:%[0-9]+]]:vec128 = LDA_dmv_lda_q_ag_idx_imm [[COPY]], -512 :: (load (<4 x s32>))
    ; CHECK-NEXT: [[VLDB_128_ag_idx:%[0-9]+]]:mwa = VLDB_128_ag_idx [[COPY]], [[MOV_PD_imm11_pseudo]] :: (load (<4 x s32>))
    ; CHECK-NEXT: [[VLDB_128_ag_idx1:%[0-9]+]]:mwa = VLDB_128_ag_idx [[COPY]], [[MOVXM_lng_cg]] :: (load (<4 x s32>))
    ; CHECK-NEXT: PseudoRET implicit $lr, implicit [[LDA_dmv_lda_q_ag_idx_imm]], implicit [[LDA_dmv_lda_q_ag_idx_imm1]], implicit [[LDA_dmv_lda_q_ag_idx_imm2]], implicit [[VLDB_128_ag_idx]], implicit [[VLDB_128_ag_idx1]]
    %1:ptrregbank(p0) = COPY $p0
    %2:modregbank(s20) = G_CONSTANT i20 32
    %3:modregbank(s20) = G_CONSTANT i20 496
    %4:modregbank(s20) = G_CONSTANT i20 -512
    %5:modregbank(s20) = G_CONSTANT i20 512
    %6:modregbank(s20) = G_CONSTANT i20 1024
    %7:vregbank(<4 x s32>) = G_AIE_OFFSET_LOAD %1:ptrregbank(p0), %2:modregbank(s20) :: (load (<4 x s32>))
    %8:vregbank(<4 x s32>) = G_AIE_OFFSET_LOAD %1:ptrregbank(p0), %3:modregbank(s20) :: (load (<4 x s32>))
    %9:vregbank(<4 x s32>) = G_AIE_OFFSET_LOAD %1:ptrregbank(p0), %4:modregbank(s20) :: (load (<4 x s32>))
    %10:vregbank(<4 x s32>) = G_AIE_OFFSET_LOAD %1:ptrregbank(p0), %5:modregbank(s20) :: (load (<4 x s32>))
    %11:vregbank(<4 x s32>) = G_AIE_OFFSET_LOAD %1:ptrregbank(p0), %6:modregbank(s20) :: (load (<4 x s32>))
    PseudoRET implicit $lr, implicit %7, implicit %8, implicit %9, implicit %10, implicit %11
...
