; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

; 32-bit vector types

declare void @callee_v2bf16(<2 x bfloat>, <2 x bfloat>, <2 x bfloat>, <2 x bfloat>, <2 x bfloat>, <2 x bfloat>, <2 x bfloat>, <2 x bfloat>,
                             <2 x bfloat>)
define void @call_v2bf16() {
  ; CHECK-LABEL: name: call_v2bf16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_FCONSTANT bfloat 0xR0000
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<2 x s16>) = G_BUILD_VECTOR [[C]](s16), [[C]](s16)
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<2 x s16>), [[PTR_ADD]](p0) :: (store (<2 x s16>) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r1 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r2 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r3 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r4 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r5 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r6 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r7 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   PseudoJL @callee_v2bf16, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v2bf16(<2 x bfloat> zeroinitializer, <2 x bfloat> zeroinitializer, <2 x bfloat> zeroinitializer, <2 x bfloat> zeroinitializer, <2 x bfloat> zeroinitializer, <2 x bfloat> zeroinitializer, <2 x bfloat> zeroinitializer, <2 x bfloat> zeroinitializer,
                            <2 x bfloat> zeroinitializer)
  ret void
}

declare void @callee_v2int16(<2 x i16>, <2 x i16>, <2 x i16>, <2 x i16>, <2 x i16>, <2 x i16>, <2 x i16>, <2 x i16>,
                             <2 x i16>)
define void @call_v2int16() {
  ; CHECK-LABEL: name: call_v2int16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<2 x s16>) = G_BUILD_VECTOR [[C]](s16), [[C]](s16)
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<2 x s16>), [[PTR_ADD]](p0) :: (store (<2 x s16>) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r1 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r2 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r3 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r4 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r5 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r6 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r7 = COPY [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   PseudoJL @callee_v2int16, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v2int16(<2 x i16> zeroinitializer, <2 x i16> zeroinitializer, <2 x i16> zeroinitializer, <2 x i16> zeroinitializer, <2 x i16> zeroinitializer, <2 x i16> zeroinitializer, <2 x i16> zeroinitializer, <2 x i16> zeroinitializer,
                            <2 x i16> zeroinitializer)
  ret void
}

declare void @callee_v4int8(<4 x i8>, <4 x i8>, <4 x i8>, <4 x i8>, <4 x i8>, <4 x i8>, <4 x i8>, <4 x i8>,
                            <4 x i8>)
define void @call_v4int8() {
  ; CHECK-LABEL: name: call_v4int8
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s8) = G_CONSTANT i8 0
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<4 x s8>) = G_BUILD_VECTOR [[C]](s8), [[C]](s8), [[C]](s8), [[C]](s8)
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 -4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C1]](s32)
  ; CHECK-NEXT:   G_STORE [[BUILD_VECTOR]](<4 x s8>), [[PTR_ADD]](p0) :: (store (<4 x s8>) into stack - 4, basealign 32)
  ; CHECK-NEXT:   $r0 = COPY [[BUILD_VECTOR]](<4 x s8>)
  ; CHECK-NEXT:   $r1 = COPY [[BUILD_VECTOR]](<4 x s8>)
  ; CHECK-NEXT:   $r2 = COPY [[BUILD_VECTOR]](<4 x s8>)
  ; CHECK-NEXT:   $r3 = COPY [[BUILD_VECTOR]](<4 x s8>)
  ; CHECK-NEXT:   $r4 = COPY [[BUILD_VECTOR]](<4 x s8>)
  ; CHECK-NEXT:   $r5 = COPY [[BUILD_VECTOR]](<4 x s8>)
  ; CHECK-NEXT:   $r6 = COPY [[BUILD_VECTOR]](<4 x s8>)
  ; CHECK-NEXT:   $r7 = COPY [[BUILD_VECTOR]](<4 x s8>)
  ; CHECK-NEXT:   PseudoJL @callee_v4int8, csr_aie2, implicit-def $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5, implicit $r6, implicit $r7
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   PseudoRET implicit $lr
  call void @callee_v4int8(<4 x i8> zeroinitializer, <4 x i8> zeroinitializer, <4 x i8> zeroinitializer, <4 x i8> zeroinitializer, <4 x i8> zeroinitializer, <4 x i8> zeroinitializer, <4 x i8> zeroinitializer, <4 x i8> zeroinitializer,
                           <4 x i8> zeroinitializer)
  ret void
}
