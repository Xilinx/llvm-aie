; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s
%class.bfloat16 = type { bfloat }

define dso_local %class.bfloat16 @_Z13test_bfloat168bfloat16(%class.bfloat16 returned %arg.coerce)  {
  ; CHECK-LABEL: name: _Z13test_bfloat168bfloat16
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s16) = G_TRUNC [[COPY]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[TRUNC]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
entry:
  ret %class.bfloat16 %arg.coerce
}

define dso_local %class.bfloat16 @_Z13bfloat16_div28bfloat16f(%class.bfloat16 %arg.coerce, float noundef %f)  {
  ; CHECK-LABEL: name: _Z13bfloat16_div28bfloat16f
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s16) = G_TRUNC [[COPY]](s32)
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 16
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 32768
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 98303
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 65536
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s16) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[TRUNC]](s16)
  ; CHECK-NEXT:   [[SHL:%[0-9]+]]:_(s32) = nuw G_SHL [[ZEXT]], [[C]](s32)
  ; CHECK-NEXT:   [[FDIV:%[0-9]+]]:_(s32) = G_FDIV [[SHL]], [[COPY1]]
  ; CHECK-NEXT:   [[AND:%[0-9]+]]:_(s32) = G_AND [[FDIV]], [[C1]]
  ; CHECK-NEXT:   [[ICMP:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[AND]](s32), [[C2]]
  ; CHECK-NEXT:   [[AND1:%[0-9]+]]:_(s32) = G_AND [[FDIV]], [[C3]]
  ; CHECK-NEXT:   [[ICMP1:%[0-9]+]]:_(s1) = G_ICMP intpred(eq), [[AND1]](s32), [[C2]]
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s32) = G_ADD [[FDIV]], [[C4]]
  ; CHECK-NEXT:   [[OR:%[0-9]+]]:_(s1) = G_OR [[ICMP]], [[ICMP1]]
  ; CHECK-NEXT:   [[SELECT:%[0-9]+]]:_(s32) = G_SELECT [[OR]](s1), [[FDIV]], [[ADD]]
  ; CHECK-NEXT:   [[LSHR:%[0-9]+]]:_(s32) = G_LSHR [[SELECT]], [[C]](s32)
  ; CHECK-NEXT:   [[TRUNC1:%[0-9]+]]:_(s16) = G_TRUNC [[LSHR]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[TRUNC1]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
entry:
  %a.coerce.fca.0.extract.i = extractvalue %class.bfloat16 %arg.coerce, 0
  %0 = bitcast bfloat %a.coerce.fca.0.extract.i to i16
  %conv2.i.i = zext i16 %0 to i32
  %shl.i.i = shl nuw i32 %conv2.i.i, 16
  %1 = bitcast i32 %shl.i.i to float
  %div.i = fdiv float %1, %f
  %2 = bitcast float %div.i to i32
  %and.i.i = and i32 %2, 32768
  %cmp.not.i.i = icmp eq i32 %and.i.i, 0
  %3 = and i32 %2, 98303
  %brmerge.not.i.i = icmp eq i32 %3, 0
  %add.i.i = add i32 %2, 65536
  %4 = or i1 %cmp.not.i.i, %brmerge.not.i.i
  %I32.0.i.i = select i1 %4, i32 %2, i32 %add.i.i
  %shr.i.i = lshr i32 %I32.0.i.i, 16
  %conv.i.i = trunc i32 %shr.i.i to i16
  %5 = bitcast i16 %conv.i.i to bfloat
  %.fca.0.insert.i = insertvalue %class.bfloat16 poison, bfloat %5, 0
  ret %class.bfloat16 %.fca.0.insert.i
}

define dso_local noundef zeroext i1 @_Z12bfloat_cmp_g8bfloat16S_(%class.bfloat16 %arg0.coerce, %class.bfloat16 %arg1.coerce)  {
  ; CHECK-LABEL: name: _Z12bfloat_cmp_g8bfloat16S_
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s16) = G_TRUNC [[COPY]](s32)
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $r2
  ; CHECK-NEXT:   [[TRUNC1:%[0-9]+]]:_(s16) = G_TRUNC [[COPY1]](s32)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 16
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(s32) = G_ZEXT [[TRUNC1]](s16)
  ; CHECK-NEXT:   [[SHL:%[0-9]+]]:_(s32) = nuw G_SHL [[ZEXT]], [[C]](s32)
  ; CHECK-NEXT:   [[ZEXT1:%[0-9]+]]:_(s32) = G_ZEXT [[TRUNC]](s16)
  ; CHECK-NEXT:   [[SHL1:%[0-9]+]]:_(s32) = nuw G_SHL [[ZEXT1]], [[C]](s32)
  ; CHECK-NEXT:   [[FCMP:%[0-9]+]]:_(s1) = G_FCMP floatpred(olt), [[SHL]](s32), [[SHL1]]
  ; CHECK-NEXT:   [[ZEXT2:%[0-9]+]]:_(s32) = G_ZEXT [[FCMP]](s1)
  ; CHECK-NEXT:   $r0 = COPY [[ZEXT2]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
entry:
  %a.coerce.fca.0.extract.i = extractvalue %class.bfloat16 %arg0.coerce, 0
  %b.coerce.fca.0.extract.i = extractvalue %class.bfloat16 %arg1.coerce, 0
  %0 = bitcast bfloat %b.coerce.fca.0.extract.i to i16
  %conv2.i.i = zext i16 %0 to i32
  %shl.i.i = shl nuw i32 %conv2.i.i, 16
  %1 = bitcast i32 %shl.i.i to float
  %2 = bitcast bfloat %a.coerce.fca.0.extract.i to i16
  %conv2.i2.i = zext i16 %2 to i32
  %shl.i3.i = shl nuw i32 %conv2.i2.i, 16
  %3 = bitcast i32 %shl.i3.i to float
  %cmp.i = fcmp olt float %1, %3
  ret i1 %cmp.i
}

define dso_local %class.bfloat16 @_Z13test_ext_elemf(float noundef %x) {
  ; CHECK-LABEL: name: _Z13test_ext_elemf
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s16) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[INT:%[0-9]+]]:_(<8 x s64>) = G_INTRINSIC intrinsic(@llvm.aie2.v16accfloat)
  ; CHECK-NEXT:   [[INT1:%[0-9]+]]:_(<8 x s64>) = G_INTRINSIC intrinsic(@llvm.aie2.vinsert32.accfloat), [[INT]](<8 x s64>), [[C]](s32), [[COPY]](s32)
  ; CHECK-NEXT:   [[INT2:%[0-9]+]]:_(<16 x s16>) = G_INTRINSIC intrinsic(@llvm.aie2.v16accfloat.to.v16bf16), [[INT1]](<8 x s64>)
  ; CHECK-NEXT:   [[INT3:%[0-9]+]]:_(<16 x s16>) = G_INTRINSIC intrinsic(@llvm.aie2.v16bfloat16)
  ; CHECK-NEXT:   [[INT4:%[0-9]+]]:_(<32 x s16>) = G_INTRINSIC intrinsic(@llvm.aie2.concat.bf512.bf256), [[INT2]](<16 x s16>), [[INT3]](<16 x s16>)
  ; CHECK-NEXT:   [[INT5:%[0-9]+]]:_(s32) = G_INTRINSIC intrinsic(@llvm.aie2.vextract.elem16.I512), [[INT4]](<32 x s16>), [[C]](s32), [[C1]](s32)
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s16) = G_TRUNC [[INT5]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[TRUNC]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
entry:
  %0 = tail call <8 x i64> @llvm.aie2.v16accfloat()
  %1 = tail call <8 x i64> @llvm.aie2.vinsert32.accfloat(<8 x i64> %0, i32 0, float %x)
  %2 = tail call <16 x bfloat> @llvm.aie2.v16accfloat.to.v16bf16(<8 x i64> %1)
  %3 = tail call <16 x bfloat> @llvm.aie2.v16bfloat16()
  %4 = tail call <32 x bfloat> @llvm.aie2.concat.bf512.bf256(<16 x bfloat> %2, <16 x bfloat> %3)
  %5 = bitcast <32 x bfloat> %4 to <32 x i16>
  %6 = tail call i32 @llvm.aie2.vextract.elem16.I512(<32 x i16> %5, i32 0, i32 1)
  %elem.0.extract.trunc.i.i.i.i = trunc i32 %6 to i16
  %7 = bitcast i16 %elem.0.extract.trunc.i.i.i.i to bfloat
  %.fca.0.insert = insertvalue %class.bfloat16 poison, bfloat %7, 0
  ret %class.bfloat16 %.fca.0.insert
}

declare i32 @llvm.aie2.vextract.elem16.I512(<32 x i16>, i32, i32)
declare <8 x i64> @llvm.aie2.vinsert32.accfloat(<8 x i64>, i32, float)
declare <32 x bfloat> @llvm.aie2.concat.bf512.bf256(<16 x bfloat>, <16 x bfloat>)
declare <16 x bfloat> @llvm.aie2.v16accfloat.to.v16bf16(<8 x i64>)
declare <8 x i64> @llvm.aie2.v16accfloat()
declare <16 x bfloat> @llvm.aie2.v16bfloat16()
