; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

%class.bfloat16 = type { bfloat }
define dso_local %class.bfloat16 @_Z17test_get_bfloat168bfloat16(%class.bfloat16 returned %in.coerce) local_unnamed_addr #0 {
  ; CHECK-LABEL: name: _Z17test_get_bfloat168bfloat16
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $r1
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s16) = G_TRUNC [[COPY]](s32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[TRUNC]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
entry:
  ret %class.bfloat16 %in.coerce
}

define dso_local noundef <2 x bfloat> @_Z15test_v2bfloat16Dv2_u6__bf16(<2 x bfloat> noundef returned %b) local_unnamed_addr #0 {
  ; CHECK-LABEL: name: _Z15test_v2bfloat16Dv2_u6__bf16
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<2 x s16>) = COPY $r1
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.0.t
  ; CHECK-NEXT:   G_STORE [[COPY]](<2 x s16>), [[FRAME_INDEX]](p0) :: (volatile store (<2 x s16>) into %ir.t)
  ; CHECK-NEXT:   $r0 = COPY [[COPY]](<2 x s16>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0
entry:
  %t = alloca <2 x bfloat>, align 4
  store volatile <2 x bfloat> %b, ptr %t, align 4
  ret <2 x bfloat> %b
}

define dso_local noundef <4 x bfloat> @_Z15test_v4bfloat16Dv4_u6__bf16(<4 x bfloat> noundef returned %b) local_unnamed_addr #0 {
  ; CHECK-LABEL: name: _Z15test_v4bfloat16Dv4_u6__bf16
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $l1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<4 x s16>) = COPY $l1
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.0.t
  ; CHECK-NEXT:   G_STORE [[COPY]](<4 x s16>), [[FRAME_INDEX]](p0) :: (volatile store (<4 x s16>) into %ir.t)
  ; CHECK-NEXT:   $l0 = COPY [[COPY]](<4 x s16>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $l0
entry:
  %t = alloca <4 x bfloat>, align 8
  store volatile <4 x bfloat> %b, ptr %t, align 8
  ret <4 x bfloat> %b
}

define dso_local noundef <8 x bfloat> @_Z14ret_v8bfloat16Dv8_u6__bf16(<8 x bfloat> noundef %In) local_unnamed_addr #0 {
  ; CHECK-LABEL: name: _Z14ret_v8bfloat16Dv8_u6__bf16
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $wl2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<16 x s16>) = COPY $wl2
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(<8 x s16>), [[UV1:%[0-9]+]]:_(<8 x s16>) = G_UNMERGE_VALUES [[COPY]](<16 x s16>)
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.0.ret
  ; CHECK-NEXT:   G_STORE [[UV]](<8 x s16>), [[FRAME_INDEX]](p0) :: (volatile store (<8 x s16>) into %ir.ret)
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<8 x s16>) = G_LOAD [[FRAME_INDEX]](p0) :: (volatile dereferenceable load (<8 x s16>) from %ir.ret)
  ; CHECK-NEXT:   [[UV2:%[0-9]+]]:_(s16), [[UV3:%[0-9]+]]:_(s16), [[UV4:%[0-9]+]]:_(s16), [[UV5:%[0-9]+]]:_(s16), [[UV6:%[0-9]+]]:_(s16), [[UV7:%[0-9]+]]:_(s16), [[UV8:%[0-9]+]]:_(s16), [[UV9:%[0-9]+]]:_(s16) = G_UNMERGE_VALUES [[LOAD]](<8 x s16>)
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s16) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<16 x s16>) = G_BUILD_VECTOR [[UV2]](s16), [[UV3]](s16), [[UV4]](s16), [[UV5]](s16), [[UV6]](s16), [[UV7]](s16), [[UV8]](s16), [[UV9]](s16), [[DEF]](s16), [[DEF]](s16), [[DEF]](s16), [[DEF]](s16), [[DEF]](s16), [[DEF]](s16), [[DEF]](s16), [[DEF]](s16)
  ; CHECK-NEXT:   $wl0 = COPY [[BUILD_VECTOR]](<16 x s16>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $wl0
entry:
  %ret = alloca <8 x bfloat>, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %ret)
  store volatile <8 x bfloat> %In, ptr %ret, align 16
  %ret.0.ret.0.ret.0.ret.0. = load volatile <8 x bfloat>, ptr %ret, align 16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %ret)
  ret <8 x bfloat> %ret.0.ret.0.ret.0.ret.0.
}

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

define dso_local noundef <16 x bfloat> @_Z15ret_v16bfloat16Dv16_u6__bf16(<16 x bfloat> noundef %In) local_unnamed_addr #0 {
  ; CHECK-LABEL: name: _Z15ret_v16bfloat16Dv16_u6__bf16
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $wl2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<16 x s16>) = COPY $wl2
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.0.ret
  ; CHECK-NEXT:   G_STORE [[COPY]](<16 x s16>), [[FRAME_INDEX]](p0) :: (volatile store (<16 x s16>) into %ir.ret)
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<16 x s16>) = G_LOAD [[FRAME_INDEX]](p0) :: (volatile dereferenceable load (<16 x s16>) from %ir.ret)
  ; CHECK-NEXT:   $wl0 = COPY [[LOAD]](<16 x s16>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $wl0
entry:
  %ret = alloca <16 x bfloat>, align 32
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ret)
  store volatile <16 x bfloat> %In, ptr %ret, align 32
  %ret.0.ret.0.ret.0.ret.0. = load volatile <16 x bfloat>, ptr %ret, align 32
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ret)
  ret <16 x bfloat> %ret.0.ret.0.ret.0.ret.0.
}

define dso_local noundef <32 x bfloat> @_Z15ret_v32bfloat16Dv32_u6__bf16(<32 x bfloat> noundef %In) local_unnamed_addr #0 {
  ; CHECK-LABEL: name: _Z15ret_v32bfloat16Dv32_u6__bf16
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $x2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<32 x s16>) = COPY $x2
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.0.ret
  ; CHECK-NEXT:   G_STORE [[COPY]](<32 x s16>), [[FRAME_INDEX]](p0) :: (volatile store (<32 x s16>) into %ir.ret)
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<32 x s16>) = G_LOAD [[FRAME_INDEX]](p0) :: (volatile dereferenceable load (<32 x s16>) from %ir.ret)
  ; CHECK-NEXT:   $x0 = COPY [[LOAD]](<32 x s16>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $x0
entry:
  %ret = alloca <32 x bfloat>, align 64
  call void @llvm.lifetime.start.p0(i64 64, ptr nonnull %ret)
  store volatile <32 x bfloat> %In, ptr %ret, align 64
  %ret.0.ret.0.ret.0.ret.0. = load volatile <32 x bfloat>, ptr %ret, align 64
  call void @llvm.lifetime.end.p0(i64 64, ptr nonnull %ret)
  ret <32 x bfloat> %ret.0.ret.0.ret.0.ret.0.
}

define dso_local noundef <64 x bfloat> @_Z15ret_v64bfloat16Dv64_u6__bf16(<64 x bfloat> noundef %In) local_unnamed_addr #0 {
  ; CHECK-LABEL: name: _Z15ret_v64bfloat16Dv64_u6__bf16
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   liveins: $y3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<64 x s16>) = COPY $y3
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.0.ret
  ; CHECK-NEXT:   G_STORE [[COPY]](<64 x s16>), [[FRAME_INDEX]](p0) :: (volatile store (<64 x s16>) into %ir.ret)
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(<64 x s16>) = G_LOAD [[FRAME_INDEX]](p0) :: (volatile dereferenceable load (<64 x s16>) from %ir.ret)
  ; CHECK-NEXT:   $y2 = COPY [[LOAD]](<64 x s16>)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $y2
entry:
  %ret = alloca <64 x bfloat>, align 128
  call void @llvm.lifetime.start.p0(i64 128, ptr nonnull %ret)
  store volatile <64 x bfloat> %In, ptr %ret, align 128
  %ret.0.ret.0.ret.0.ret.0. = load volatile <64 x bfloat>, ptr %ret, align 128
  call void @llvm.lifetime.end.p0(i64 128, ptr nonnull %ret)
  ret <64 x bfloat> %ret.0.ret.0.ret.0.ret.0.
}
