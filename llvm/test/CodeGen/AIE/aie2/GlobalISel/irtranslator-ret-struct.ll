; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie2 -O0 -stop-after=irtranslator -global-isel -verify-machineinstrs %s -o - 2>&1 | FileCheck %s

; The clang front-end should already ensure return types larger than 16 bytes
; are returned indirectly.
; That means a [16 x i8] type still gets returned "directly", in registers+stack.
; TODO: Do we want to handle this?

%struct.S4I = type { i32, i32, i32, i32 }
%struct.S4S = type { i16, i16, i16, i16 }
%struct.SILI = type { i32, i64, i32 }
%struct.S4P = type { i32*, i32*, i32*, i32* }

define %struct.S4I @ret_S4I() {
  ; CHECK-LABEL: name: ret_S4I
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 2
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 4
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[C1]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[C2]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C3]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3
  ret %struct.S4I { i32 1, i32 2, i32 3, i32 4 }
}

define %struct.S4S @ret_S4S() {
  ; CHECK-LABEL: name: ret_S4S
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 1
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s16) = G_CONSTANT i16 2
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s16) = G_CONSTANT i16 3
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s16) = G_CONSTANT i16 4
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[C]](s16)
  ; CHECK-NEXT:   [[ANYEXT1:%[0-9]+]]:_(s32) = G_ANYEXT [[C1]](s16)
  ; CHECK-NEXT:   [[ANYEXT2:%[0-9]+]]:_(s32) = G_ANYEXT [[C2]](s16)
  ; CHECK-NEXT:   [[ANYEXT3:%[0-9]+]]:_(s32) = G_ANYEXT [[C3]](s16)
  ; CHECK-NEXT:   $r0 = COPY [[ANYEXT]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[ANYEXT1]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[ANYEXT2]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[ANYEXT3]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3
  ret %struct.S4S { i16 1, i16 2, i16 3, i16 4 }
}

define %struct.SILI @ret_SILI() {
  ; CHECK-LABEL: name: ret_SILI
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s64) = G_CONSTANT i64 2
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s32), [[UV1:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[C1]](s64)
  ; CHECK-NEXT:   $r0 = COPY [[C]](s32)
  ; CHECK-NEXT:   $r1 = COPY [[UV]](s32)
  ; CHECK-NEXT:   $r2 = COPY [[UV1]](s32)
  ; CHECK-NEXT:   $r3 = COPY [[C2]](s32)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $r0, implicit $r1, implicit $r2, implicit $r3
  ret %struct.SILI { i32 1, i64 2, i32 3 }
}

define %struct.S4P @ret_S4P() {
  ; CHECK-LABEL: name: ret_S4P
  ; CHECK: bb.1.entry:
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i20 0
  ; CHECK-NEXT:   $p0 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p1 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p2 = COPY [[C]](p0)
  ; CHECK-NEXT:   $p3 = COPY [[C]](p0)
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit $p0, implicit $p1, implicit $p2, implicit $p3
entry:
  ret %struct.S4P { i32* null, i32* null, i32* null, i32* null }
}
