; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2 -verify-machineinstrs --issue-limit=1 %s -o - | FileCheck %s

define <8 x i32> @test_extract_vector(<16 x i32> noundef %a, i32 noundef %idx) {
; CHECK-LABEL: test_extract_vector:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; jz r0, #.LBB0_2; nopv
; CHECK-NEXT:    nopa ; nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r8, r16 // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.end
; CHECK-NEXT:    mova r16, #8; nopb ; nopxm ; nops
; CHECK-NEXT:    vextract.s32 r0, x2, r16
; CHECK-NEXT:    mova r16, #9
; CHECK-NEXT:    vextract.s32 r1, x2, r16
; CHECK-NEXT:    mova r16, #10
; CHECK-NEXT:    vextract.s32 r2, x2, r16
; CHECK-NEXT:    mova r16, #11
; CHECK-NEXT:    vpush.hi.32 x0, x0, r0
; CHECK-NEXT:    vextract.s32 r3, x2, r16
; CHECK-NEXT:    mova r16, #12
; CHECK-NEXT:    vpush.hi.32 x0, x0, r1
; CHECK-NEXT:    vextract.s32 r4, x2, r16
; CHECK-NEXT:    mova r16, #13
; CHECK-NEXT:    vpush.hi.32 x0, x0, r2
; CHECK-NEXT:    vextract.s32 r5, x2, r16
; CHECK-NEXT:    mova r16, #14
; CHECK-NEXT:    vpush.hi.32 x0, x0, r3
; CHECK-NEXT:    vextract.s32 r6, x2, r16
; CHECK-NEXT:    mova r16, #15
; CHECK-NEXT:    j #.LBB0_3
; CHECK-NEXT:    vpush.hi.32 x0, x0, r4 // Delay Slot 5
; CHECK-NEXT:    vextract.s32 r7, x2, r16 // Delay Slot 4
; CHECK-NEXT:    vpush.hi.32 x0, x0, r5 // Delay Slot 3
; CHECK-NEXT:    vpush.hi.32 x0, x0, r6 // Delay Slot 2
; CHECK-NEXT:    vpush.hi.32 x0, x0, r7 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_2: // %if.then
; CHECK-NEXT:    mova r16, #0
; CHECK-NEXT:    vextract.s32 r0, x2, r16
; CHECK-NEXT:    mova r16, #1
; CHECK-NEXT:    vextract.s32 r1, x2, r16
; CHECK-NEXT:    mova r16, #2
; CHECK-NEXT:    vextract.s32 r2, x2, r16
; CHECK-NEXT:    mova r16, #3
; CHECK-NEXT:    vpush.hi.32 x0, x0, r0
; CHECK-NEXT:    vextract.s32 r3, x2, r16
; CHECK-NEXT:    mova r16, #4
; CHECK-NEXT:    vpush.hi.32 x0, x0, r1
; CHECK-NEXT:    vextract.s32 r4, x2, r16
; CHECK-NEXT:    mova r16, #5
; CHECK-NEXT:    vpush.hi.32 x0, x0, r2
; CHECK-NEXT:    vextract.s32 r5, x2, r16
; CHECK-NEXT:    mova r16, #6
; CHECK-NEXT:    vpush.hi.32 x0, x0, r3
; CHECK-NEXT:    vextract.s32 r6, x2, r16
; CHECK-NEXT:    mova r16, #7
; CHECK-NEXT:    vpush.hi.32 x0, x0, r4
; CHECK-NEXT:    vextract.s32 r7, x2, r16
; CHECK-NEXT:    vpush.hi.32 x0, x0, r5
; CHECK-NEXT:    vpush.hi.32 x0, x0, r6
; CHECK-NEXT:    vpush.hi.32 x0, x0, r7
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_3: // %return
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wl0, wh0 // Delay Slot 2
; CHECK-NEXT:    mov r16, r8 // Delay Slot 1
entry:
  %cmp = icmp eq i32 %idx, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:
  %shuffle = shufflevector <16 x i32> %a, <16 x i32> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  br label %return

if.end:
  %shuffle1 = shufflevector <16 x i32> %a, <16 x i32> poison, <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  br label %return

return:
  %retval.0 = phi <8 x i32> [ %shuffle, %if.then ], [ %shuffle1, %if.end ]
  ret <8 x i32> %retval.0
}

define <16 x i32> @test_insert_vector(<16 x i32> noundef %a, i32 noundef %idx, <8 x i32> noundef %b) {
; CHECK-LABEL: test_insert_vector:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; jz r0, #.LBB1_2; nopv
; CHECK-NEXT:    nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    mov r1, r16 // Delay Slot 2
; CHECK-NEXT:    mova r16, #0 // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.end
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    vextract.s32 r0, x2, r16 // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vpush.hi.32 x0, x0, r0 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB1_2: // %if.then
; CHECK-NEXT:    nopa ; nopx ; vextract.s32 r0, x4, r16
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    vpush.hi.32 x0, x0, r0 // Delay Slot 5
; CHECK-NEXT:    vextract.s32 r0, x0, r16 // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vpush.hi.32 x0, x0, r0 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %shuffle = shufflevector <8 x i32> %b, <8 x i32> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %cmp = icmp eq i32 %idx, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:
  %shuffle1 = shufflevector <16 x i32> %shuffle, <16 x i32> %a, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23>
  br label %cleanup

if.end:                                           ;
  %shuffle2 = shufflevector <16 x i32> %a, <16 x i32> %shuffle, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23>
  br label %cleanup

cleanup:
  %retval.0 = phi <16 x i32> [ %shuffle1, %if.then ], [ %shuffle2, %if.end ]
  ret <16 x i32> %retval.0
}

define <16 x i32> @test_concat_vector(<8 x i32> noundef %a, <8 x i32> noundef %b) {
; CHECK-LABEL: test_concat_vector:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopx ; mov r1, r16
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mova r16, #0 // Delay Slot 5
; CHECK-NEXT:    vextract.s32 r0, x2, r16 // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vpush.hi.32 x0, x0, r0 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %shuffle = shufflevector <8 x i32> %a, <8 x i32> %b, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  ret <16 x i32> %shuffle
}

define <16 x i32> @test_set_vector(i32 noundef %idx, <8 x i32> noundef %a) {
; CHECK-LABEL: test_set_vector:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; mov r2, r16; nopv
; CHECK-NEXT:    mova r16, #0
; CHECK-NEXT:    eqz r0, r0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    vextract.s32 r1, x2, r16 // Delay Slot 5
; CHECK-NEXT:    add r16, r0, #-1 // Delay Slot 4
; CHECK-NEXT:    vpush.hi.32 x0, x0, r1 // Delay Slot 3
; CHECK-NEXT:    vsel.32 x0, x0, x0, r16 // Delay Slot 2
; CHECK-NEXT:    mov r16, r2 // Delay Slot 1
entry:
  %cmp = icmp eq i32 %idx, 0
  %shuffle = shufflevector <8 x i32> %a, <8 x i32> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %shuffle1 = shufflevector <8 x i32> %a, <8 x i32> undef, <16 x i32> <i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  %retval.0 = select i1 %cmp, <16 x i32> %shuffle, <16 x i32> %shuffle1
  ret <16 x i32> %retval.0
}

define i32 @test_extract_elem(<8 x i32> noundef %a, i32 noundef %idx) {
; CHECK-LABEL: test_extract_elem:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r2, r16 // Delay Slot 5
; CHECK-NEXT:    mov r16, r1 // Delay Slot 4
; CHECK-NEXT:    vextract.s32 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r2 // Delay Slot 1
entry:
  %vecext = extractelement <8 x i32> %a, i32 %idx
  ret i32 %vecext
}
