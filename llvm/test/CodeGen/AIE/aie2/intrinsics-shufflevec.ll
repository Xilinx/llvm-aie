; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2 -verify-machineinstrs --issue-limit=1 %s -o - | FileCheck %s

define <8 x i32> @test_extract_vector(<16 x i32> noundef %a, i32 noundef %idx) {
; CHECK-LABEL: test_extract_vector:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; jz r0, #.LBB0_2; nopv
; CHECK-NEXT:    nopa ; nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov x0, x2 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.end
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov wl0, wh0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_2: // %return
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %cmp = icmp eq i32 %idx, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:
  %shuffle = shufflevector <16 x i32> %a, <16 x i32> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  br label %return

if.end:
  %shuffle1 = shufflevector <16 x i32> %a, <16 x i32> poison, <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  br label %return

return:
  %retval.0 = phi <8 x i32> [ %shuffle, %if.then ], [ %shuffle1, %if.end ]
  ret <8 x i32> %retval.0
}

define <16 x i32> @test_insert_vector(<16 x i32> noundef %a, i32 noundef %idx, <8 x i32> noundef %b) {
; CHECK-LABEL: test_insert_vector:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; jz r0, #.LBB1_2; nopv
; CHECK-NEXT:    nopa ; nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    vmov wl0, wl4 // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.end
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nopx // Delay Slot 5
; CHECK-NEXT:    vmov wh2, wl0 // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov x0, x2 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB1_2: // %if.then
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wh0, wl2 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %shuffle = shufflevector <8 x i32> %b, <8 x i32> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %cmp = icmp eq i32 %idx, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:
  %shuffle1 = shufflevector <16 x i32> %shuffle, <16 x i32> %a, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23>
  br label %cleanup

if.end:                                           ;
  %shuffle2 = shufflevector <16 x i32> %a, <16 x i32> %shuffle, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23>
  br label %cleanup

cleanup:
  %retval.0 = phi <16 x i32> [ %shuffle1, %if.then ], [ %shuffle2, %if.end ]
  ret <16 x i32> %retval.0
}

define <16 x i32> @test_concat_vector(<8 x i32> noundef %a, <8 x i32> noundef %b) {
; CHECK-LABEL: test_concat_vector:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vmov wl0, wl2 // Delay Slot 3
; CHECK-NEXT:    vmov wh0, wl4 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %shuffle = shufflevector <8 x i32> %a, <8 x i32> %b, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  ret <16 x i32> %shuffle
}

define <16 x i32> @test_set_vector(i32 noundef %idx, <8 x i32> noundef %a) {
; CHECK-LABEL: test_set_vector:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopx ; mov r1, r16
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    eqz r0, r0 // Delay Slot 5
; CHECK-NEXT:    vmov wh0, wl2 // Delay Slot 4
; CHECK-NEXT:    add r16, r0, #-1 // Delay Slot 3
; CHECK-NEXT:    vsel.32 x0, x2, x0, r16 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %cmp = icmp eq i32 %idx, 0
  %shuffle = shufflevector <8 x i32> %a, <8 x i32> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %shuffle1 = shufflevector <8 x i32> %a, <8 x i32> undef, <16 x i32> <i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  %retval.0 = select i1 %cmp, <16 x i32> %shuffle, <16 x i32> %shuffle1
  ret <16 x i32> %retval.0
}

define i32 @test_extract_elem(<8 x i32> noundef %a, i32 noundef %idx) {
; CHECK-LABEL: test_extract_elem:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    mov r2, r16 // Delay Slot 5
; CHECK-NEXT:    mov r16, r1 // Delay Slot 4
; CHECK-NEXT:    vextract.s32 r0, x0, r16 // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    mov r16, r2 // Delay Slot 1
entry:
  %vecext = extractelement <8 x i32> %a, i32 %idx
  ret i32 %vecext
}
