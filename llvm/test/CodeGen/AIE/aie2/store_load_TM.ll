; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2 %s -o - | FileCheck %s

define dso_local noundef i32 @_Z12test_read_tmj(i32 noundef %regAddr) local_unnamed_addr #0 {
; CHECK-LABEL: _Z12test_read_tmj:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    movxm r0, #524288
; CHECK-NEXT:    add r0, r1, r0
; CHECK-NEXT:    mov p0, r0
; CHECK-NEXT:    lda.tm r0, [p0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %add.i = add i32 %regAddr, 524288
  %conv.i = trunc i32 %add.i to i20
  %0 = inttoptr i20 %conv.i to ptr
  %1 = tail call i32 @llvm.aie2.read.tm(ptr %0)
  ret i32 %1
}

define dso_local void @_Z13test_write_tmjj(i32 noundef %regVal, i32 noundef %regAddr) local_unnamed_addr #1 {
; CHECK-LABEL: _Z13test_write_tmjj:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm
; CHECK-NEXT:    movxm r2, #524288 // Delay Slot 5
; CHECK-NEXT:    add r1, r1, r2 // Delay Slot 4
; CHECK-NEXT:    mov p0, r1 // Delay Slot 3
; CHECK-NEXT:    st.tm r0, [p0] // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %add.i = add i32 %regAddr, 524288
  %conv.i = trunc i32 %add.i to i20
  %0 = inttoptr i20 %conv.i to ptr
  tail call void @llvm.aie2.write.tm(i32 %regVal, ptr %0)
  ret void
}

define dso_local noundef i32 @_Z12test_read_tmjj(i32 noundef %regAddr, i32 noundef %TMAddrSpaceStart) local_unnamed_addr #0 {
; CHECK-LABEL: _Z12test_read_tmjj:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; add r0, r2, r1; nopm
; CHECK-NEXT:    mov p0, r0
; CHECK-NEXT:    lda.tm r0, [p0]
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %add.i = add i32 %TMAddrSpaceStart, %regAddr
  %conv.i = trunc i32 %add.i to i20
  %0 = inttoptr i20 %conv.i to ptr
  %1 = tail call i32 @llvm.aie2.read.tm(ptr %0)
  ret i32 %1
}

define dso_local void @_Z13test_write_tmjjj(i32 noundef %regVal, i32 noundef %regAddr, i32 noundef %TMAddrSpaceStart) local_unnamed_addr #1 {
; CHECK-LABEL: _Z13test_write_tmjjj:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    add r1, r2, r1 // Delay Slot 4
; CHECK-NEXT:    mov p0, r1 // Delay Slot 3
; CHECK-NEXT:    st.tm r0, [p0] // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %add.i = add i32 %TMAddrSpaceStart, %regAddr
  %conv.i = trunc i32 %add.i to i20
  %0 = inttoptr i20 %conv.i to ptr
  tail call void @llvm.aie2.write.tm(i32 %regVal, ptr %0)
  ret void
}

declare i32 @llvm.aie2.read.tm(ptr) #2
declare void @llvm.aie2.write.tm(i32, ptr) #3
