; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2 --issue-limit=1 %s -o - | FileCheck %s

define dso_local noundef <64 x i8> @_Z29test_set_v128uint_set_512_256iDv32_DU8_(i32 noundef %idx, <32 x i8> noundef %b) local_unnamed_addr #0 {
; CHECK-LABEL: _Z29test_set_v128uint_set_512_256iDv32_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nopxm
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB0_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wl0, wl2 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov wh0, wl0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_2: // %_ZL13set_v128uint4iDv32_DU8_.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  %1 = bitcast <32 x i8> %b to <8 x i32>
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %2 = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> %1, i32 0)
  br label %_ZL13set_v128uint4iDv32_DU8_.exit

if.else.i:
  %3 = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> %1, i32 1)
  br label %_ZL13set_v128uint4iDv32_DU8_.exit

_ZL13set_v128uint4iDv32_DU8_.exit:
  %retval.0.in.i = phi <16 x i32> [ %2, %if.then.i ], [ %3, %if.else.i ]
  %retval.0.i = bitcast <16 x i32> %retval.0.in.i to <64 x i8>
  ret <64 x i8> %retval.0.i
}


define dso_local noundef <64 x i8> @_Z29test_set_v128uint_set_512_256Dv32_DU8_(<32 x i8> noundef %b) local_unnamed_addr #0 {
; CHECK-LABEL: _Z29test_set_v128uint_set_512_256Dv32_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wl0, wl2 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <32 x i8> %b to <8 x i32>
  %1 = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> %0, i32 0)
  %retval.0.i = bitcast <16 x i32> %1 to <64 x i8>
  ret <64 x i8> %retval.0.i
}


define dso_local noundef <128 x i8> @_Z27test_set_v256uint4_1024_256iDv32_DU8_(i32 noundef %idx, <32 x i8> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z27test_set_v256uint4_1024_256iDv32_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #160; nopxm ; nops
; CHECK-NEXT:    vmov wh5, wl0
; CHECK-NEXT:    st lr, [sp, #-156] // 4-byte Folded Spill
; CHECK-NEXT:    jl #__modsi3
; CHECK-NEXT:    mova r2, #4 // Delay Slot 5
; CHECK-NEXT:    st r16, [sp, #-160] // 4-byte Folded Spill Delay Slot 4
; CHECK-NEXT:    vst wh5, [sp, #-32] // 32-byte Folded Spill Delay Slot 3
; CHECK-NEXT:    mov r1, r0 // Delay Slot 2
; CHECK-NEXT:    mova r16, #2 // Delay Slot 1
; CHECK-NEXT:    nopb ; nopa ; nops ; eq r1, r0, r16; nopm ; nopv
; CHECK-NEXT:    jnz r1, #.LBB2_5
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    mova r1, #1; nopb ; nopxm
; CHECK-NEXT:    eq r1, r0, r1
; CHECK-NEXT:    jnz r1, #.LBB2_4
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    nopa ; nopb ; jnz r0, #.LBB2_6; nops
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    vlda wl4, [sp, #-128] // 32-byte Folded Reload Delay Slot 4
; CHECK-NEXT:    vlda wh5, [sp, #-32] // 32-byte Folded Reload Delay Slot 3
; CHECK-NEXT:    vlda wh4, [sp, #-96] // 32-byte Folded Reload Delay Slot 2
; CHECK-NEXT:    vlda wl5, [sp, #-64] // 32-byte Folded Reload Delay Slot 1
; CHECK-NEXT:  // %bb.3: // %if.then.i
; CHECK-NEXT:    nopb ; nopa ; nops ; j #.LBB2_6; nopv
; CHECK-NEXT:    nopa ; nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    vmov wl4, wh5 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB2_4: // %if.then3.i
; CHECK-NEXT:    vlda wh5, [sp, #-32]; nopb ; nopx // 32-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    j #.LBB2_6
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vlda wl4, [sp, #-128] // 32-byte Folded Reload Delay Slot 3
; CHECK-NEXT:    vlda wl5, [sp, #-64] // 32-byte Folded Reload Delay Slot 2
; CHECK-NEXT:    vmov wh4, wh5 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB2_5: // %if.then7.i
; CHECK-NEXT:    vlda wh5, [sp, #-32]; nopb ; nopxm // 32-byte Folded Reload
; CHECK-NEXT:    vlda wl4, [sp, #-128] // 32-byte Folded Reload
; CHECK-NEXT:    vlda wh4, [sp, #-96] // 32-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov wl5, wh5
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB2_6: // %_ZL13set_v256uint4iDv32_DU8_.exit
; CHECK-NEXT:    nopb ; lda lr, [sp, #-156]; nops ; nopxm ; nopv // 4-byte Folded Reload
; CHECK-NEXT:    nopx
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r16, [sp, #-160] // 4-byte Folded Reload
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-160 // Delay Slot 1
entry:
  %rem.i = srem i32 %idx, 4
  switch i32 %rem.i, label %if.else.i [
    i32 0, label %if.then.i
    i32 1, label %if.then3.i
    i32 2, label %if.then7.i
  ]

if.then.i:
  %0 = bitcast <32 x i8> %b to <8 x i32>
  %1 = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> %0, i32 0)
  br label %_ZL13set_v256uint4iDv32_DU8_.exit

if.then3.i:
  %2 = bitcast <32 x i8> %b to <8 x i32>
  %3 = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> %2, i32 1)
  br label %_ZL13set_v256uint4iDv32_DU8_.exit

if.then7.i:
  %4 = bitcast <32 x i8> %b to <8 x i32>
  %5 = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> %4, i32 2)
  br label %_ZL13set_v256uint4iDv32_DU8_.exit

if.else.i:
  %6 = bitcast <32 x i8> %b to <8 x i32>
  %7 = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> %6, i32 3)
  br label %_ZL13set_v256uint4iDv32_DU8_.exit

_ZL13set_v256uint4iDv32_DU8_.exit:
  %retval.0.in.i = phi <32 x i32> [ %1, %if.then.i ], [ %3, %if.then3.i ], [ %5, %if.then7.i ], [ %7, %if.else.i ]
  %retval.0.i = bitcast <32 x i32> %retval.0.in.i to <128 x i8>
  ret <128 x i8> %retval.0.i
}


define dso_local noundef <128 x i8> @_Z27test_set_v256uint4_1024_256Dv32_DU8_(<32 x i8> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z27test_set_v256uint4_1024_256Dv32_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wh4, wl0 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <32 x i8> %b to <8 x i32>
  %1 = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> %0, i32 1)
  %retval.0.i = bitcast <32 x i32> %1 to <128 x i8>
  ret <128 x i8> %retval.0.i
}


define dso_local noundef <128 x i8> @_Z27test_set_v256uint4_1024_512iDv64_DU8_(i32 noundef %idx, <64 x i8> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z27test_set_v256uint4_1024_512iDv64_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nopxm
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB4_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov x4, x0 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov x5, x4; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB4_2: // %_ZL13set_v256uint4iDv64_DU8_.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  %1 = bitcast <64 x i8> %b to <16 x i32>
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %2 = tail call <32 x i32> @llvm.aie2.set.I1024.I512(<16 x i32> %1, i32 0)
  br label %_ZL13set_v256uint4iDv64_DU8_.exit

if.else.i:
  %3 = tail call <32 x i32> @llvm.aie2.set.I1024.I512(<16 x i32> %1, i32 1)
  br label %_ZL13set_v256uint4iDv64_DU8_.exit

_ZL13set_v256uint4iDv64_DU8_.exit:
  %retval.0.in.i = phi <32 x i32> [ %2, %if.then.i ], [ %3, %if.else.i ]
  %retval.0.i = bitcast <32 x i32> %retval.0.in.i to <128 x i8>
  ret <128 x i8> %retval.0.i
}


define dso_local noundef <128 x i8> @_Z27test_set_v256uint4_1024_512Dv64_DU8_(<64 x i8> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z27test_set_v256uint4_1024_512Dv64_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov x4, x0 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <64 x i8> %b to <16 x i32>
  %1 = tail call <32 x i32> @llvm.aie2.set.I1024.I512(<16 x i32> %0, i32 0)
  %retval.0.i = bitcast <32 x i32> %1 to <128 x i8>
  ret <128 x i8> %retval.0.i
}


define dso_local noundef <8 x i64> @_Z17test_set_v16acc32iDv8_u7__acc32(i32 noundef %idx, <4 x i64> noundef %b) local_unnamed_addr #0 {
; CHECK-LABEL: _Z17test_set_v16acc32iDv8_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nopxm
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB6_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amll0, amll1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov amlh0, amll0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB6_2: // %_ZL12set_v16acc32iDv8_u7__acc32.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %1 = tail call <8 x i64> @llvm.aie2.set.512.256.acc(<4 x i64> %b, i32 0)
  br label %_ZL12set_v16acc32iDv8_u7__acc32.exit

if.else.i:
  %2 = tail call <8 x i64> @llvm.aie2.set.512.256.acc(<4 x i64> %b, i32 1)
  br label %_ZL12set_v16acc32iDv8_u7__acc32.exit

_ZL12set_v16acc32iDv8_u7__acc32.exit:
  %retval.0.i = phi <8 x i64> [ %1, %if.then.i ], [ %2, %if.else.i ]
  ret <8 x i64> %retval.0.i
}


define dso_local noundef <8 x i64> @_Z17test_set_v16acc32Dv8_u7__acc32(<4 x i64> noundef %b) local_unnamed_addr #0 {
; CHECK-LABEL: _Z17test_set_v16acc32Dv8_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amlh0, amll1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <8 x i64> @llvm.aie2.set.512.256.acc(<4 x i64> %b, i32 1)
  ret <8 x i64> %0
}


define dso_local noundef <8 x i64> @_Z16test_set_v8acc64iDv4_u7__acc64(i32 noundef %idx, <4 x i64> noundef %b) local_unnamed_addr #0 {
; CHECK-LABEL: _Z16test_set_v8acc64iDv4_u7__acc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nopxm
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB8_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amll0, amll1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov amlh0, amll0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB8_2: // %_ZL11set_v8acc64iDv4_u7__acc64.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %1 = tail call <8 x i64> @llvm.aie2.set.512.256.acc(<4 x i64> %b, i32 0)
  br label %_ZL11set_v8acc64iDv4_u7__acc64.exit

if.else.i:
  %2 = tail call <8 x i64> @llvm.aie2.set.512.256.acc(<4 x i64> %b, i32 1)
  br label %_ZL11set_v8acc64iDv4_u7__acc64.exit

_ZL11set_v8acc64iDv4_u7__acc64.exit:
  %retval.0.i = phi <8 x i64> [ %1, %if.then.i ], [ %2, %if.else.i ]
  ret <8 x i64> %retval.0.i
}


define dso_local noundef <8 x i64> @_Z16test_set_v8acc64Dv4_u7__acc64(<4 x i64> noundef %b) local_unnamed_addr #0 {
; CHECK-LABEL: _Z16test_set_v8acc64Dv4_u7__acc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amll0, amll1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <8 x i64> @llvm.aie2.set.512.256.acc(<4 x i64> %b, i32 0)
  ret <8 x i64> %0
}


define dso_local noundef <16 x i64> @_Z17test_set_v32acc32iDv8_u7__acc32(i32 noundef %idx, <4 x i64> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z17test_set_v32acc32iDv8_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #160; nopxm ; nops
; CHECK-NEXT:    vmov amhl0, amll1
; CHECK-NEXT:    st lr, [sp, #-156] // 4-byte Folded Spill
; CHECK-NEXT:    jl #__modsi3
; CHECK-NEXT:    mova r2, #4 // Delay Slot 5
; CHECK-NEXT:    st r16, [sp, #-160] // 4-byte Folded Spill Delay Slot 4
; CHECK-NEXT:    vst amhl0, [sp, #-64] // 32-byte Folded Spill Delay Slot 3
; CHECK-NEXT:    mov r1, r0 // Delay Slot 2
; CHECK-NEXT:    mova r16, #2 // Delay Slot 1
; CHECK-NEXT:    nopb ; nopa ; nops ; eq r1, r0, r16; nopm ; nopv
; CHECK-NEXT:    jnz r1, #.LBB10_5
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    mova r1, #1; nopb ; nopxm
; CHECK-NEXT:    eq r1, r0, r1
; CHECK-NEXT:    jnz r1, #.LBB10_4
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    nopb ; vlda amhl0, [sp, #-64]; nops ; nopxm ; nopv // 32-byte Folded Reload
; CHECK-NEXT:    jnz r0, #.LBB10_6
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.3: // %if.then.i
; CHECK-NEXT:    nopb ; nopa ; nops ; j #.LBB10_7; nopv
; CHECK-NEXT:    nopa ; nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    vmov amll0, amhl0 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB10_4: // %if.then3.i
; CHECK-NEXT:    vlda amhl0, [sp, #-64]; nopb ; nopx // 32-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    j #.LBB10_7
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vlda amll0, [sp, #-128] // 32-byte Folded Reload Delay Slot 3
; CHECK-NEXT:    vlda amhh0, [sp, #-32] // 32-byte Folded Reload Delay Slot 2
; CHECK-NEXT:    vmov amlh0, amhl0 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB10_5: // %if.then7.i
; CHECK-NEXT:    nopa ; nopb ; j #.LBB10_7; nops
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    vlda amll0, [sp, #-128] // 32-byte Folded Reload Delay Slot 4
; CHECK-NEXT:    vlda amlh0, [sp, #-96] // 32-byte Folded Reload Delay Slot 3
; CHECK-NEXT:    vlda amhl0, [sp, #-64] // 32-byte Folded Reload Delay Slot 2
; CHECK-NEXT:    vlda amhh0, [sp, #-32] // 32-byte Folded Reload Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB10_6: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov amhh0, amhl0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB10_7: // %_ZL12set_v32acc32iDv8_u7__acc32.exit
; CHECK-NEXT:    nopb ; lda lr, [sp, #-156]; nops ; nopxm ; nopv // 4-byte Folded Reload
; CHECK-NEXT:    nopx
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r16, [sp, #-160] // 4-byte Folded Reload
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-160 // Delay Slot 1
entry:
  %rem.i = srem i32 %idx, 4
  switch i32 %rem.i, label %if.else.i [
    i32 0, label %if.then.i
    i32 1, label %if.then3.i
    i32 2, label %if.then7.i
  ]

if.then.i:
  %0 = tail call <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64> %b, i32 0)
  br label %_ZL12set_v32acc32iDv8_u7__acc32.exit

if.then3.i:
  %1 = tail call <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64> %b, i32 1)
  br label %_ZL12set_v32acc32iDv8_u7__acc32.exit

if.then7.i:
  %2 = tail call <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64> %b, i32 2)
  br label %_ZL12set_v32acc32iDv8_u7__acc32.exit

if.else.i:
  %3 = tail call <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64> %b, i32 3)
  br label %_ZL12set_v32acc32iDv8_u7__acc32.exit

_ZL12set_v32acc32iDv8_u7__acc32.exit:
  %retval.0.i = phi <16 x i64> [ %0, %if.then.i ], [ %1, %if.then3.i ], [ %2, %if.then7.i ], [ %3, %if.else.i ]
  ret <16 x i64> %retval.0.i
}


define dso_local noundef <16 x i64> @_Z17test_set_v32acc32Dv8_u7__acc32(<4 x i64> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z17test_set_v32acc32Dv8_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amlh0, amll1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64> %b, i32 1)
  ret <16 x i64> %0
}


define dso_local noundef <16 x i64> @_Z17test_set_v32acc32iDv16_u7__acc32(i32 noundef %idx, <8 x i64> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z17test_set_v32acc32iDv16_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nopxm
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB12_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov bml0, bml1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov bmh0, bml0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB12_2: // %_ZL12set_v32acc32iDv16_u7__acc32.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %1 = tail call <16 x i64> @llvm.aie2.set.1024.512.acc(<8 x i64> %b, i32 0)
  br label %_ZL12set_v32acc32iDv16_u7__acc32.exit

if.else.i:
  %2 = tail call <16 x i64> @llvm.aie2.set.1024.512.acc(<8 x i64> %b, i32 1)
  br label %_ZL12set_v32acc32iDv16_u7__acc32.exit

_ZL12set_v32acc32iDv16_u7__acc32.exit:
  %retval.0.i = phi <16 x i64> [ %1, %if.then.i ], [ %2, %if.else.i ]
  ret <16 x i64> %retval.0.i
}


define dso_local noundef <16 x i64> @_Z17test_set_v32acc32Dv16_u7__acc32(<8 x i64> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z17test_set_v32acc32Dv16_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov bml0, bml1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <16 x i64> @llvm.aie2.set.1024.512.acc(<8 x i64> %b, i32 0)
  ret <16 x i64> %0
}


define dso_local noundef <16 x i64> @_Z17test_set_v16acc64iDv4_u7__acc64(i32 noundef %idx, <4 x i64> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z17test_set_v16acc64iDv4_u7__acc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #160; nopxm ; nops
; CHECK-NEXT:    vmov amhl0, amll1
; CHECK-NEXT:    st lr, [sp, #-156] // 4-byte Folded Spill
; CHECK-NEXT:    jl #__modsi3
; CHECK-NEXT:    mova r2, #4 // Delay Slot 5
; CHECK-NEXT:    st r16, [sp, #-160] // 4-byte Folded Spill Delay Slot 4
; CHECK-NEXT:    vst amhl0, [sp, #-64] // 32-byte Folded Spill Delay Slot 3
; CHECK-NEXT:    mov r1, r0 // Delay Slot 2
; CHECK-NEXT:    mova r16, #2 // Delay Slot 1
; CHECK-NEXT:    nopb ; nopa ; nops ; eq r1, r0, r16; nopm ; nopv
; CHECK-NEXT:    jnz r1, #.LBB14_5
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    mova r1, #1; nopb ; nopxm
; CHECK-NEXT:    eq r1, r0, r1
; CHECK-NEXT:    jnz r1, #.LBB14_4
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    nopb ; vlda amhl0, [sp, #-64]; nops ; nopxm ; nopv // 32-byte Folded Reload
; CHECK-NEXT:    jnz r0, #.LBB14_6
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.3: // %if.then.i
; CHECK-NEXT:    nopb ; nopa ; nops ; j #.LBB14_7; nopv
; CHECK-NEXT:    nopa ; nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    vmov amll0, amhl0 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB14_4: // %if.then3.i
; CHECK-NEXT:    vlda amhl0, [sp, #-64]; nopb ; nopx // 32-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    j #.LBB14_7
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vlda amll0, [sp, #-128] // 32-byte Folded Reload Delay Slot 3
; CHECK-NEXT:    vlda amhh0, [sp, #-32] // 32-byte Folded Reload Delay Slot 2
; CHECK-NEXT:    vmov amlh0, amhl0 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB14_5: // %if.then7.i
; CHECK-NEXT:    nopa ; nopb ; j #.LBB14_7; nops
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    vlda amll0, [sp, #-128] // 32-byte Folded Reload Delay Slot 4
; CHECK-NEXT:    vlda amlh0, [sp, #-96] // 32-byte Folded Reload Delay Slot 3
; CHECK-NEXT:    vlda amhl0, [sp, #-64] // 32-byte Folded Reload Delay Slot 2
; CHECK-NEXT:    vlda amhh0, [sp, #-32] // 32-byte Folded Reload Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB14_6: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov amhh0, amhl0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB14_7: // %_ZL12set_v16acc64iDv4_u7__acc64.exit
; CHECK-NEXT:    nopb ; lda lr, [sp, #-156]; nops ; nopxm ; nopv // 4-byte Folded Reload
; CHECK-NEXT:    nopx
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r16, [sp, #-160] // 4-byte Folded Reload
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-160 // Delay Slot 1
entry:
  %rem.i = srem i32 %idx, 4
  switch i32 %rem.i, label %if.else.i [
    i32 0, label %if.then.i
    i32 1, label %if.then3.i
    i32 2, label %if.then7.i
  ]

if.then.i:
  %0 = tail call <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64> %b, i32 0)
  br label %_ZL12set_v16acc64iDv4_u7__acc64.exit

if.then3.i:
  %1 = tail call <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64> %b, i32 1)
  br label %_ZL12set_v16acc64iDv4_u7__acc64.exit

if.then7.i:
  %2 = tail call <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64> %b, i32 2)
  br label %_ZL12set_v16acc64iDv4_u7__acc64.exit

if.else.i:
  %3 = tail call <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64> %b, i32 3)
  br label %_ZL12set_v16acc64iDv4_u7__acc64.exit

_ZL12set_v16acc64iDv4_u7__acc64.exit:
  %retval.0.i = phi <16 x i64> [ %0, %if.then.i ], [ %1, %if.then3.i ], [ %2, %if.then7.i ], [ %3, %if.else.i ]
  ret <16 x i64> %retval.0.i
}


define dso_local noundef <16 x i64> @_Z17test_set_v16acc64Dv4_u7__acc64(<4 x i64> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z17test_set_v16acc64Dv4_u7__acc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amlh0, amll1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64> %b, i32 1)
  ret <16 x i64> %0
}


define dso_local noundef <16 x i64> @_Z17test_set_v16acc64iDv8_u7__acc64(i32 noundef %idx, <8 x i64> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z17test_set_v16acc64iDv8_u7__acc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nopxm
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB16_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov bml0, bml1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov bmh0, bml0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB16_2: // %_ZL12set_v16acc64iDv8_u7__acc64.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %1 = tail call <16 x i64> @llvm.aie2.set.1024.512.acc(<8 x i64> %b, i32 0)
  br label %_ZL12set_v16acc64iDv8_u7__acc64.exit

if.else.i:
  %2 = tail call <16 x i64> @llvm.aie2.set.1024.512.acc(<8 x i64> %b, i32 1)
  br label %_ZL12set_v16acc64iDv8_u7__acc64.exit

_ZL12set_v16acc64iDv8_u7__acc64.exit:
  %retval.0.i = phi <16 x i64> [ %1, %if.then.i ], [ %2, %if.else.i ]
  ret <16 x i64> %retval.0.i
}


define dso_local noundef <16 x i64> @_Z17test_set_v16acc64Dv8_u7__acc64(<8 x i64> noundef %b) local_unnamed_addr #1 {
; CHECK-LABEL: _Z17test_set_v16acc64Dv8_u7__acc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov bml0, bml1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <16 x i64> @llvm.aie2.set.1024.512.acc(<8 x i64> %b, i32 0)
  ret <16 x i64> %0
}


declare <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32>, i32) #2
declare <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32>, i32) #2
declare <32 x i32> @llvm.aie2.set.I1024.I512(<16 x i32>, i32) #2
declare <8 x i64> @llvm.aie2.set.512.256.acc(<4 x i64>, i32) #2
declare <16 x i64> @llvm.aie2.set.1024.256.acc(<4 x i64>, i32) #2
declare <16 x i64> @llvm.aie2.set.1024.512.acc(<8 x i64>, i32) #2
