; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2 --issue-limit=1 %s -o - | FileCheck %s

define  <8 x i32> @test_extract_v4int32(i32 noundef %idx, <16 x i32> noundef %a)  {
; CHECK-LABEL: test_extract_v4int32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    mova r1, #4 // Delay Slot 4
; CHECK-NEXT:    lshl r0, r0, r1 // Delay Slot 3
; CHECK-NEXT:    vshift x0, x2, x0, r0 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <16 x i32> @llvm.aie2.v16int32()
  %mul.i = shl nsw i32 %idx, 4
  %1 = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> %a, <16 x i32> %0, i32 0, i32 %mul.i)
  %2 = tail call <4 x i32> @llvm.aie2.extract.I128.I512(<16 x i32> %1)
  %3 = tail call <8 x i32> @llvm.aie2.get.I256.I128(<4 x i32> %2)
  ret <8 x i32> %3
}

define  <32 x i16> @test_set_v32int16(i32 noundef %idx, ptr nocapture readonly %a)  {
; CHECK-LABEL: test_set_v32int16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    vlda.128 wl0, [p0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    mova r1, #4
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mova r2, #64 // Delay Slot 5
; CHECK-NEXT:    lshl r0, r0, r1 // Delay Slot 4
; CHECK-NEXT:    sub r0, r2, r0 // Delay Slot 3
; CHECK-NEXT:    vshift x0, x0, x0, r0 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = load <4 x i32>, ptr %a, align 16
  %1 = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> %0)
  %2 = tail call <32 x i16> @llvm.aie2.v32int16()
  %3 = bitcast <32 x i16> %2 to <16 x i32>
  %4 = shl i32 %idx, 4
  %mul.i = sub i32 64, %4
  %5 = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> %3, <16 x i32> %1, i32 0, i32 %mul.i)
  %retval.0.i = bitcast <16 x i32> %5 to <32 x i16>
  ret <32 x i16> %retval.0.i
}

define <64 x i8> @insert_128_in_512(<64 x i8> noundef %v, i32 noundef %idx, <16 x i8> noundef %b) {
; CHECK-LABEL: insert_128_in_512:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; mov r5, r16; nopv
; CHECK-NEXT:    mova r1, #4
; CHECK-NEXT:    mova r2, #64
; CHECK-NEXT:    mova r3, #2
; CHECK-NEXT:    mova r4, #15
; CHECK-NEXT:    lshl r1, r0, r1
; CHECK-NEXT:    lshl r0, r0, r3
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    sub r1, r2, r1 // Delay Slot 5
; CHECK-NEXT:    lshl r16, r4, r0 // Delay Slot 4
; CHECK-NEXT:    vshift x0, x0, x4, r1 // Delay Slot 3
; CHECK-NEXT:    vsel.32 x0, x2, x0, r16 // Delay Slot 2
; CHECK-NEXT:    mov r16, r5 // Delay Slot 1
entry:
  %0 = bitcast <16 x i8> %b to <4 x i32>
  %1 = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> %0)
  %2 = tail call <16 x i32> @llvm.aie2.v16int32()
  %3 = shl i32 %idx, 4
  %mul.i.i = sub i32 64, %3
  %4 = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> %2, <16 x i32> %1, i32 0, i32 %mul.i.i)
  %mul.i = shl i32 %idx, 2
  %shl.i = shl i32 15, %mul.i
  %5 = bitcast <64 x i8> %v to <16 x i32>
  %6 = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> %5, <16 x i32> %4, i32 %shl.i)
  %7 = bitcast <16 x i32> %6 to <64 x i8>
  ret <64 x i8> %7
}

define dso_local noundef <32 x i8> @insert_128_in_256(<32 x i8> noundef %v, i32 noundef %idx, <16 x i8> noundef %b) {
; CHECK-LABEL: insert_128_in_256:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; mov r5, r16; nopv
; CHECK-NEXT:    mova r1, #4
; CHECK-NEXT:    mova r2, #64
; CHECK-NEXT:    mova r3, #2
; CHECK-NEXT:    mova r4, #15
; CHECK-NEXT:    lshl r1, r0, r1
; CHECK-NEXT:    lshl r0, r0, r3
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    sub r1, r2, r1 // Delay Slot 5
; CHECK-NEXT:    lshl r16, r4, r0 // Delay Slot 4
; CHECK-NEXT:    vshift x0, x0, x4, r1 // Delay Slot 3
; CHECK-NEXT:    vsel.32 x0, x2, x0, r16 // Delay Slot 2
; CHECK-NEXT:    mov r16, r5 // Delay Slot 1
entry:
  %0 = bitcast <32 x i8> %v to <8 x i32>
  %1 = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> %0, i32 0)
  %2 = bitcast <16 x i8> %b to <4 x i32>
  %3 = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> %2)
  %4 = tail call <16 x i32> @llvm.aie2.v16int32()
  %5 = shl i32 %idx, 4
  %mul.i.i.i = sub i32 64, %5
  %6 = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> %4, <16 x i32> %3, i32 0, i32 %mul.i.i.i)
  %mul.i.i = shl i32 %idx, 2
  %shl.i.i = shl i32 15, %mul.i.i
  %7 = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> %1, <16 x i32> %6, i32 %shl.i.i)
  %8 = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> %7, i32 0)
  %retval.0.i7.i = bitcast <8 x i32> %8 to <32 x i8>
  ret <32 x i8> %retval.0.i7.i
}

define <64 x i8> @test_concat_4_v32uint4(<16 x i8> noundef %v0, <16 x i8> noundef %v1, <16 x i8> noundef %v2, <16 x i8> noundef %v3) {
; CHECK-LABEL: test_concat_4_v32uint4:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov r3, r16
; CHECK-NEXT:    mov r4, r17
; CHECK-NEXT:    mov r5, r18
; CHECK-NEXT:    mova r0, #48
; CHECK-NEXT:    mova r1, #32
; CHECK-NEXT:    movxm r16, #3840
; CHECK-NEXT:    mova r2, #16
; CHECK-NEXT:    movxm r17, #61440
; CHECK-NEXT:    mova r18, #15
; CHECK-NEXT:    vshift x0, x0, x4, r0
; CHECK-NEXT:    vshift x4, x0, x6, r1
; CHECK-NEXT:    vsel.32 x0, x0, x4, r16
; CHECK-NEXT:    mov r16, r3
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    vshift x4, x0, x8, r2 // Delay Slot 5
; CHECK-NEXT:    vsel.32 x0, x0, x4, r17 // Delay Slot 4
; CHECK-NEXT:    mov r17, r4 // Delay Slot 3
; CHECK-NEXT:    vsel.32 x0, x0, x2, r18 // Delay Slot 2
; CHECK-NEXT:    mov r18, r5 // Delay Slot 1
entry:
  %0 = bitcast <16 x i8> %v1 to <4 x i32>
  %1 = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> %0)
  %2 = tail call <16 x i32> @llvm.aie2.v16int32()
  %3 = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> %2, <16 x i32> %1, i32 0, i32 48)
  %4 = bitcast <16 x i8> %v2 to <4 x i32>
  %5 = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> %4)
  %6 = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> %2, <16 x i32> %5, i32 0, i32 32)
  %7 = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> %3, <16 x i32> %6, i32 3840)
  %8 = bitcast <16 x i8> %v3 to <4 x i32>
  %9 = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> %8)
  %10 = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> %2, <16 x i32> %9, i32 0, i32 16)
  %11 = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> %7, <16 x i32> %10, i32 61440)
  %12 = bitcast <16 x i8> %v0 to <4 x i32>
  %13 = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> %12)
  %14 = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> %11, <16 x i32> %13, i32 15)
  %15 = bitcast <16 x i32> %14 to <64 x i8>
  ret <64 x i8> %15
}

define <32 x i8> @test_concat_2_v32uint4(<16 x i8> noundef %v0, <16 x i8> noundef %v1) {
; CHECK-LABEL: test_concat_2_v32uint4:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopx ; mov r1, r16
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mova r0, #48 // Delay Slot 5
; CHECK-NEXT:    mova r16, #15 // Delay Slot 4
; CHECK-NEXT:    vshift x0, x0, x4, r0 // Delay Slot 3
; CHECK-NEXT:    vsel.32 x0, x0, x2, r16 // Delay Slot 2
; CHECK-NEXT:    mov r16, r1 // Delay Slot 1
entry:
  %0 = bitcast <16 x i8> %v1 to <4 x i32>
  %1 = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> %0)
  %2 = tail call <16 x i32> @llvm.aie2.v16int32()
  %3 = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> %2, <16 x i32> %1, i32 0, i32 48)
  %4 = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> %3, i32 0)
  %5 = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> %4, i32 0)
  %6 = bitcast <16 x i8> %v0 to <4 x i32>
  %7 = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> %6)
  %8 = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> %5, <16 x i32> %7, i32 15)
  %9 = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> %8, i32 0)
  %retval.0.i7.i.i = bitcast <8 x i32> %9 to <32 x i8>
  ret <32 x i8> %retval.0.i7.i.i
}

declare <8 x i32> @llvm.aie2.get.I256.I128(<4 x i32>)

declare <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32>)

declare <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32>, i32)

declare <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32>, <16 x i32>, i32, i32)

declare <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32>, i32)

declare <16 x i32> @llvm.aie2.v16int32()

declare <4 x i32> @llvm.aie2.extract.I128.I512(<16 x i32>)

declare <32 x i16> @llvm.aie2.v32int16()

declare <8 x i16> @llvm.aie2.v8int16()

declare <16 x i32> @llvm.aie2.vsel32(<16 x i32>, <16 x i32>, i32)

declare <16 x i8> @llvm.aie2.v16int8()

declare <64 x i8> @llvm.aie2.v64int8()
