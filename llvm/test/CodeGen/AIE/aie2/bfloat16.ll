; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2 --issue-limit=1 %s -o - | FileCheck %s

define dso_local noundef <32 x bfloat> @band_v32bf16(<32 x bfloat> noundef %a, <32 x bfloat> noundef %b)  {
; CHECK-LABEL: band_v32bf16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vband x0, x4, x2 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <32 x bfloat> %a to <32 x i16>
  %1 = bitcast <32 x bfloat> %b to <32 x i16>
  %and.i.i = and <32 x i16> %1, %0
  %2 = bitcast <32 x i16> %and.i.i to <32 x bfloat>
  ret <32 x bfloat> %2
}


define dso_local noundef <32 x bfloat> @bor_v32bf16(<32 x bfloat> noundef %a, <32 x bfloat> noundef %b)  {
; CHECK-LABEL: bor_v32bf16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vbor x0, x4, x2 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <32 x bfloat> %a to <32 x i16>
  %1 = bitcast <32 x bfloat> %b to <32 x i16>
  %or.i.i = or <32 x i16> %1, %0
  %2 = bitcast <32 x i16> %or.i.i to <32 x bfloat>
  ret <32 x bfloat> %2
}


define dso_local noundef <32 x bfloat> @bxor_v32bf16(<32 x bfloat> noundef %a, <32 x bfloat> noundef %b)  {
; CHECK-LABEL: bxor_v32bf16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov r0, r16
; CHECK-NEXT:    vbneg_ltz.s16 x0, r16, x4
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    vband x0, x0, x2 // Delay Slot 5
; CHECK-NEXT:    vbneg_ltz.s16 x2, r16, x2 // Delay Slot 4
; CHECK-NEXT:    vband x2, x2, x4 // Delay Slot 3
; CHECK-NEXT:    vbor x0, x2, x0 // Delay Slot 2
; CHECK-NEXT:    mov r16, r0 // Delay Slot 1
entry:
  %0 = bitcast <32 x bfloat> %a to <32 x i16>
  %1 = bitcast <32 x bfloat> %b to <32 x i16>
  %2 = tail call { <32 x i16>, i32 } @llvm.aie2.vbneg.ltz16(<32 x i16> %1)
  %3 = extractvalue { <32 x i16>, i32 } %2, 0
  %and.i.i.i = and <32 x i16> %3, %0
  %4 = tail call { <32 x i16>, i32 } @llvm.aie2.vbneg.ltz16(<32 x i16> %0)
  %5 = extractvalue { <32 x i16>, i32 } %4, 0
  %and.i7.i.i = and <32 x i16> %5, %1
  %or.i.i.i = or <32 x i16> %and.i7.i.i, %and.i.i.i
  %6 = bitcast <32 x i16> %or.i.i.i to <32 x bfloat>
  ret <32 x bfloat> %6
}


define dso_local noundef <32 x bfloat> @bneg_v32bf16(<32 x bfloat> noundef %a)  {
; CHECK-LABEL: bneg_v32bf16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vbneg_ltz.s16 x0, r16, x2 // Delay Slot 3
; CHECK-NEXT:    or r0, r16, r16 // Delay Slot 2
; CHECK-NEXT:    mov r16, r0 // Delay Slot 1
entry:
  %0 = bitcast <32 x bfloat> %a to <32 x i16>
  %1 = tail call { <32 x i16>, i32 } @llvm.aie2.vbneg.ltz16(<32 x i16> %0)
  %2 = extractvalue { <32 x i16>, i32 } %1, 0
  %3 = bitcast <32 x i16> %2 to <32 x bfloat>
  ret <32 x bfloat> %3
}


define dso_local noundef <32 x bfloat> @abs_v32bf16(<32 x bfloat> noundef %a)  {
; CHECK-LABEL: abs_v32bf16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    movxm r0, #32767 // Delay Slot 4
; CHECK-NEXT:    vbcst.16 x0, r0 // Delay Slot 3
; CHECK-NEXT:    vband x0, x0, x2 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <32 x i16> @llvm.aie2.vbroadcast16.I512(i32 32767)
  %1 = bitcast <32 x bfloat> %a to <32 x i16>
  %and.i.i.i = and <32 x i16> %0, %1
  %2 = bitcast <32 x i16> %and.i.i.i to <32 x bfloat>
  ret <32 x bfloat> %2
}

define dso_local noundef <32 x bfloat> @max_lt_v32bf16(<32 x bfloat> noundef %a, <32 x bfloat> noundef %b, ptr nocapture nonnull writeonly align 4 dereferenceable(4) %cmp)  {
; CHECK-LABEL: max_lt_v32bf16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    vmax_lt.bf16 x0, r16, x2, x4 // Delay Slot 4
; CHECK-NEXT:    or r0, r16, r16 // Delay Slot 3
; CHECK-NEXT:    st r16, [p0, #0] // Delay Slot 2
; CHECK-NEXT:    mov r16, r0 // Delay Slot 1
entry:
  %0 = tail call { <32 x bfloat>, i32 } @llvm.aie2.vmax.ltbf16(<32 x bfloat> %a, <32 x bfloat> %b)
  %1 = extractvalue { <32 x bfloat>, i32 } %0, 1
  store i32 %1, ptr %cmp, align 4
  %2 = extractvalue { <32 x bfloat>, i32 } %0, 0
  ret <32 x bfloat> %2
}


define dso_local noundef <32 x bfloat> @max_v32bf16D(<32 x bfloat> noundef %a, <32 x bfloat> noundef %b)  {
; CHECK-LABEL: max_v32bf16D:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vmax_lt.bf16 x0, r16, x2, x4 // Delay Slot 3
; CHECK-NEXT:    or r0, r16, r16 // Delay Slot 2
; CHECK-NEXT:    mov r16, r0 // Delay Slot 1
entry:
  %0 = tail call { <32 x bfloat>, i32 } @llvm.aie2.vmax.ltbf16(<32 x bfloat> %a, <32 x bfloat> %b)
  %1 = extractvalue { <32 x bfloat>, i32 } %0, 0
  ret <32 x bfloat> %1
}

define dso_local noundef <32 x bfloat> @min_ge_v32bf16(<32 x bfloat> noundef %a, <32 x bfloat> noundef %b, ptr nocapture nonnull writeonly align 4 dereferenceable(4) %cmp)  {
; CHECK-LABEL: min_ge_v32bf16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; nopb ; ret lr ; nopm ; nops
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    vmin_ge.bf16 x0, r16, x2, x4 // Delay Slot 4
; CHECK-NEXT:    or r0, r16, r16 // Delay Slot 3
; CHECK-NEXT:    st r16, [p0, #0] // Delay Slot 2
; CHECK-NEXT:    mov r16, r0 // Delay Slot 1
entry:
  %0 = tail call { <32 x bfloat>, i32 } @llvm.aie2.vmin.gebf16(<32 x bfloat> %a, <32 x bfloat> %b)
  %1 = extractvalue { <32 x bfloat>, i32 } %0, 1
  store i32 %1, ptr %cmp, align 4
  %2 = extractvalue { <32 x bfloat>, i32 } %0, 0
  ret <32 x bfloat> %2
}


define dso_local noundef <32 x bfloat> @min_v32bf16(<32 x bfloat> noundef %a, <32 x bfloat> noundef %b)  {
; CHECK-LABEL: min_v32bf16:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vmin_ge.bf16 x0, r16, x2, x4 // Delay Slot 3
; CHECK-NEXT:    or r0, r16, r16 // Delay Slot 2
; CHECK-NEXT:    mov r16, r0 // Delay Slot 1
entry:
  %0 = tail call { <32 x bfloat>, i32 } @llvm.aie2.vmin.gebf16(<32 x bfloat> %a, <32 x bfloat> %b)
  %1 = extractvalue { <32 x bfloat>, i32 } %0, 0
  ret <32 x bfloat> %1
}


define dso_local noundef <16 x i32> @test_bfloat16_to_int(<16 x bfloat> noundef %a, i32 noundef %shft)  {
; CHECK-LABEL: test_bfloat16_to_int:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; ret lr ; nopm ; nopv
; CHECK-NEXT:    nopx // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    mov s0, r0 // Delay Slot 3
; CHECK-NEXT:    vfloor.s32.bf16 x0, wl2, s0 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <16 x i32> @llvm.aie2.v16bf16.to.v16i32(<16 x bfloat> %a, i32 %shft)
  ret <16 x i32> %0
}

declare { <32 x i16>, i32 } @llvm.aie2.vbneg.ltz16(<32 x i16>)

declare <32 x i16> @llvm.aie2.vbroadcast16.I512(i32)

declare { <32 x bfloat>, i32 } @llvm.aie2.vmax.ltbf16(<32 x bfloat>, <32 x bfloat>)

declare { <32 x bfloat>, i32 } @llvm.aie2.vmin.gebf16(<32 x bfloat>, <32 x bfloat>)

declare <16 x i32> @llvm.aie2.v16bf16.to.v16i32(<16 x bfloat>, i32)
