; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2  --issue-limit=1 %s -o - | FileCheck %s

define dso_local noundef <32 x i8> @_Z21test_extract_v64uint4Dv64_DU8_i(<64 x i8> noundef %a, i32 noundef %idx) local_unnamed_addr #0 {
; CHECK-LABEL: _Z21test_extract_v64uint4Dv64_DU8_i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nops ; nopv
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB0_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov x0, x2 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov wl0, wh0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_2: // %_ZL16extract_v64uint4Dv64_DU8_i.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  %1 = bitcast <64 x i8> %a to <16 x i32>
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %2 = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> %1, i32 0)
  br label %_ZL16extract_v64uint4Dv64_DU8_i.exit

if.else.i:
  %3 = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> %1, i32 1)
  br label %_ZL16extract_v64uint4Dv64_DU8_i.exit

_ZL16extract_v64uint4Dv64_DU8_i.exit:
  %retval.0.in.i = phi <8 x i32> [ %2, %if.then.i ], [ %3, %if.else.i ]
  %retval.0.i = bitcast <8 x i32> %retval.0.in.i to <32 x i8>
  ret <32 x i8> %retval.0.i
}


define dso_local noundef <32 x i8> @_Z21test_extract_v64uint4Dv64_DU8_(<64 x i8> noundef %a) local_unnamed_addr #0 {
; CHECK-LABEL: _Z21test_extract_v64uint4Dv64_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov x0, x2 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <64 x i8> %a to <16 x i32>
  %1 = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> %0, i32 0)
  %retval.0.i = bitcast <8 x i32> %1 to <32 x i8>
  ret <32 x i8> %retval.0.i
}


define dso_local noundef <32 x i8> @_Z30test_extract_v64uint4_256_1024Dv128_DU8_i(<128 x i8> noundef %a, i32 noundef %idx) local_unnamed_addr #1 {
; CHECK-LABEL: _Z30test_extract_v64uint4_256_1024Dv128_DU8_i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #160
; CHECK-NEXT:    st lr, [sp, #-156] // 4-byte Folded Spill
; CHECK-NEXT:    st r16, [sp, #-160] // 4-byte Folded Spill
; CHECK-NEXT:    mova r2, #4
; CHECK-NEXT:    vst wl4, [sp, #-128] // 32-byte Folded Spill
; CHECK-NEXT:    jl #__modsi3
; CHECK-NEXT:    vst wh4, [sp, #-96] // 32-byte Folded Spill Delay Slot 5
; CHECK-NEXT:    vst wl5, [sp, #-64] // 32-byte Folded Spill Delay Slot 4
; CHECK-NEXT:    vst wh5, [sp, #-32] // 32-byte Folded Spill Delay Slot 3
; CHECK-NEXT:    mov r1, r0 // Delay Slot 2
; CHECK-NEXT:    mova r16, #2 // Delay Slot 1
; CHECK-NEXT:    nopb ; nopa ; nops ; eq r1, r0, r16; nopm ; nopv
; CHECK-NEXT:    jnz r1, #.LBB2_5
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    mova r1, #1; nopxm ; nopv
; CHECK-NEXT:    eq r1, r0, r1
; CHECK-NEXT:    jnz r1, #.LBB2_4
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; jz r0, #.LBB2_6; nopv
; CHECK-NEXT:    nopv // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vlda wl4, [sp, #-128] // 32-byte Folded Reload Delay Slot 3
; CHECK-NEXT:    vlda wh5, [sp, #-32] // 32-byte Folded Reload Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.3: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; j #.LBB2_6; nopv
; CHECK-NEXT:    nopa ; nopm // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    vmov wl4, wh5 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB2_4: // %if.then3.i
; CHECK-NEXT:    vlda wh4, [sp, #-96]; nopxm ; nopv // 32-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    j #.LBB2_6
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    vmov wl4, wh4 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB2_5: // %if.then7.i
; CHECK-NEXT:    nopb ; vlda wl5, [sp, #-64]; nops ; nopx ; nopm ; nopv // 32-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov wl4, wl5
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB2_6: // %_ZL16extract_v64uint4Dv128_DU8_i.exit
; CHECK-NEXT:    nopb ; lda lr, [sp, #-156]; nops ; nopx ; nopm ; nopv // 4-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r16, [sp, #-160] // 4-byte Folded Reload
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wl0, wl4 // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-160 // Delay Slot 1
entry:
  %rem.i = srem i32 %idx, 4
  switch i32 %rem.i, label %if.else.i [
    i32 0, label %if.then.i
    i32 1, label %if.then3.i
    i32 2, label %if.then7.i
  ]

if.then.i:
  %0 = bitcast <128 x i8> %a to <32 x i32>
  %1 = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> %0, i32 0)
  br label %_ZL16extract_v64uint4Dv128_DU8_i.exit

if.then3.i:
  %2 = bitcast <128 x i8> %a to <32 x i32>
  %3 = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> %2, i32 1)
  br label %_ZL16extract_v64uint4Dv128_DU8_i.exit

if.then7.i:
  %4 = bitcast <128 x i8> %a to <32 x i32>
  %5 = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> %4, i32 2)
  br label %_ZL16extract_v64uint4Dv128_DU8_i.exit

if.else.i:
  %6 = bitcast <128 x i8> %a to <32 x i32>
  %7 = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> %6, i32 3)
  br label %_ZL16extract_v64uint4Dv128_DU8_i.exit

_ZL16extract_v64uint4Dv128_DU8_i.exit:
  %retval.0.in.i = phi <8 x i32> [ %1, %if.then.i ], [ %3, %if.then3.i ], [ %5, %if.then7.i ], [ %7, %if.else.i ]
  %retval.0.i = bitcast <8 x i32> %retval.0.in.i to <32 x i8>
  ret <32 x i8> %retval.0.i
}


define dso_local noundef <32 x i8> @_Z35test_extract_v64uint4_256_1024_idx0Dv128_DU8_(<128 x i8> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z35test_extract_v64uint4_256_1024_idx0Dv128_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wl0, wl4 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <128 x i8> %a to <32 x i32>
  %1 = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> %0, i32 0)
  %retval.0.i = bitcast <8 x i32> %1 to <32 x i8>
  ret <32 x i8> %retval.0.i
}


define dso_local noundef <32 x i8> @_Z35test_extract_v64uint4_256_1024_idx1Dv128_DU8_(<128 x i8> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z35test_extract_v64uint4_256_1024_idx1Dv128_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wl0, wh4 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <128 x i8> %a to <32 x i32>
  %1 = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> %0, i32 1)
  %retval.0.i = bitcast <8 x i32> %1 to <32 x i8>
  ret <32 x i8> %retval.0.i
}


define dso_local noundef <32 x i8> @_Z35test_extract_v64uint4_256_1024_idx2Dv128_DU8_(<128 x i8> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z35test_extract_v64uint4_256_1024_idx2Dv128_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wl0, wl5 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <128 x i8> %a to <32 x i32>
  %1 = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> %0, i32 2)
  %retval.0.i = bitcast <8 x i32> %1 to <32 x i8>
  ret <32 x i8> %retval.0.i
}


define dso_local noundef <32 x i8> @_Z35test_extract_v64uint4_256_1024_idx3Dv128_DU8_(<128 x i8> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z35test_extract_v64uint4_256_1024_idx3Dv128_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov wl0, wh5 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <128 x i8> %a to <32 x i32>
  %1 = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> %0, i32 3)
  %retval.0.i = bitcast <8 x i32> %1 to <32 x i8>
  ret <32 x i8> %retval.0.i
}


define dso_local noundef <64 x i8> @_Z31test_extract_v128uint4_512_1024Dv128_DU8_i(<128 x i8> noundef %a, i32 noundef %idx) local_unnamed_addr #1 {
; CHECK-LABEL: _Z31test_extract_v128uint4_512_1024Dv128_DU8_i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nopxm ; nopv
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB7_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov x4, x5; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB7_2: // %_ZL17extract_v128uint4Dv128_DU8_i.exit
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov x0, x4 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  %1 = bitcast <128 x i8> %a to <32 x i32>
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %2 = tail call <16 x i32> @llvm.aie2.ext.I512.I1024(<32 x i32> %1, i32 0)
  br label %_ZL17extract_v128uint4Dv128_DU8_i.exit

if.else.i:
  %3 = tail call <16 x i32> @llvm.aie2.ext.I512.I1024(<32 x i32> %1, i32 1)
  br label %_ZL17extract_v128uint4Dv128_DU8_i.exit

_ZL17extract_v128uint4Dv128_DU8_i.exit:
  %retval.0.in.i = phi <16 x i32> [ %2, %if.then.i ], [ %3, %if.else.i ]
  %retval.0.i = bitcast <16 x i32> %retval.0.in.i to <64 x i8>
  ret <64 x i8> %retval.0.i
}


define dso_local noundef <64 x i8> @_Z31test_extract_v128uint4_512_1024Dv128_DU8_(<128 x i8> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z31test_extract_v128uint4_512_1024Dv128_DU8_:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov x0, x4 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = bitcast <128 x i8> %a to <32 x i32>
  %1 = tail call <16 x i32> @llvm.aie2.ext.I512.I1024(<32 x i32> %0, i32 0)
  %retval.0.i = bitcast <16 x i32> %1 to <64 x i8>
  ret <64 x i8> %retval.0.i
}


define dso_local noundef <4 x i64> @_Z20test_extract_v8acc32Dv16_u7__acc32i(<8 x i64> noundef %a, i32 noundef %idx) local_unnamed_addr #0 {
; CHECK-LABEL: _Z20test_extract_v8acc32Dv16_u7__acc32i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nops ; nopv
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB9_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov bml0, bml1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov amll0, amlh0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB9_2: // %_ZL15extract_v8acc32Dv16_u7__acc32i.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %1 = tail call <4 x i64> @llvm.aie2.ext.256.512.acc(<8 x i64> %a, i32 0)
  br label %_ZL15extract_v8acc32Dv16_u7__acc32i.exit

if.else.i:
  %2 = tail call <4 x i64> @llvm.aie2.ext.256.512.acc(<8 x i64> %a, i32 1)
  br label %_ZL15extract_v8acc32Dv16_u7__acc32i.exit

_ZL15extract_v8acc32Dv16_u7__acc32i.exit:
  %retval.0.i = phi <4 x i64> [ %1, %if.then.i ], [ %2, %if.else.i ]
  ret <4 x i64> %retval.0.i
}


define dso_local noundef <4 x i64> @_Z20test_extract_v8acc32Dv16_u7__acc32(<8 x i64> noundef %a) local_unnamed_addr #0 {
; CHECK-LABEL: _Z20test_extract_v8acc32Dv16_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amll0, amlh1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <4 x i64> @llvm.aie2.ext.256.512.acc(<8 x i64> %a, i32 1)
  ret <4 x i64> %0
}


define dso_local noundef <4 x i64> @_Z20test_extract_v4acc64Dv8_u7__acc64i(<8 x i64> noundef %a, i32 noundef %idx) local_unnamed_addr #0 {
; CHECK-LABEL: _Z20test_extract_v4acc64Dv8_u7__acc64i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nops ; nopv
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB11_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov bml0, bml1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov amll0, amlh0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB11_2: // %_ZL15extract_v4acc64Dv8_u7__acc64i.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %1 = tail call <4 x i64> @llvm.aie2.ext.256.512.acc(<8 x i64> %a, i32 0)
  br label %_ZL15extract_v4acc64Dv8_u7__acc64i.exit

if.else.i:
  %2 = tail call <4 x i64> @llvm.aie2.ext.256.512.acc(<8 x i64> %a, i32 1)
  br label %_ZL15extract_v4acc64Dv8_u7__acc64i.exit

_ZL15extract_v4acc64Dv8_u7__acc64i.exit:
  %retval.0.i = phi <4 x i64> [ %1, %if.then.i ], [ %2, %if.else.i ]
  ret <4 x i64> %retval.0.i
}


define dso_local noundef <4 x i64> @_Z20test_extract_v4acc64Dv8_u7__acc64(<8 x i64> noundef %a) local_unnamed_addr #0 {
; CHECK-LABEL: _Z20test_extract_v4acc64Dv8_u7__acc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov bml0, bml1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <4 x i64> @llvm.aie2.ext.256.512.acc(<8 x i64> %a, i32 0)
  ret <4 x i64> %0
}


define dso_local noundef <4 x i64> @_Z20test_extract_v8acc32Dv32_u7__acc32i(<16 x i64> noundef %a, i32 noundef %idx) local_unnamed_addr #1 {
; CHECK-LABEL: _Z20test_extract_v8acc32Dv32_u7__acc32i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #160
; CHECK-NEXT:    st lr, [sp, #-156] // 4-byte Folded Spill
; CHECK-NEXT:    st r16, [sp, #-160] // 4-byte Folded Spill
; CHECK-NEXT:    mova r2, #4
; CHECK-NEXT:    vst amll1, [sp, #-128] // 32-byte Folded Spill
; CHECK-NEXT:    jl #__modsi3
; CHECK-NEXT:    vst amlh1, [sp, #-96] // 32-byte Folded Spill Delay Slot 5
; CHECK-NEXT:    vst amhl1, [sp, #-64] // 32-byte Folded Spill Delay Slot 4
; CHECK-NEXT:    vst amhh1, [sp, #-32] // 32-byte Folded Spill Delay Slot 3
; CHECK-NEXT:    mov r1, r0 // Delay Slot 2
; CHECK-NEXT:    mova r16, #2 // Delay Slot 1
; CHECK-NEXT:    nopb ; nopa ; nops ; eq r1, r0, r16; nopm ; nopv
; CHECK-NEXT:    jnz r1, #.LBB13_5
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    mova r1, #1; nopxm ; nopv
; CHECK-NEXT:    eq r1, r0, r1
; CHECK-NEXT:    jnz r1, #.LBB13_4
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; jz r0, #.LBB13_6; nopv
; CHECK-NEXT:    nopv // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vlda amll0, [sp, #-128] // 32-byte Folded Reload Delay Slot 3
; CHECK-NEXT:    vlda amhh0, [sp, #-32] // 32-byte Folded Reload Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.3: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; j #.LBB13_6; nopv
; CHECK-NEXT:    nopa ; nopm // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    vmov amll0, amhh0 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB13_4: // %if.then3.i
; CHECK-NEXT:    vlda amlh0, [sp, #-96]; nopxm ; nopv // 32-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    j #.LBB13_6
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    vmov amll0, amlh0 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB13_5: // %if.then7.i
; CHECK-NEXT:    nopb ; vlda amhl0, [sp, #-64]; nops ; nopx ; nopm ; nopv // 32-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov amll0, amhl0
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB13_6: // %_ZL15extract_v8acc32Dv32_u7__acc32i.exit
; CHECK-NEXT:    nopb ; lda lr, [sp, #-156]; nops ; nopx ; nopm ; nopv // 4-byte Folded Reload
; CHECK-NEXT:    nopv
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r16, [sp, #-160] // 4-byte Folded Reload
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-160 // Delay Slot 1
entry:
  %rem.i = srem i32 %idx, 4
  switch i32 %rem.i, label %if.else.i [
    i32 0, label %if.then.i
    i32 1, label %if.then3.i
    i32 2, label %if.then7.i
  ]

if.then.i:
  %0 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 0)
  br label %_ZL15extract_v8acc32Dv32_u7__acc32i.exit

if.then3.i:
  %1 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 1)
  br label %_ZL15extract_v8acc32Dv32_u7__acc32i.exit

if.then7.i:
  %2 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 2)
  br label %_ZL15extract_v8acc32Dv32_u7__acc32i.exit

if.else.i:
  %3 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 3)
  br label %_ZL15extract_v8acc32Dv32_u7__acc32i.exit

_ZL15extract_v8acc32Dv32_u7__acc32i.exit:
  %retval.0.i = phi <4 x i64> [ %0, %if.then.i ], [ %1, %if.then3.i ], [ %2, %if.then7.i ], [ %3, %if.else.i ]
  ret <4 x i64> %retval.0.i
}


define dso_local noundef <4 x i64> @_Z25test_extract_v8acc32_idx0Dv32_u7__acc32(<16 x i64> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z25test_extract_v8acc32_idx0Dv32_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov cm0, cm1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 0)
  ret <4 x i64> %0
}


define dso_local noundef <4 x i64> @_Z25test_extract_v8acc32_idx1Dv32_u7__acc32(<16 x i64> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z25test_extract_v8acc32_idx1Dv32_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amll0, amlh1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 1)
  ret <4 x i64> %0
}


define dso_local noundef <4 x i64> @_Z25test_extract_v8acc32_idx2Dv32_u7__acc32(<16 x i64> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z25test_extract_v8acc32_idx2Dv32_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amll0, amhl1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 2)
  ret <4 x i64> %0
}


define dso_local noundef <4 x i64> @_Z25test_extract_v8acc32_idx3Dv32_u7__acc32(<16 x i64> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z25test_extract_v8acc32_idx3Dv32_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amll0, amhh1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 3)
  ret <4 x i64> %0
}


define dso_local noundef <8 x i64> @_Z21test_extract_v16acc32Dv32_u7__acc32i(<16 x i64> noundef %a, i32 noundef %idx) local_unnamed_addr #1 {
; CHECK-LABEL: _Z21test_extract_v16acc32Dv32_u7__acc32i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nops ; nopv
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB18_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov cm0, cm1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov bml0, bmh0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB18_2: // %_ZL16extract_v16acc32Dv32_u7__acc32i.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %1 = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc(<16 x i64> %a, i32 0)
  br label %_ZL16extract_v16acc32Dv32_u7__acc32i.exit

if.else.i:
  %2 = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc(<16 x i64> %a, i32 1)
  br label %_ZL16extract_v16acc32Dv32_u7__acc32i.exit

_ZL16extract_v16acc32Dv32_u7__acc32i.exit:
  %retval.0.i = phi <8 x i64> [ %1, %if.then.i ], [ %2, %if.else.i ]
  ret <8 x i64> %retval.0.i
}


define dso_local noundef <8 x i64> @_Z21test_extract_v16acc32Dv32_u7__acc32(<16 x i64> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z21test_extract_v16acc32Dv32_u7__acc32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov cm0, cm1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc(<16 x i64> %a, i32 0)
  ret <8 x i64> %0
}


define dso_local noundef <4 x i64> @_Z20test_extract_v4acc64Dv16_u7__acc64i(<16 x i64> noundef %a, i32 noundef %idx) local_unnamed_addr #1 {
; CHECK-LABEL: _Z20test_extract_v4acc64Dv16_u7__acc64i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    nopa ; paddb [sp], #160
; CHECK-NEXT:    st lr, [sp, #-156] // 4-byte Folded Spill
; CHECK-NEXT:    st r16, [sp, #-160] // 4-byte Folded Spill
; CHECK-NEXT:    mova r2, #4
; CHECK-NEXT:    vst amll1, [sp, #-128] // 32-byte Folded Spill
; CHECK-NEXT:    jl #__modsi3
; CHECK-NEXT:    vst amlh1, [sp, #-96] // 32-byte Folded Spill Delay Slot 5
; CHECK-NEXT:    vst amhl1, [sp, #-64] // 32-byte Folded Spill Delay Slot 4
; CHECK-NEXT:    vst amhh1, [sp, #-32] // 32-byte Folded Spill Delay Slot 3
; CHECK-NEXT:    mov r1, r0 // Delay Slot 2
; CHECK-NEXT:    mova r16, #2 // Delay Slot 1
; CHECK-NEXT:    nopb ; nopa ; nops ; eq r1, r0, r16; nopm ; nopv
; CHECK-NEXT:    jnz r1, #.LBB20_5
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    mova r1, #1; nopxm ; nopv
; CHECK-NEXT:    eq r1, r0, r1
; CHECK-NEXT:    jnz r1, #.LBB20_4
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    nopb ; nopa ; nops ; jz r0, #.LBB20_6; nopv
; CHECK-NEXT:    nopv // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    vlda amll0, [sp, #-128] // 32-byte Folded Reload Delay Slot 3
; CHECK-NEXT:    vlda amhh0, [sp, #-32] // 32-byte Folded Reload Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.3: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; j #.LBB20_6; nopv
; CHECK-NEXT:    nopa ; nopm // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    vmov amll0, amhh0 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB20_4: // %if.then3.i
; CHECK-NEXT:    vlda amlh0, [sp, #-96]; nopxm ; nopv // 32-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    j #.LBB20_6
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    vmov amll0, amlh0 // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB20_5: // %if.then7.i
; CHECK-NEXT:    nopb ; vlda amhl0, [sp, #-64]; nops ; nopx ; nopm ; nopv // 32-byte Folded Reload
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov amll0, amhl0
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB20_6: // %_ZL15extract_v4acc64Dv16_u7__acc64i.exit
; CHECK-NEXT:    nopb ; lda lr, [sp, #-156]; nops ; nopx ; nopm ; nopv // 4-byte Folded Reload
; CHECK-NEXT:    nopv
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    lda r16, [sp, #-160] // 4-byte Folded Reload
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    paddb [sp], #-160 // Delay Slot 1
entry:
  %rem.i = srem i32 %idx, 4
  switch i32 %rem.i, label %if.else.i [
    i32 0, label %if.then.i
    i32 1, label %if.then3.i
    i32 2, label %if.then7.i
  ]

if.then.i:
  %0 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 0)
  br label %_ZL15extract_v4acc64Dv16_u7__acc64i.exit

if.then3.i:
  %1 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 1)
  br label %_ZL15extract_v4acc64Dv16_u7__acc64i.exit

if.then7.i:
  %2 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 2)
  br label %_ZL15extract_v4acc64Dv16_u7__acc64i.exit

if.else.i:
  %3 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 3)
  br label %_ZL15extract_v4acc64Dv16_u7__acc64i.exit

_ZL15extract_v4acc64Dv16_u7__acc64i.exit:
  %retval.0.i = phi <4 x i64> [ %0, %if.then.i ], [ %1, %if.then3.i ], [ %2, %if.then7.i ], [ %3, %if.else.i ]
  ret <4 x i64> %retval.0.i
}


define dso_local noundef <4 x i64> @_Z25test_extract_v4acc64_idx1Dv16_u7__acc64(<16 x i64> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z25test_extract_v4acc64_idx1Dv16_u7__acc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amll0, amlh1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 1)
  ret <4 x i64> %0
}


define dso_local noundef <4 x i64> @_Z25test_extract_v4acc64_idx2Dv16_u7__acc64(<16 x i64> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z25test_extract_v4acc64_idx2Dv16_u7__acc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov amll0, amhl1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64> %a, i32 2)
  ret <4 x i64> %0
}


define dso_local noundef <8 x i64> @_Z20test_extract_v8acc64Dv16_u7__acc64i(<16 x i64> noundef %a, i32 noundef %idx) local_unnamed_addr #1 {
; CHECK-LABEL: _Z20test_extract_v8acc64Dv16_u7__acc64i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r1, #1; nops ; nopv
; CHECK-NEXT:    and r0, r0, r1
; CHECK-NEXT:    jz r0, #.LBB23_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov cm0, cm1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:  // %bb.1: // %if.else.i
; CHECK-NEXT:    nopb ; nopa ; nops ; nopx ; vmov bml0, bmh0; nopv
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB23_2: // %_ZL15extract_v8acc64Dv16_u7__acc64i.exit
; CHECK-NEXT:    nopa ; ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = and i32 %idx, 1
  %cmp.i = icmp eq i32 %0, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:
  %1 = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc(<16 x i64> %a, i32 0)
  br label %_ZL15extract_v8acc64Dv16_u7__acc64i.exit

if.else.i:
  %2 = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc(<16 x i64> %a, i32 1)
  br label %_ZL15extract_v8acc64Dv16_u7__acc64i.exit

_ZL15extract_v8acc64Dv16_u7__acc64i.exit:
  %retval.0.i = phi <8 x i64> [ %1, %if.then.i ], [ %2, %if.else.i ]
  ret <8 x i64> %retval.0.i
}


define dso_local noundef <8 x i64> @_Z20test_extract_v8acc64Dv16_u7__acc64(<16 x i64> noundef %a) local_unnamed_addr #1 {
; CHECK-LABEL: _Z20test_extract_v8acc64Dv16_u7__acc64:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    vmov cm0, cm1 // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc(<16 x i64> %a, i32 0)
  ret <8 x i64> %0
}


declare <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32>, i32) #2
declare <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32>, i32) #2
declare <16 x i32> @llvm.aie2.ext.I512.I1024(<32 x i32>, i32) #2
declare <4 x i64> @llvm.aie2.ext.256.512.acc(<8 x i64>, i32) #2
declare <4 x i64> @llvm.aie2.ext.256.1024.acc(<16 x i64>, i32) #2
declare <8 x i64> @llvm.aie2.ext.512.1024.acc(<16 x i64>, i32) #2
