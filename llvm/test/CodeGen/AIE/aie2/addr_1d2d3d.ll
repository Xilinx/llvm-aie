; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -O2 -mtriple=aie2  --issue-limit=1  %s -o - | FileCheck %s

define dso_local ptr @test_byte_incr(ptr readnone %a, i32 noundef %incr) local_unnamed_addr #0 {
; CHECK-LABEL: test_byte_incr:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    mov p0, p1 // Delay Slot 3
; CHECK-NEXT:    mov m0, r0 // Delay Slot 2
; CHECK-NEXT:    paddb [p0], m0 // Delay Slot 1
entry:
  %idx.ext.i = trunc i32 %incr to i20
  %add.ptr.i = getelementptr inbounds i8, ptr %a, i20 %idx.ext.i
  ret ptr %add.ptr.i
}

define dso_local ptr @test_add_2d_ptr(ptr %a, i32 noundef %off, i32 noundef %size1, ptr nocapture nonnull align 4 dereferenceable(4) %count1, i32 noundef %inc1) local_unnamed_addr #1 {
; CHECK-LABEL: test_add_2d_ptr:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    lda dc0, [p2, #0]
; CHECK-NEXT:    mova r3, #6
; CHECK-NEXT:    lshl r0, r0, r3
; CHECK-NEXT:    mov m0, r0
; CHECK-NEXT:    mov dn0, r1
; CHECK-NEXT:    lshl r0, r2, r3
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mov p0, p1 // Delay Slot 5
; CHECK-NEXT:    mov dj0, r0 // Delay Slot 4
; CHECK-NEXT:    padda.2d [p0], d0 // Delay Slot 3
; CHECK-NEXT:    st dc0, [p2, #0] // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %mul.i = shl i32 %off, 6
  %0 = trunc i32 %mul.i to i20
  %mul1.i = shl i32 %inc1, 6
  %1 = trunc i32 %mul1.i to i20
  %2 = trunc i32 %size1 to i20
  %3 = load i32, ptr %count1, align 4, !tbaa !2
  %4 = trunc i32 %3 to i20
  %5 = tail call { ptr, i20 } @llvm.aie2.add.2d(ptr %a, i20 %0, i20 %1, i20 %2, i20 %4)
  %6 = extractvalue { ptr, i20 } %5, 1
  %7 = zext i20 %6 to i32
  store i32 %7, ptr %count1, align 4
  %8 = extractvalue { ptr, i20 } %5, 0
  ret ptr %8
}

define dso_local ptr @test_add_2d_byte(ptr %a, i32 noundef %off, i32 noundef %size1, ptr nocapture nonnull align 4 dereferenceable(4) %count1, i32 noundef %inc1) local_unnamed_addr #1 {
; CHECK-LABEL: test_add_2d_byte:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    lda dc0, [p2, #0]
; CHECK-NEXT:    mov m0, r0
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov dj0, r2
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mov dn0, r1 // Delay Slot 5
; CHECK-NEXT:    mov p0, p1 // Delay Slot 4
; CHECK-NEXT:    padda.2d [p0], d0 // Delay Slot 3
; CHECK-NEXT:    st dc0, [p2, #0] // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = trunc i32 %off to i20
  %1 = trunc i32 %inc1 to i20
  %2 = trunc i32 %size1 to i20
  %3 = load i32, ptr %count1, align 4, !tbaa !2
  %4 = trunc i32 %3 to i20
  %5 = tail call { ptr, i20 } @llvm.aie2.add.2d(ptr %a, i20 %0, i20 %1, i20 %2, i20 %4)
  %6 = extractvalue { ptr, i20 } %5, 1
  %7 = zext i20 %6 to i32
  store i32 %7, ptr %count1, align 4
  %8 = extractvalue { ptr, i20 } %5, 0
  ret ptr %8
}

define dso_local ptr @test_add_3d_ptr(ptr %a, i32 noundef %off, i32 noundef %size1, ptr nocapture nonnull align 4 dereferenceable(4) %count1, i32 noundef %inc1, i32 noundef %size2, ptr nocapture nonnull align 4 dereferenceable(4) %count2, i32 noundef %inc2) local_unnamed_addr #1 {
; CHECK-LABEL: test_add_3d_ptr:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    lda dc0, [p2, #0]
; CHECK-NEXT:    lda dc4, [p3, #0]
; CHECK-NEXT:    mova r5, #6
; CHECK-NEXT:    lshl r0, r0, r5
; CHECK-NEXT:    mov m0, r0
; CHECK-NEXT:    lshl r0, r2, r5
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov dj0, r0
; CHECK-NEXT:    mov dn0, r1
; CHECK-NEXT:    mov dn4, r3
; CHECK-NEXT:    mov p0, p1
; CHECK-NEXT:    lshl r0, r4, r5
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mov dj4, r0 // Delay Slot 5
; CHECK-NEXT:    padda.3d [p0], d0 // Delay Slot 4
; CHECK-NEXT:    st dc0, [p2, #0] // Delay Slot 3
; CHECK-NEXT:    st dc4, [p3, #0] // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %mul.i = shl i32 %off, 6
  %0 = trunc i32 %mul.i to i20
  %mul1.i = shl i32 %inc1, 6
  %1 = trunc i32 %mul1.i to i20
  %mul2.i = shl i32 %inc2, 6
  %2 = trunc i32 %mul2.i to i20
  %3 = trunc i32 %size1 to i20
  %4 = load i32, ptr %count1, align 4, !tbaa !2
  %5 = trunc i32 %4 to i20
  %6 = trunc i32 %size2 to i20
  %7 = load i32, ptr %count2, align 4, !tbaa !2
  %8 = trunc i32 %7 to i20
  %9 = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr %a, i20 %0, i20 %1, i20 %2, i20 %3, i20 %5, i20 %6, i20 %8)
  %10 = extractvalue { ptr, i20, i20 } %9, 1
  %11 = zext i20 %10 to i32
  %12 = extractvalue { ptr, i20, i20 } %9, 2
  %13 = zext i20 %12 to i32
  store i32 %11, ptr %count1, align 4
  store i32 %13, ptr %count2, align 4
  %14 = extractvalue { ptr, i20, i20 } %9, 0
  ret ptr %14
}

define dso_local ptr @test_add_3d_byte(ptr %a, i32 noundef %off, i32 noundef %size1, ptr nocapture nonnull align 4 dereferenceable(4) %count1, i32 noundef %inc1, i32 noundef %size2, ptr nocapture nonnull align 4 dereferenceable(4) %count2, i32 noundef %inc2) local_unnamed_addr #1 {
; CHECK-LABEL: test_add_3d_byte:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    lda dc0, [p2, #0]
; CHECK-NEXT:    lda dc4, [p3, #0]
; CHECK-NEXT:    mov m0, r0
; CHECK-NEXT:    mov dj0, r2
; CHECK-NEXT:    mov dj4, r4
; CHECK-NEXT:    mov dn0, r1
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov dn4, r3
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    mov p0, p1 // Delay Slot 5
; CHECK-NEXT:    padda.3d [p0], d0 // Delay Slot 4
; CHECK-NEXT:    st dc0, [p2, #0] // Delay Slot 3
; CHECK-NEXT:    st dc4, [p3, #0] // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = trunc i32 %off to i20
  %1 = trunc i32 %inc1 to i20
  %2 = trunc i32 %inc2 to i20
  %3 = trunc i32 %size1 to i20
  %4 = load i32, ptr %count1, align 4, !tbaa !2
  %5 = trunc i32 %4 to i20
  %6 = trunc i32 %size2 to i20
  %7 = load i32, ptr %count2, align 4, !tbaa !2
  %8 = trunc i32 %7 to i20
  %9 = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr %a, i20 %0, i20 %1, i20 %2, i20 %3, i20 %5, i20 %6, i20 %8)
  %10 = extractvalue { ptr, i20, i20 } %9, 1
  %11 = zext i20 %10 to i32
  %12 = extractvalue { ptr, i20, i20 } %9, 2
  %13 = zext i20 %12 to i32
  store i32 %11, ptr %count1, align 4
  store i32 %13, ptr %count2, align 4
  %14 = extractvalue { ptr, i20, i20 } %9, 0
  ret ptr %14
}

define dso_local ptr @test_add_2d_ptr_backTOback_call(ptr %a, i32 noundef %off, i32 noundef %size1, i32 noundef %inc1) local_unnamed_addr #0 {
; CHECK-LABEL: test_add_2d_ptr_backTOback_call:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r3, #6
; CHECK-NEXT:    lshl r0, r0, r3
; CHECK-NEXT:    mov p0, p1
; CHECK-NEXT:    mova dc0, #0
; CHECK-NEXT:    mov m0, r0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    lshl r0, r2, r3 // Delay Slot 5
; CHECK-NEXT:    mov dn0, r1 // Delay Slot 4
; CHECK-NEXT:    mov dj0, r0 // Delay Slot 3
; CHECK-NEXT:    padda.2d [p0], d0 // Delay Slot 2
; CHECK-NEXT:    padda.2d [p0], d0 // Delay Slot 1
entry:
  %mul.i = shl i32 %off, 6
  %0 = trunc i32 %mul.i to i20
  %mul1.i = shl i32 %inc1, 6
  %1 = trunc i32 %mul1.i to i20
  %2 = trunc i32 %size1 to i20
  %3 = tail call { ptr, i20 } @llvm.aie2.add.2d(ptr %a, i20 %0, i20 %1, i20 %2, i20 0)
  %4 = extractvalue { ptr, i20 } %3, 1
  %5 = extractvalue { ptr, i20 } %3, 0
  %6 = tail call { ptr, i20 } @llvm.aie2.add.2d(ptr %5, i20 %0, i20 %1, i20 %2, i20 %4)
  %7 = extractvalue { ptr, i20 } %6, 0
  ret ptr %7
}


define dso_local ptr @test_add_3d_ptr_backTOback_call(ptr %a, i32 noundef %off, i32 noundef %size1, i32 noundef %inc1, i32 noundef %size2, i32 noundef %inc2) local_unnamed_addr #0 {
; CHECK-LABEL: test_add_3d_ptr_backTOback_call:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mova r5, #6
; CHECK-NEXT:    lshl r0, r0, r5
; CHECK-NEXT:    mov m0, r0
; CHECK-NEXT:    lshl r0, r2, r5
; CHECK-NEXT:    mova dc0, #0
; CHECK-NEXT:    mov p0, p1
; CHECK-NEXT:    mov dn0, r1
; CHECK-NEXT:    mov dn4, r3
; CHECK-NEXT:    mov dj0, r0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    lshl r0, r4, r5 // Delay Slot 5
; CHECK-NEXT:    mov dc4, dc0 // Delay Slot 4
; CHECK-NEXT:    mov dj4, r0 // Delay Slot 3
; CHECK-NEXT:    padda.3d [p0], d0 // Delay Slot 2
; CHECK-NEXT:    padda.3d [p0], d0 // Delay Slot 1
entry:
  %mul.i = shl i32 %off, 6
  %0 = trunc i32 %mul.i to i20
  %mul1.i = shl i32 %inc1, 6
  %1 = trunc i32 %mul1.i to i20
  %mul2.i = shl i32 %inc2, 6
  %2 = trunc i32 %mul2.i to i20
  %3 = trunc i32 %size1 to i20
  %4 = trunc i32 %size2 to i20
  %5 = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr %a, i20 %0, i20 %1, i20 %2, i20 %3, i20 0, i20 %4, i20 0)
  %6 = extractvalue { ptr, i20, i20 } %5, 1
  %7 = extractvalue { ptr, i20, i20 } %5, 2
  %8 = extractvalue { ptr, i20, i20 } %5, 0
  %9 = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr %8, i20 %0, i20 %1, i20 %2, i20 %3, i20 %6, i20 %4, i20 %7)
  %10 = extractvalue { ptr, i20, i20 } %9, 0
  ret ptr %10
}


declare { ptr, i20 } @llvm.aie2.add.2d(ptr, i20, i20, i20, i20) #2
declare { ptr, i20, i20 } @llvm.aie2.add.3d(ptr, i20, i20, i20, i20, i20, i20, i20) #2
!0 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C++ TBAA"}
