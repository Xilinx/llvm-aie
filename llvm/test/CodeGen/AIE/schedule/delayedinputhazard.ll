; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie --issue-limit=1 < %s | FileCheck %s
; ModuleID = 't.ll'
source_filename = "llvm-link"
target datalayout = "e-m:e-p:32:32-i1:8:32-i8:8:32-i16:16:32-i32:32:32-f32:32:32-i64:32-f64:32-a:0:32-n32"
target triple = "aie"

@error = dso_local local_unnamed_addr global i32 0, align 4
@a = external global [32 x [32 x i32]]
@b = external global [32 x [32 x float]]

; The important thing in this test is that the instruction:
; vfpmac wr2, r0, wr2, ya, r15, cl0, wc0, #0, cl0, #1, cl1
; reads operand 2 (wr2) on cycle 4.  This means that there is an
; extra anti-dependence where wr2 cannot be written by another instruction
; until wr2 is read.  e.g.:
; vfpmac wr2, r0, wr2, ya, r15, cl0, wc0, #0, cl0, #1, cl1
; inst not_wr2
; inst not_wr2
; add wr2, wr0, wr1

; Note that we've assumed no forwarding path between vfpmac and add.  If there is
; a forwarding path then we need to delay one additional cycle.

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind writeonly
define dso_local void @func(i32* inreg nocapture %a, float* inreg nocapture %b, float inreg %MinRe, float inreg %MaxRe, float %MinIm, float %MaxIm) local_unnamed_addr #0 {
; CHECK-LABEL: func:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 r14, #0
; CHECK-NEXT:    mov.u20 cl0, #274960
; CHECK-NEXT:    mov cl1, r14
; CHECK-NEXT:    movt.s12 cl0, #1893
; CHECK-NEXT:    movt.s12 cl1, #11
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    vshl0.32 wr2, r7
; CHECK-NEXT:    vshl0.32 wr0, r6
; CHECK-NEXT:    vfpmac wd0, r0, wr2, ya, r15, cl0, wc0, #0, cl0, #1, cl1
; CHECK-NEXT:    mov cl2, r14
; CHECK-NEXT:    movt.s12 r14, #976
; CHECK-NEXT:    movt.s12 cl2, #9
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    vshl0.32 wc0, r14
; CHECK-NEXT:    vfpmul wr2, r0, yd, r15, cl0, wc0, #0, cl0, #0, cl2
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    vshl0.32 wr0, r8
; CHECK-NEXT:    mov.s12 cs0, #20
; CHECK-NEXT:    mov r7, r8
; CHECK-NEXT:    vext.32 r8, vl6[#0]
; CHECK-NEXT:    vext.32 r14, vl2[#0]
; CHECK-NEXT:    vshl0.32 wr2, r9
; CHECK-NEXT:    vfpmac wr2, r0, wr2, ya, r15, cl0, wc0, #0, cl0, #1, cl1
; CHECK-NEXT:    st r14, [p1, cs0]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    vext.32 r9, vl2[#0]
; CHECK-NEXT:    j _ZL5juliaPjffffff
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %sub = fsub float %MaxRe, %MinRe
  %div = fmul float %sub, 3.125000e-02
  %sub1 = fsub float %MaxIm, %MinIm
  ; %div2 = fmul float %sub1, 3.125000e-02
  ; store float %MinRe, float* %b, align 4, !tbaa !4
  ; %arrayidx3 = getelementptr inbounds float, float* %b, i32 1
  ; store float %MaxRe, float* %arrayidx3, align 4, !tbaa !4
  ; %arrayidx4 = getelementptr inbounds float, float* %b, i32 2
  ; store float %MinIm, float* %arrayidx4, align 4, !tbaa !4
  ; %arrayidx5 = getelementptr inbounds float, float* %b, i32 3
  ; store float %MaxIm, float* %arrayidx5, align 4, !tbaa !4
  ; %arrayidx6 = getelementptr inbounds float, float* %b, i32 4
  ; store float %div, float* %arrayidx6, align 4, !tbaa !4
  %arrayidx7 = getelementptr inbounds float, float* %b, i32 5
  store float %div, float* %arrayidx7, align 4, !tbaa !4
  tail call fastcc void @_ZL5juliaPjffffff(i32* inreg %a, float inreg %MinRe, float inreg %MinIm, float inreg %sub, float %sub1) #2
  ret void
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind writeonly
declare void @_ZL5juliaPjffffff(i32* inreg nocapture %framebuffer, float inreg %MinRe, float inreg %MinIm, float inreg %StepRe, float %StepIm) unnamed_addr #0

; Function Attrs: inaccessiblememonly nofree nosync nounwind willreturn
declare void @llvm.assume(i1 noundef) #1

attributes #0 = { mustprogress nofree noinline norecurse nosync nounwind writeonly "frame-pointer"="all" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #1 = { inaccessiblememonly nofree nosync nounwind willreturn }
attributes #2 = { nobuiltin "no-builtins" }

!llvm.ident = !{!0}
!llvm.module.flags = !{!1, !2, !3}

!0 = !{!"clang version 14.0.0 (ssh://git@gitenterprise.xilinx.com/stephenn/llvm-aie ec5e3b74ee9600e2ed4297b876a3ac4ef065b2e6)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 7, !"frame-pointer", i32 2}
!3 = !{i32 2, !"Debug Info Version", i32 3}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C++ TBAA"}
!8 = !{!9, !9, i64 0}
!9 = !{!"int", !6, i64 0}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
!12 = distinct !{!12, !11}
!13 = distinct !{!13, !11}
