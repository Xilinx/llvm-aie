#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
# RUN: llc --mtriple=aie --issue-limit=1 %s --start-before=post-RA-sched \
# RUN:   -o %t.s
# RUN: cat %t.s | FileCheck %s

# This represents a case where instruction scheduling can cause problems.
# In particular, there are a variety of loads and stores that have both
# true data dependencies and scheduling hazards, because the writeback to
# the scalar register file is a contended resource

# CHECK:  mov     r14, p0
# CHECK:  padda   [sp], #64
# CHECK:  mov     r13, p1
# CHECK:  mov     p0, r14
# CHECK:  st.spil lr, [sp, #-64]
# CHECK:  st      p0, [sp, #-60]
# CHECK:  mov     p0, r13
# CHECK:  mov     r12, p2
# CHECK:  st      p0, [sp, #-56]
# CHECK:  mov     p0, r12
# CHECK:  mov.u20 r12, #0
# CHECK:  st      p0, [sp, #-52]
# CHECK:  st      r12, [sp, #-48]
# CHECK:  lda     p0, [sp, #-52]
# CHECK:  lda     r13, [sp, #-48]
# CHECK:  mov.u20 p1, #10
# CHECK:  mov     r14, p1
# CHECK:  lda     r12, [sp, #-40]
# CHECK:  nop
# CHECK:  nop
# CHECK:  nop
# CHECK:  nop
# CHECK:  lshl    r13, r13, r14
# CHECK:  mov     r14, p0
# CHECK:  mov.u20 p0, #2
# CHECK:  add     r13, r14, r13
# CHECK:  lda     r14, [sp, #-44]
# CHECK:  mov     r5, p0
# CHECK:  nop
# CHECK:  nop
# CHECK:  nop
# CHECK:  nop
# CHECK:  nop
# CHECK:  lshl    r14, r14, r5
# CHECK:  add     r13, r13, r14
# CHECK:  mov     p0, r13
# CHECK:  st      r12, [p0]
# CHECK:  ldb     lr, [sp, #-64]
# CHECK:  padda   [sp], #-64

--- |
  ; ModuleID = '<stdin>'
  source_filename = "conv2d.c"
  target datalayout = "e-m:e-p:20:32-i1:8:32-i8:8:32-i16:16:32-i32:32:32-f32:32:32-i64:32-f64:32-a:0:32-n32"
  target triple = "aie"

  ; Function Attrs: mustprogress noinline nounwind optnone
  define dso_local void @conv2d([272 x float]* %img_in, [3 x float]* %kernel_coeff, [256 x float]* %img_out) #0 {
  entry:
    %img_in.addr = alloca [272 x float]*, align 4
    %kernel_coeff.addr = alloca [3 x float]*, align 4
    %img_out.addr = alloca [256 x float]*, align 4
    %r = alloca i32, align 4
    %c = alloca i32, align 4
    %acc = alloca float, align 4
    %i = alloca i32, align 4
    %j = alloca i32, align 4
    store [272 x float]* %img_in, [272 x float]** %img_in.addr, align 4
    store [3 x float]* %kernel_coeff, [3 x float]** %kernel_coeff.addr, align 4
    store [256 x float]* %img_out, [256 x float]** %img_out.addr, align 4
    store i32 0, i32* %r, align 4
    br label %for.cond

  for.cond:                                         ; preds = %for.inc22, %entry
    %0 = load i32, i32* %r, align 4
    %cmp = icmp slt i32 %0, 16
    br i1 %cmp, label %for.body, label %for.end24

  for.body:                                         ; preds = %for.cond
    store i32 0, i32* %c, align 4
    br label %for.cond1

  for.cond1:                                        ; preds = %for.inc19, %for.body
    %1 = load i32, i32* %c, align 4
    %cmp2 = icmp slt i32 %1, 256
    br i1 %cmp2, label %for.body3, label %for.end21

  for.body3:                                        ; preds = %for.cond1
    store float 0.000000e+00, float* %acc, align 4
    store i32 0, i32* %i, align 4
    br label %for.cond4

  for.cond4:                                        ; preds = %for.inc14, %for.body3
    %2 = load i32, i32* %i, align 4
    %cmp5 = icmp slt i32 %2, 3
    br i1 %cmp5, label %for.body6, label %for.end16

  for.body6:                                        ; preds = %for.cond4
    store i32 0, i32* %j, align 4
    br label %for.cond7

  for.cond7:                                        ; preds = %for.inc, %for.body6
    %3 = load i32, i32* %j, align 4
    %cmp8 = icmp slt i32 %3, 3
    br i1 %cmp8, label %for.body9, label %for.end

  for.body9:                                        ; preds = %for.cond7
    %4 = load [272 x float]*, [272 x float]** %img_in.addr, align 4
    %5 = load i32, i32* %r, align 4
    %6 = load i32, i32* %i, align 4
    %add = add nsw i32 %5, %6
    %arrayidx = getelementptr inbounds [272 x float], [272 x float]* %4, i32 %add
    %7 = load i32, i32* %c, align 4
    %8 = load i32, i32* %j, align 4
    %add10 = add nsw i32 %7, %8
    %arrayidx11 = getelementptr inbounds [272 x float], [272 x float]* %arrayidx, i32 0, i32 %add10
    %9 = load float, float* %arrayidx11, align 4
    %10 = load [3 x float]*, [3 x float]** %kernel_coeff.addr, align 4
    %11 = load i32, i32* %i, align 4
    %arrayidx12 = getelementptr inbounds [3 x float], [3 x float]* %10, i32 %11
    %12 = load i32, i32* %j, align 4
    %arrayidx13 = getelementptr inbounds [3 x float], [3 x float]* %arrayidx12, i32 0, i32 %12
    %13 = load float, float* %arrayidx13, align 4
    %14 = load float, float* %acc, align 4
    %15 = call float @llvm.fmuladd.f32(float %9, float %13, float %14)
    store float %15, float* %acc, align 4
    br label %for.inc

  for.inc:                                          ; preds = %for.body9
    %16 = load i32, i32* %j, align 4
    %inc = add nsw i32 %16, 1
    store i32 %inc, i32* %j, align 4
    br label %for.cond7, !llvm.loop !2

  for.end:                                          ; preds = %for.cond7
    br label %for.inc14

  for.inc14:                                        ; preds = %for.end
    %17 = load i32, i32* %i, align 4
    %inc15 = add nsw i32 %17, 1
    store i32 %inc15, i32* %i, align 4
    br label %for.cond4, !llvm.loop !5

  for.end16:                                        ; preds = %for.cond4
    %18 = load float, float* %acc, align 4
    %19 = load [256 x float]*, [256 x float]** %img_out.addr, align 4
    %20 = load i32, i32* %r, align 4
    %arrayidx17 = getelementptr inbounds [256 x float], [256 x float]* %19, i32 %20
    %21 = load i32, i32* %c, align 4
    %arrayidx18 = getelementptr inbounds [256 x float], [256 x float]* %arrayidx17, i32 0, i32 %21
    store float %18, float* %arrayidx18, align 4
    br label %for.inc19

  for.inc19:                                        ; preds = %for.end16
    %22 = load i32, i32* %c, align 4
    %inc20 = add nsw i32 %22, 1
    store i32 %inc20, i32* %c, align 4
    br label %for.cond1, !llvm.loop !6

  for.end21:                                        ; preds = %for.cond1
    br label %for.inc22

  for.inc22:                                        ; preds = %for.end21
    %23 = load i32, i32* %r, align 4
    %inc23 = add nsw i32 %23, 1
    store i32 %inc23, i32* %r, align 4
    br label %for.cond, !llvm.loop !7

  for.end24:                                        ; preds = %for.cond
    ret void
  }

  ; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
  declare float @llvm.fmuladd.f32(float, float, float) #1

  attributes #0 = { mustprogress noinline nounwind optnone "frame-pointer"="none" "min-legal-vector-width"="0" "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
  attributes #1 = { nocallback nofree nosync nounwind readnone speculatable willreturn }

  !llvm.module.flags = !{!0}
  !llvm.ident = !{!1}

  !0 = !{i32 1, !"wchar_size", i32 4}
  !1 = !{!"clang version 15.0.0"}
  !2 = distinct !{!2, !3, !4}
  !3 = !{!"llvm.loop.mustprogress"}
  !4 = !{!"llvm.loop.unroll.disable"}
  !5 = distinct !{!5, !3, !4}
  !6 = distinct !{!6, !3, !4}
  !7 = distinct !{!7, !3, !4}

...
---
name:            conv2d
alignment:       16
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
failsVerification: false
tracksDebugUserValues: true
registers:       []
liveins:
  - { reg: '$p0', virtual-reg: '' }
  - { reg: '$p1', virtual-reg: '' }
  - { reg: '$p2', virtual-reg: '' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       64
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  maxCallFrameSize: 0
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  hasTailCall:     false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:
  - { id: 0, name: img_in.addr, type: default, offset: 4, size: 4, alignment: 4,
      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  - { id: 1, name: kernel_coeff.addr, type: default, offset: 8, size: 4,
      alignment: 4, stack-id: default, callee-saved-register: '', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  - { id: 2, name: img_out.addr, type: default, offset: 12, size: 4, alignment: 4,
      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  - { id: 3, name: r, type: default, offset: 16, size: 4, alignment: 4,
      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  - { id: 4, name: c, type: default, offset: 20, size: 4, alignment: 4,
      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  - { id: 5, name: acc, type: default, offset: 24, size: 4, alignment: 4,
      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  - { id: 6, name: i, type: default, offset: 28, size: 4, alignment: 4,
      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  - { id: 7, name: j, type: default, offset: 32, size: 4, alignment: 4,
      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  - { id: 8, name: '', type: spill-slot, offset: 0, size: 4, alignment: 4,
      stack-id: default, callee-saved-register: '$lr', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
callSites:       []
debugValueSubstitutions: []
constants:       []
machineFunctionInfo: {}
body:             |
  bb.0.entry:
    liveins: $p0, $p1, $p2

    frame-setup PADDA_sp_imm 64, implicit-def $sp, implicit $sp
    ST_SPIL_PTR killed $lr, -64, implicit $sp
    $r12 = MOV $p2
    $r13 = MOV $p1
    $r14 = MOV $p0
    $p0 = MOV killed $r14
    ST_spis_PTR killed renamable $p0, -60, implicit $sp :: (store (s24) into %ir.img_in.addr, align 4)
    $p0 = MOV killed $r13
    ST_spis_PTR killed renamable $p0, -56, implicit $sp :: (store (s24) into %ir.kernel_coeff.addr, align 4)
    $p0 = MOV killed $r12
    ST_spis_PTR killed renamable $p0, -52, implicit $sp :: (store (s24) into %ir.img_out.addr, align 4)
    renamable $r12 = MOV_U20 0
    ST_spis_GPR killed renamable $r12, -48, implicit $sp :: (store (s32) into %ir.r)

    renamable $r12 = LDA_spis_GPR -40, implicit $sp :: (dereferenceable load (s32) from %ir.acc)
    renamable $p0 = LDA_spis_PTR -52, implicit $sp :: (dereferenceable load (s24) from %ir.img_out.addr, align 4)
    renamable $r13 = LDA_spis_GPR -48, implicit $sp :: (dereferenceable load (s32) from %ir.r)
    renamable $p1 = MOV_U20_I20 10
    $r14 = MOV killed $p1
    renamable $r13 = LSHL killed renamable $r13, killed renamable $r14
    $r14 = MOV killed $p0
    renamable $r13 = ADD killed renamable $r14, killed renamable $r13
    renamable $r14 = LDA_spis_GPR -44, implicit $sp :: (dereferenceable load (s32) from %ir.c)
    renamable $p0 = MOV_U20_I20 2
    $r5 = MOV killed $p0
    renamable $r14 = LSHL killed renamable $r14, killed renamable $r5
    renamable $r13 = ADD killed renamable $r13, killed renamable $r14
    $p0 = MOV killed $r13
    ST_ind_GPR killed renamable $r12, killed renamable $p0 :: (store (s32) into %ir.arrayidx18)

    $lr = LDB_spis -64, implicit $sp
    frame-destroy PADDA_sp_imm -64, implicit-def $sp, implicit $sp
    PseudoRET implicit $lr

...
