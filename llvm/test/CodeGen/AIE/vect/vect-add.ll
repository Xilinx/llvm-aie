; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc < %s -verify-machineinstrs -mtriple=aie | FileCheck %s

define <8 x i32> @add8xi32(<8 x i32> %A, <8 x i32> %B) {
; CHECK-LABEL: add8xi32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 ch0, #65536
; CHECK-NEXT:    movt.s12 ch0, #0
; CHECK-NEXT:    mov.u20 cl0, #49152
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    movt.s12 cl0, #0
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    mov.u20 r5, #16
; CHECK-NEXT:    vmov wr2, wr1
; CHECK-NEXT:    // kill: def $wr0 killed $wr0 def $xa
; CHECK-NEXT:    vcmp xc, r0, ya.s32, r15, c1, r5, c1, c0
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov wr0, wc0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
	%tmp1 = add <8 x i32> %A, %B
	ret <8 x i32> %tmp1
}

define <16 x i32> @add16xi32(<16 x i32> %A, <16 x i32> %B) {
; CHECK-LABEL: add16xi32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 ch0, #65536
; CHECK-NEXT:    mov.u20 ch1, #834200
; CHECK-NEXT:    movt.s12 ch0, #0
; CHECK-NEXT:    movt.s12 ch1, #-19
; CHECK-NEXT:    mov.u20 cl0, #49152
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    movt.s12 cl0, #0
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    mov.u20 r5, #16
; CHECK-NEXT:    nop
; CHECK-NEXT:    vcmp xc, r0, ya.s32, r15, c1, r5, c1, c0
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov xa, xc
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
	%tmp1 = add <16 x i32> %A, %B
	ret <16 x i32> %tmp1
}

declare <8 x i32> @llvm.smin.v8i32(<8 x i32>, <8 x i32>)
declare <16 x i32> @llvm.smin.v16i32(<16 x i32>, <16 x i32>)

define <8 x i32> @min8xi32(<8 x i32> %A, <8 x i32> %B) {
; CHECK-LABEL: min8xi32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 ch0, #65536
; CHECK-NEXT:    movt.s12 ch0, #0
; CHECK-NEXT:    mov.u20 cl0, #638976
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    movt.s12 cl0, #33
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    mov.u20 r5, #16
; CHECK-NEXT:    vmov wr2, wr1
; CHECK-NEXT:    // kill: def $wr0 killed $wr0 def $xa
; CHECK-NEXT:    vcmp xc, r0, ya.s32, r15, c1, r5, c1, c0
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov wr0, wc0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
	%tmp1 = call <8 x i32> @llvm.smin.v8i32(<8 x i32> %A, <8 x i32> %B)
	ret <8 x i32> %tmp1
}

define <16 x i32> @min16xi32(<16 x i32> %A, <16 x i32> %B) {
; CHECK-LABEL: min16xi32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 ch0, #65536
; CHECK-NEXT:    mov.u20 ch1, #834200
; CHECK-NEXT:    movt.s12 ch0, #0
; CHECK-NEXT:    movt.s12 ch1, #-19
; CHECK-NEXT:    mov.u20 cl0, #638976
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    movt.s12 cl0, #33
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    mov.u20 r5, #16
; CHECK-NEXT:    nop
; CHECK-NEXT:    vcmp xc, r0, ya.s32, r15, c1, r5, c1, c0
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov xa, xc
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
	%tmp1 = call <16 x i32> @llvm.smin.v16i32(<16 x i32> %A, <16 x i32> %B)
	ret <16 x i32> %tmp1
}

declare <8 x i32> @llvm.smax.v8i32(<8 x i32>, <8 x i32>)
declare <16 x i32> @llvm.smax.v16i32(<16 x i32>, <16 x i32>)

define <8 x i32> @max8xi32(<8 x i32> %A, <8 x i32> %B) {
; CHECK-LABEL: max8xi32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 ch0, #65536
; CHECK-NEXT:    movt.s12 ch0, #0
; CHECK-NEXT:    mov.u20 cl0, #638976
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    movt.s12 cl0, #41
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    mov.u20 r5, #16
; CHECK-NEXT:    vmov wr2, wr1
; CHECK-NEXT:    // kill: def $wr0 killed $wr0 def $xa
; CHECK-NEXT:    vcmp xc, r0, ya.s32, r15, c1, r5, c1, c0
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov wr0, wc0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
	%tmp1 = call <8 x i32> @llvm.smax.v8i32(<8 x i32> %A, <8 x i32> %B)
	ret <8 x i32> %tmp1
}

define <16 x i32> @max16xi32(<16 x i32> %A, <16 x i32> %B) {
; CHECK-LABEL: max16xi32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 ch0, #65536
; CHECK-NEXT:    mov.u20 ch1, #834200
; CHECK-NEXT:    movt.s12 ch0, #0
; CHECK-NEXT:    movt.s12 ch1, #-19
; CHECK-NEXT:    mov.u20 cl0, #638976
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    movt.s12 cl0, #41
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    mov.u20 r15, #0
; CHECK-NEXT:    mov.u20 r5, #16
; CHECK-NEXT:    nop
; CHECK-NEXT:    vcmp xc, r0, ya.s32, r15, c1, r5, c1, c0
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov xa, xc
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
	%tmp1 = call <16 x i32> @llvm.smax.v16i32(<16 x i32> %A, <16 x i32> %B)
	ret <16 x i32> %tmp1
}
