; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc --issue-limit=1 -verify-machineinstrs -mtriple=aie < %s \
; RUN:   | FileCheck %s


define <8 x i32> @vselect_v8i32(<8 x i32> %a, i32 %d) {
; CHECK-LABEL: vselect_v8i32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    // kill: def $wr0 killed $wr0 def $ya
; CHECK-NEXT:    vshl0.32 wr2, r12
; CHECK-NEXT:    vshl0.32 wr2, r12
; CHECK-NEXT:    vshl0.32 wr2, r12
; CHECK-NEXT:    mov.u20 ch0, #65536
; CHECK-NEXT:    vshl0.32 wr2, r12
; CHECK-NEXT:    vshl0.32 wr2, r12
; CHECK-NEXT:    movt.s12 ch0, #0
; CHECK-NEXT:    mov.u20 cl0, #49152
; CHECK-NEXT:    vshl0.32 wr2, r12
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    vshl0.32 wr2, r12
; CHECK-NEXT:    movt.s12 cl0, #0
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    mov.u20 r0, #16
; CHECK-NEXT:    vshl0.32 wr2, r12
; CHECK-NEXT:    mov.u20 r13, #3
; CHECK-NEXT:    vsel xc, ya.s32, r12, c1, r0, c1, c0, r13
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov wr0, wc0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %b = select <8 x i1> <i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>,
              <8 x i32> %a,
			  <8 x i32> <i32 undef, i32 undef, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0>
  ret <8 x i32> %b
}

; define <8 x i8> @vselect_v8i8(<8 x i8> %a) {
;   %b = select <8 x i1> <i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <8 x i8> %a, <8 x i8> <i8 undef, i8 undef, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>
;   ret <8 x i8> %b
; }

; define <4 x i16> @vselect_v4i16(<4 x i16> %a) {
;   %b = select <4 x i1> <i1 true, i1 false, i1 false, i1 false>, <4 x i16> %a, <4 x i16> <i16 undef, i16 0, i16 0, i16 0>
;   ret <4 x i16> %b
; }

; define <8 x i8> @vselect_cmp_ne(<8 x i8> %a, <8 x i8> %b, <8 x i8> %c) {
;   %cmp = icmp ne <8 x i8> %a, %b
;   %d = select <8 x i1> %cmp, <8 x i8> %b, <8 x i8> %c
;   ret <8 x i8> %d
; }

; define <8 x i8> @vselect_cmp_eq(<8 x i8> %a, <8 x i8> %b, <8 x i8> %c) {
;   %cmp = icmp eq <8 x i8> %a, %b
;   %d = select <8 x i1> %cmp, <8 x i8> %b, <8 x i8> %c
;   ret <8 x i8> %d
; }

; define <8 x i8> @vselect_cmpz_ne(<8 x i8> %a, <8 x i8> %b, <8 x i8> %c) {
;   %cmp = icmp ne <8 x i8> %a, zeroinitializer
;   %d = select <8 x i1> %cmp, <8 x i8> %b, <8 x i8> %c
;   ret <8 x i8> %d
; }

; define <8 x i8> @vselect_cmpz_eq(<8 x i8> %a, <8 x i8> %b, <8 x i8> %c) {
;   %cmp = icmp eq <8 x i8> %a, zeroinitializer
;   %d = select <8 x i1> %cmp, <8 x i8> %b, <8 x i8> %c
;   ret <8 x i8> %d
; }

; define <8 x i8> @vselect_tst(<8 x i8> %a, <8 x i8> %b, <8 x i8> %c) {
;   %tmp3 = and <8 x i8> %a, %b
;   %tmp4 = icmp eq <8 x i8> %tmp3, zeroinitializer
;   %d = select <8 x i1> %tmp4, <8 x i8> %c, <8 x i8> %b
;   ret <8 x i8> %d
; }
define <32 x i16> @_Z13test_select32v() {
; CHECK-LABEL: _Z13test_select32v:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 cl0, #114688
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    movt.s12 cl0, #25
; CHECK-NEXT:    mov cl1, r12
; CHECK-NEXT:    mov.u20 ch0, #65536
; CHECK-NEXT:    mov ch1, r12
; CHECK-NEXT:    mov.u20 r0, #2
; CHECK-NEXT:    nop
; CHECK-NEXT:    vsel xc, ya.s16, r12, c1, r0, c1, c0, r12
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmov xa, xc
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <16 x i16> @llvm.aie.v16i16undef()
  %1 = tail call <32 x i16> @llvm.aie.concat.v16i16(<16 x i16> %0, <16 x i16> %0)
  %2 = tail call <32 x i16> @llvm.aie.prim.v32int16.select(<32 x i16> %1, i32 0, i32 0, i32 2, <2 x i32> zeroinitializer, <2 x i32> zeroinitializer, <2 x i32> <i32 26329088, i32 65536>)
  ret <32 x i16> %2
}

declare <32 x i16> @llvm.aie.prim.v32int16.select(<32 x i16>, i32, i32, i32, <2 x i32>, <2 x i32>, <2 x i32>)
declare <32 x i16> @llvm.aie.concat.v16i16(<16 x i16>, <16 x i16>)
declare <16 x i16> @llvm.aie.v16i16undef()
