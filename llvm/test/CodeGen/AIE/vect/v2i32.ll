; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc --issue-limit=1 < %s -verify-machineinstrs -mtriple=aie \
; RUN:   | FileCheck %s
define void @v2i32_call() {
; CHECK-LABEL: v2i32_call:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r6, #1
; CHECK-NEXT:    mov.u20 r7, #2
; CHECK-NEXT:    mov.u20 r8, #3
; CHECK-NEXT:    mov.u20 r9, #4
; CHECK-NEXT:    j bar
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %call = tail call <2 x i32> @bar(<2 x i32> inreg <i32 1, i32 2>, <2 x i32> inreg <i32 3, i32 4>) #3
  ret void
}

declare <2 x i32> @bar(<2 x i32> inreg, <2 x i32> inreg)

define <2 x i32> @v2i32_insert(<2 x i32> inreg %arg0) {
; CHECK-LABEL: v2i32_insert:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    add r12, r6, #10
; CHECK-NEXT:    mov cl1, r12
; CHECK-NEXT:    add r12, r7, #20
; CHECK-NEXT:    mov ch1, r12
; CHECK-NEXT:    mov r0, cl1
; CHECK-NEXT:    mov r1, ch1
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %1 = insertelement <2 x i32> %arg0, i32 10, i32 0
  %2 = insertelement <2 x i32> %arg0, i32 20, i32 1
  %3 = add  <2 x i32> %1, %2
  ret <2 x i32>  %3
}

define i32 @v2i32_extract(<2 x i32> %val) {
; CHECK-LABEL: v2i32_extract:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov cl1, r6
; CHECK-NEXT:    mov ch1, r7
; CHECK-NEXT:    mov r13, cl1
; CHECK-NEXT:    add r0, r13, r7
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
  %r0 = extractelement <2 x i32> %val, i32 0    ; yields i32
  %r1 = extractelement <2 x i32> %val, i32 1    ; yields i32
  %r2 = add i32 %r0, %r1
  ret i32 %r2
}

define <2 x i32> @v2i32_undef_intrinsic() {
; CHECK-LABEL: v2i32_undef_intrinsic:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r12, sp
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    padda [p0], #-28
; CHECK-NEXT:    mov.u20 r12, #200
; CHECK-NEXT:    st r12, [p0]
; CHECK-NEXT:    st.spil r12, [sp, #-32]
; CHECK-NEXT:    lda ch0, [p0]
; CHECK-NEXT:    lda.spil cl0, [sp, #-32]
; CHECK-NEXT:    mov r1, ch0
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r0, cl0
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %val = alloca <2 x i32>, align 8
  %0 = tail call <2 x i32> @llvm.aie.v2i32undef()
  %vecins = insertelement <2 x i32> %0, i32 100, i32 0
  %vecins1 = insertelement <2 x i32> %0, i32 200, i32 1
  store volatile <2 x i32> %vecins1, <2 x i32>* %val
  %val.0 = load volatile <2 x i32>, <2 x i32>* %val
  ret <2 x i32> %val.0
}
; Function Attrs: nofree nosync nounwind readnone
declare <2 x i32> @llvm.aie.v2i32undef()
