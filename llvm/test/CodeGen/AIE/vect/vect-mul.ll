; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc --issue-limit=1 -verify-machineinstrs -mtriple=aie < %s \
; RUN:   | FileCheck %s
define <8 x i32> @mul8xi32(<8 x i32> %A, <8 x i32> %B) {
; CHECK-LABEL: mul8xi32:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.u20 r0, #0
; CHECK-NEXT:    mov r1, r0
; CHECK-NEXT:    movt.s12 r1, #0
; CHECK-NEXT:    mov ch0, r1
; CHECK-NEXT:    mov.u20 cl0, #65536
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    movt.s12 cl0, #0
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    vmov wc0, wr1
; CHECK-NEXT:    // kill: def $wr0 killed $wr0 def $ya
; CHECK-NEXT:    vmul.80 aml0, ya.s32, r0, c1, r0, wc0.s32, #0, c1, c0
; CHECK-NEXT:    mov.u20 r12, #12
; CHECK-NEXT:    mov s0, r0
; CHECK-NEXT:    mov md0, r12
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmovs.80.srsl wr0, aml0, s0
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
	%tmp1 = mul <8 x i32> %A, %B;
	ret <8 x i32> %tmp1
}
define <16 x i48> @_Z12mul16_v32i32Dv32_iDv16_s(<32 x i32> %xbuff, <16 x i16> %zbuff) {
; CHECK-LABEL: _Z12mul16_v32i32Dv32_iDv16_s:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 cl0, #274960
; CHECK-NEXT:    mov.u20 cl1, #262672
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    movt.s12 cl0, #1893
; CHECK-NEXT:    movt.s12 cl1, #869
; CHECK-NEXT:    mov cl2, r12
; CHECK-NEXT:    mov.u20 ch0, #4112
; CHECK-NEXT:    mov.u20 ch1, #12816
; CHECK-NEXT:    mov ch2, r12
; CHECK-NEXT:    mov.u20 r0, #2
; CHECK-NEXT:    nop
; CHECK-NEXT:    vmul.48 bm0, ya.s32, r12, c1, r0, wc0.s16, #2, c0, c2
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <16 x i48> @llvm.aie.mul16.v32int32(<32 x i32> %xbuff, <16 x i16> %zbuff, i32 0, i32 2, i32 2, <2 x i32> <i32 911475216, i32 12816>, <2 x i32> <i32 1985229328, i32 4112>, <2 x i32> zeroinitializer)
  ret <16 x i48> %0
}
define <16 x i48> @_Z12mul16_v128i8Dv128_aDv32_a(<128 x i8> %xbuff, <32 x i8> %zbuff) {
; CHECK-LABEL: _Z12mul16_v128i8Dv128_aDv32_a:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 cl1, #274960
; CHECK-NEXT:    mov.u20 cl2, #262672
; CHECK-NEXT:    mov.u20 cl0, #514
; CHECK-NEXT:    mov.u20 ch0, #4580
; CHECK-NEXT:    movt.s12 cl1, #1893
; CHECK-NEXT:    movt.s12 cl2, #869
; CHECK-NEXT:    mov.u20 r0, #0
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    vmul.48 bm0, ya.s8, r0, c2, r0, wc0.s8, #0, c1, c0
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <2 x i32> @llvm.aie.v2i32undef()
  %vecins.i = insertelement <2 x i32> %0, i32 911475216, i32 0
  %vecins2.i = insertelement <2 x i32> %0, i32 1985229328, i32 0
  %1 = tail call <16 x i48> @llvm.aie.mul16.v128int8(<128 x i8> %xbuff, <32 x i8> %zbuff, i32 0, i32 0, i32 0, <2 x i32> %vecins.i, <2 x i32> %vecins2.i, <2 x i32> <i32 514, i32 4580>)
  ret <16 x i48> %1
}
define <16 x i48> @_Z12lmul8_v32i32Dv32_iDv8_i(<32 x i32> %xbuff, <8 x i32> %zbuff) {
; CHECK-LABEL: _Z12lmul8_v32i32Dv32_iDv8_i:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.u20 r0, #0
; CHECK-NEXT:    mov.u20 cl0, #274960
; CHECK-NEXT:    mov cl1, r0
; CHECK-NEXT:    movt.s12 cl0, #1893
; CHECK-NEXT:    mov ch1, r0
; CHECK-NEXT:    padda [sp], #32
; CHECK-NEXT:    vmul.80 bm0, ya.s32, r0, c0, r0, wc0.s32, #0, c0, c1
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %0 = tail call <2 x i32> @llvm.aie.v2i32undef()
  %vecins.i = insertelement <2 x i32> %0, i32 1985229328, i32 0
  %1 = tail call <16 x i48> @llvm.aie.lmul8.v32int32(<32 x i32> %xbuff, <8 x i32> %zbuff, i32 0, i32 0, i32 0, <2 x i32> %vecins.i, <2 x i32> %vecins.i, <2 x i32> zeroinitializer)
  ret <16 x i48> %1
}
declare <16 x i48> @llvm.aie.mul16.v32int32(<32 x i32>, <16 x i16>, i32, i32, i32, <2 x i32>, <2 x i32>, <2 x i32>)
declare <2 x i32> @llvm.aie.v2i32undef()
declare <16 x i48> @llvm.aie.mul16.v128int8(<128 x i8>, <32 x i8>, i32, i32, i32, <2 x i32>, <2 x i32>, <2 x i32>)
declare <16 x i48> @llvm.aie.lmul8.v32int32(<32 x i32>, <8 x i32>, i32, i32, i32, <2 x i32>, <2 x i32>, <2 x i32>)
