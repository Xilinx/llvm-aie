; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;
; This file is licensed under the Apache License v2.0 with LLVM Exceptions.
; See https://llvm.org/LICENSE.txt for license information.
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
;
; (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
; RUN: llc -mtriple=aie -tail-merge-size=5 < %s \
; RUN:   | FileCheck %s

; This test contains unconditional branches which fall through to the next
; basic block.  When optimization is turned off, these branches remain and
; this test checks that the target basic blocks retain the correct labels.

source_filename = "1_02.cc"
target datalayout = "e-m:e-p:32:32-i1:8:32-i8:8:32-i16:16:32-i32:32:32-f32:32:32-i64:32-f64:32-a:0:32-n32"
target triple = "aie"

%struct.window_internal = type { i8*, i8*, i8*, i32, i32 }

@buf1 = dso_local local_unnamed_addr global [2 x <4 x i32>] zeroinitializer, align 16
@buf1d = dso_local local_unnamed_addr global [2 x <4 x i32>] zeroinitializer, align 16
@buf2 = dso_local local_unnamed_addr global [2 x <4 x i32>] zeroinitializer, align 16
@buf2d = dso_local local_unnamed_addr global [2 x <4 x i32>] zeroinitializer, align 16

; Function Attrs: noinline nounwind optnone
define void @_ZL11window_initP15window_internaliPaii(%struct.window_internal* inreg %w, i32 inreg %channels, i8* inreg %buffer, i32 inreg %size, i32 %winsize) local_unnamed_addr #0 {
; CHECK-LABEL: _ZL11window_initP15window_internaliPaii:
; CHECK:         .p2align 4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    padda [sp], #32; mov r13, p0; nop
; CHECK-NEXT:    mov p0, r13
; CHECK-NEXT:    mov r12, p1
; CHECK-NEXT:    st.spil p0, [sp, #-32]
; CHECK-NEXT:    mov p0, r12
; CHECK-NEXT:    mov.u20 r12, #0
; CHECK-NEXT:    st.spil r6, [sp, #-28]
; CHECK-NEXT:    st.spil p0, [sp, #-24]
; CHECK-NEXT:    st.spil r7, [sp, #-20]
; CHECK-NEXT:    st.spil r8, [sp, #-16]
; CHECK-NEXT:    st.spil r12, [sp, #-12]
; CHECK-NEXT:    j .LBB0_1
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_1: // %for.cond
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    // Label of block must be emitted
; CHECK-NEXT:    lda.spil r12, [sp, #-12]
; CHECK-NEXT:    lda.spil r13, [sp, #-28]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    ge r12, r12, r13
; CHECK-NEXT:    bnez r12, .LBB0_4
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    j .LBB0_2
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_2: // %for.body
; CHECK-NEXT:    // in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    // Label of block must be emitted
; CHECK-NEXT:    mov.s12 cs0, #8; lda.spil r12, [sp, #-20]
; CHECK-NEXT:    lda.spil r13, [sp, #-12]
; CHECK-NEXT:    lda.spil p0, [sp, #-24]
; CHECK-NEXT:    mov.u20 p2, #20
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mul r12, r12, r13
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov p1, r12
; CHECK-NEXT:    mov r12, p0
; CHECK-NEXT:    lda.spil p0, [sp, #-32]
; CHECK-NEXT:    mov r14, p1
; CHECK-NEXT:    nop ; mov p1, r13; add r12, r12, r14
; CHECK-NEXT:    mov r13, p1
; CHECK-NEXT:    mov r14, p2
; CHECK-NEXT:    nop
; CHECK-NEXT:    mul r13, r13, r14
; CHECK-NEXT:    nop
; CHECK-NEXT:    mov r14, p0
; CHECK-NEXT:    nop ; mov p0, r12; add r13, r14, r13
; CHECK-NEXT:    mov p1, r13
; CHECK-NEXT:    st p0, [p1, cs0]
; CHECK-NEXT:    j .LBB0_3
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_3: // %for.inc
; CHECK-NEXT:    // in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    // Label of block must be emitted
; CHECK-NEXT:    lda.spil r12, [sp, #-12]
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    nop
; CHECK-NEXT:    add r12, r12, #1
; CHECK-NEXT:    st.spil r12, [sp, #-12]
; CHECK-NEXT:    j .LBB0_1
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_4: // %for.end
; CHECK-NEXT:    // Label of block must be emitted
; CHECK-NEXT:    padda [sp], #-32
; CHECK-NEXT:    ret lr
; CHECK-NEXT:    nop // Delay Slot 5
; CHECK-NEXT:    nop // Delay Slot 4
; CHECK-NEXT:    nop // Delay Slot 3
; CHECK-NEXT:    nop // Delay Slot 2
; CHECK-NEXT:    nop // Delay Slot 1
entry:
  %w.addr = alloca %struct.window_internal*, align 4
  %channels.addr = alloca i32, align 4
  %buffer.addr = alloca i8*, align 4
  %size.addr = alloca i32, align 4
  %winsize.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.window_internal* %w, %struct.window_internal** %w.addr, align 4
  store i32 %channels, i32* %channels.addr, align 4
  store i8* %buffer, i8** %buffer.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %winsize, i32* %winsize.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %channels.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i8*, i8** %buffer.addr, align 4
  %3 = load i32, i32* %size.addr, align 4
  %4 = load i32, i32* %i, align 4
  %mul = mul nsw i32 %3, %4
  %add.ptr = getelementptr inbounds i8, i8* %2, i32 %mul
  %5 = load %struct.window_internal*, %struct.window_internal** %w.addr, align 4
  %6 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds %struct.window_internal, %struct.window_internal* %5, i32 %6
  %buffer1 = getelementptr inbounds %struct.window_internal, %struct.window_internal* %arrayidx, i32 0, i32 2
  store i8* %add.ptr, i8** %buffer1, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %t23 = load i32, i32* %i, align 4
  %inc = add nsw i32 %t23, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 9.0.0 (https://stephenn@gitenterprise.xilinx.com/stephenn/llvm-aie.git 7dfbed0513202ff90fdfa49b6fd533758f3be5fc)"}
