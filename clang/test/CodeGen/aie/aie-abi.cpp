// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --return-type --skip-function-body
//===- aie-abi.cpp ----------------------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: %clang_cc1 -triple aie -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -triple aie2 -emit-llvm %s -o - | FileCheck %s

extern "C" {
// CHECK-LABEL: define {{[^@]*}}signext i8 @ret_c
// CHECK-SAME: (i8 noundef signext [[C:%.*]]) #[[ATTR0:[0-9]+]] {
char ret_c(char c) { return c; }

// CHECK-LABEL: define {{[^@]*}}zeroext i8 @ret_uc
// CHECK-SAME: (i8 noundef zeroext [[C:%.*]]) #[[ATTR0:[0-9]+]] {
unsigned char ret_uc(unsigned char c) { return c; }

// CHECK-LABEL: define {{[^@]*}}signext i16 @ret_s
// CHECK-SAME: (i16 noundef signext [[S:%.*]]) #[[ATTR0:[0-9]+]] {
short ret_s(short s) { return s; }

// CHECK-LABEL: define {{[^@]*}}zeroext i16 @ret_us
// CHECK-SAME: (i16 noundef zeroext [[S:%.*]]) #[[ATTR0:[0-9]+]] {
unsigned short ret_us(unsigned short s) { return s; }

// CHECK-LABEL: define {{[^@]*}}i32 @ret_i
// CHECK-SAME: (i32 noundef [[I:%.*]]) #[[ATTR0:[0-9]+]] {
int ret_i(int i) { return i; }

// CHECK-LABEL: define {{[^@]*}}i32 @ret_u
// CHECK-SAME: (i32 noundef [[I:%.*]]) #[[ATTR0:[0-9]+]] {
unsigned ret_u(unsigned int i) { return i; }

// CHECK-LABEL: define {{[^@]*}}i64 @ret_ll
// CHECK-SAME: (i64 noundef [[LL:%.*]]) #[[ATTR0:[0-9]+]] {
long long ret_ll(long long ll) { return ll; }

// CHECK-LABEL: define {{[^@]*}}i64 @ret_ull
// CHECK-SAME: (i64 noundef [[LL:%.*]]) #[[ATTR0:[0-9]+]] {
unsigned long long ret_ull(unsigned long long ll) { return ll; }

// CHECK-LABEL: define {{[^@]*}}float @ret_f
// CHECK-SAME: (float noundef [[F:%.*]]) #[[ATTR0:[0-9]+]] {
float ret_f(float f) { return f; }

// CHECK-LABEL: define {{[^@]*}}double @ret_d
// CHECK-SAME: (double noundef [[D:%.*]]) #[[ATTR0:[0-9]+]] {
double ret_d(double d) { return d; }

// CHECK-LABEL: define {{[^@]*}}double @ret_ld
// CHECK-SAME: (double noundef [[LD:%.*]]) #[[ATTR0:[0-9]+]] {
long double ret_ld(long double ld) { return ld; }

// CHECK-LABEL: define {{[^@]*}}ptr @ret_vptr
// CHECK-SAME: (ptr [[VPTR:%.*]]) #[[ATTR0:[0-9]+]] {
void *ret_vptr(void *vptr) { return vptr; }

// CHECK-LABEL: define {{[^@]*}}ptr @ret_iptr
// CHECK-SAME: (ptr [[IPTR:%.*]]) #[[ATTR0:[0-9]+]] {
int *ret_iptr(int *iptr) { return iptr; }

typedef struct S1 {
  int x;
  int y;
} st1;

// align 4 %agg.result)
// CHECK-LABEL: define {{[^@]*}}%struct.S1 @ret_st1
// CHECK-SAME: () #[[ATTR0:[0-9]+]] {
st1 ret_st1(void) { return {0, 0}; }

// CHECK-LABEL: define {{[^@]*}}i32 @tk_st1
// CHECK-SAME: ([[STRUCT_S1:%.*]] [[S_COERCE:%.*]]) #[[ATTR0:[0-9]+]] {
int tk_st1(st1 s) { return s.x; }

// According to the ABI, there are two 32-bit scalar return registers,
// thus structs >64 bits are interesting
typedef struct S2 {
  int x;
  int y;
  int z;
} st2;

// align 4 %agg.result)
// CHECK-LABEL: define {{[^@]*}}%struct.S2 @ret_st2
// CHECK-SAME: () #[[ATTR0:[0-9]+]] {
st2 ret_st2(void) { return {0, 0}; }

// CHECK-LABEL: define {{[^@]*}}i32 @tk_st2
// CHECK-SAME: ([[STRUCT_S2:%.*]] [[S_COERCE:%.*]]) #[[ATTR0:[0-9]+]] {
int tk_st2(st2 s) { return s.z; }

typedef struct S3 {
  int a;
  int b;
  int c;
  int d;
  int e;
} st3;

// align 4 %agg.result)
// CHECK-LABEL: define {{[^@]*}}void @ret_st3
// CHECK-SAME: (ptr noalias sret([[STRUCT_S3:%.*]]) align 4 [[AGG_RESULT:%.*]]) #[[ATTR0:[0-9]+]] {
st3 ret_st3(void) { return {0, 0, 0, 0, 0}; }

// CHECK-LABEL: define {{[^@]*}}i32 @tk_st3
// CHECK-SAME: ([[STRUCT_S3:%.*]] [[S_COERCE:%.*]]) #[[ATTR0:[0-9]+]] {
int tk_st3(st3 s) { return s.e; }
}
