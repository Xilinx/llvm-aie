// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//===- aie2-addr-intrinsic.cpp ----------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: %clang -O2 %s --target=aie2 -S -emit-llvm -o - | FileCheck %s


// CHECK-LABEL: @_Z14test_byte_incrPDv32_si(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[IDX_EXT_I:%.*]] = trunc i32 [[INCR:%.*]] to i20
// CHECK-NEXT:    [[ADD_PTR_I:%.*]] = getelementptr inbounds i8, ptr [[A:%.*]], i20 [[IDX_EXT_I]]
// CHECK-NEXT:    ret ptr [[ADD_PTR_I]]
//
v32int16* test_byte_incr(v32int16* a, int incr){
   return byte_incr(a,incr);
}

// CHECK-LABEL: @_Z15test_add_2d_ptrPDv16_iiiRii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MUL_I:%.*]] = shl i32 [[OFF:%.*]], 6
// CHECK-NEXT:    [[TMP0:%.*]] = trunc i32 [[MUL_I]] to i20
// CHECK-NEXT:    [[MUL1_I:%.*]] = shl i32 [[INC1:%.*]], 6
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i32 [[MUL1_I]] to i20
// CHECK-NEXT:    [[TMP2:%.*]] = trunc i32 [[SIZE1:%.*]] to i20
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[COUNT1:%.*]], align 4, !tbaa [[TBAA2:![0-9]+]]
// CHECK-NEXT:    [[TMP4:%.*]] = trunc i32 [[TMP3]] to i20
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, i20 } @llvm.aie2.add.2d(ptr [[A:%.*]], i20 [[TMP0]], i20 [[TMP1]], i20 [[TMP2]], i20 [[TMP4]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, i20 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP7:%.*]] = zext i20 [[TMP6]] to i32
// CHECK-NEXT:    store i32 [[TMP7]], ptr [[COUNT1]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, i20 } [[TMP5]], 0
// CHECK-NEXT:    ret ptr [[TMP8]]
//
v16int32* test_add_2d_ptr(v16int32* a, int off, int size1, addr_t& count1, int inc1){
    return add_2d_ptr(a,off,size1,count1,inc1);
}

// CHECK-LABEL: @_Z15test_add_2d_ptrPKDv16_iiiRii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MUL_I:%.*]] = shl i32 [[OFF:%.*]], 6
// CHECK-NEXT:    [[TMP0:%.*]] = trunc i32 [[MUL_I]] to i20
// CHECK-NEXT:    [[MUL1_I:%.*]] = shl i32 [[INC1:%.*]], 6
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i32 [[MUL1_I]] to i20
// CHECK-NEXT:    [[TMP2:%.*]] = trunc i32 [[SIZE1:%.*]] to i20
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[COUNT1:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP4:%.*]] = trunc i32 [[TMP3]] to i20
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, i20 } @llvm.aie2.add.2d(ptr [[A:%.*]], i20 [[TMP0]], i20 [[TMP1]], i20 [[TMP2]], i20 [[TMP4]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, i20 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP7:%.*]] = zext i20 [[TMP6]] to i32
// CHECK-NEXT:    store i32 [[TMP7]], ptr [[COUNT1]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, i20 } [[TMP5]], 0
// CHECK-NEXT:    ret ptr [[TMP8]]
//
const v16int32* test_add_2d_ptr(const v16int32* a, int off, int size1, addr_t& count1, int inc1){
    return add_2d_ptr(a,off,size1,count1,inc1);
}


// CHECK-LABEL: @_Z16test_add_2d_bytePDv16_iiiRii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = trunc i32 [[OFF:%.*]] to i20
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i32 [[INC1:%.*]] to i20
// CHECK-NEXT:    [[TMP2:%.*]] = trunc i32 [[SIZE1:%.*]] to i20
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[COUNT1:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP4:%.*]] = trunc i32 [[TMP3]] to i20
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, i20 } @llvm.aie2.add.2d(ptr [[A:%.*]], i20 [[TMP0]], i20 [[TMP1]], i20 [[TMP2]], i20 [[TMP4]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, i20 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP7:%.*]] = zext i20 [[TMP6]] to i32
// CHECK-NEXT:    store i32 [[TMP7]], ptr [[COUNT1]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, i20 } [[TMP5]], 0
// CHECK-NEXT:    ret ptr [[TMP8]]
//
v16int32* test_add_2d_byte(v16int32* a, int off, int size1, addr_t& count1, int inc1){
    return add_2d_byte(a,off,size1,count1,inc1);
}

// CHECK-LABEL: @_Z16test_add_2d_bytePKDv16_iiiRii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = trunc i32 [[OFF:%.*]] to i20
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i32 [[INC1:%.*]] to i20
// CHECK-NEXT:    [[TMP2:%.*]] = trunc i32 [[SIZE1:%.*]] to i20
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[COUNT1:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP4:%.*]] = trunc i32 [[TMP3]] to i20
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, i20 } @llvm.aie2.add.2d(ptr [[A:%.*]], i20 [[TMP0]], i20 [[TMP1]], i20 [[TMP2]], i20 [[TMP4]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, i20 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP7:%.*]] = zext i20 [[TMP6]] to i32
// CHECK-NEXT:    store i32 [[TMP7]], ptr [[COUNT1]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, i20 } [[TMP5]], 0
// CHECK-NEXT:    ret ptr [[TMP8]]
//
const v16int32* test_add_2d_byte(const v16int32* a, int off, int size1, addr_t& count1, int inc1){
    return add_2d_byte(a,off,size1,count1,inc1);
}

// CHECK-LABEL: @_Z15test_add_3d_ptrPDv16_iiiRiiiS1_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MUL_I:%.*]] = shl i32 [[OFF:%.*]], 6
// CHECK-NEXT:    [[TMP0:%.*]] = trunc i32 [[MUL_I]] to i20
// CHECK-NEXT:    [[MUL1_I:%.*]] = shl i32 [[INC1:%.*]], 6
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i32 [[MUL1_I]] to i20
// CHECK-NEXT:    [[MUL2_I:%.*]] = shl i32 [[INC2:%.*]], 6
// CHECK-NEXT:    [[TMP2:%.*]] = trunc i32 [[MUL2_I]] to i20
// CHECK-NEXT:    [[TMP3:%.*]] = trunc i32 [[SIZE1:%.*]] to i20
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[COUNT1:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP4]] to i20
// CHECK-NEXT:    [[TMP6:%.*]] = trunc i32 [[SIZE2:%.*]] to i20
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[COUNT2:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP8:%.*]] = trunc i32 [[TMP7]] to i20
// CHECK-NEXT:    [[TMP9:%.*]] = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr [[A:%.*]], i20 [[TMP0]], i20 [[TMP1]], i20 [[TMP2]], i20 [[TMP3]], i20 [[TMP5]], i20 [[TMP6]], i20 [[TMP8]])
// CHECK-NEXT:    [[TMP10:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 1
// CHECK-NEXT:    [[TMP11:%.*]] = zext i20 [[TMP10]] to i32
// CHECK-NEXT:    [[TMP12:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 2
// CHECK-NEXT:    [[TMP13:%.*]] = zext i20 [[TMP12]] to i32
// CHECK-NEXT:    store i32 [[TMP11]], ptr [[COUNT1]], align 4
// CHECK-NEXT:    store i32 [[TMP13]], ptr [[COUNT2]], align 4
// CHECK-NEXT:    [[TMP14:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 0
// CHECK-NEXT:    ret ptr [[TMP14]]
//
v16int32* test_add_3d_ptr(v16int32* a, int off, int size1, addr_t& count1, int inc1, int size2, addr_t& count2, int inc2){
    return add_3d_ptr(a,off,size1,count1,inc1,size2,count2,inc2);
}


// CHECK-LABEL: @_Z15test_add_3d_ptrPKDv16_iiiRiiiS2_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MUL_I:%.*]] = shl i32 [[OFF:%.*]], 6
// CHECK-NEXT:    [[TMP0:%.*]] = trunc i32 [[MUL_I]] to i20
// CHECK-NEXT:    [[MUL1_I:%.*]] = shl i32 [[INC1:%.*]], 6
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i32 [[MUL1_I]] to i20
// CHECK-NEXT:    [[MUL2_I:%.*]] = shl i32 [[INC2:%.*]], 6
// CHECK-NEXT:    [[TMP2:%.*]] = trunc i32 [[MUL2_I]] to i20
// CHECK-NEXT:    [[TMP3:%.*]] = trunc i32 [[SIZE1:%.*]] to i20
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[COUNT1:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP4]] to i20
// CHECK-NEXT:    [[TMP6:%.*]] = trunc i32 [[SIZE2:%.*]] to i20
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[COUNT2:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP8:%.*]] = trunc i32 [[TMP7]] to i20
// CHECK-NEXT:    [[TMP9:%.*]] = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr [[A:%.*]], i20 [[TMP0]], i20 [[TMP1]], i20 [[TMP2]], i20 [[TMP3]], i20 [[TMP5]], i20 [[TMP6]], i20 [[TMP8]])
// CHECK-NEXT:    [[TMP10:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 1
// CHECK-NEXT:    [[TMP11:%.*]] = zext i20 [[TMP10]] to i32
// CHECK-NEXT:    [[TMP12:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 2
// CHECK-NEXT:    [[TMP13:%.*]] = zext i20 [[TMP12]] to i32
// CHECK-NEXT:    store i32 [[TMP11]], ptr [[COUNT1]], align 4
// CHECK-NEXT:    store i32 [[TMP13]], ptr [[COUNT2]], align 4
// CHECK-NEXT:    [[TMP14:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 0
// CHECK-NEXT:    ret ptr [[TMP14]]
//
const v16int32* test_add_3d_ptr(const v16int32* a, int off, int size1, addr_t& count1, int inc1, int size2, addr_t& count2, int inc2){
    return add_3d_ptr(a,off,size1,count1,inc1,size2,count2,inc2);
}


// CHECK-LABEL: @_Z16test_add_3d_bytePDv16_iiiRiiiS1_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = trunc i32 [[OFF:%.*]] to i20
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i32 [[INC1:%.*]] to i20
// CHECK-NEXT:    [[TMP2:%.*]] = trunc i32 [[INC2:%.*]] to i20
// CHECK-NEXT:    [[TMP3:%.*]] = trunc i32 [[SIZE1:%.*]] to i20
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[COUNT1:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP4]] to i20
// CHECK-NEXT:    [[TMP6:%.*]] = trunc i32 [[SIZE2:%.*]] to i20
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[COUNT2:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP8:%.*]] = trunc i32 [[TMP7]] to i20
// CHECK-NEXT:    [[TMP9:%.*]] = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr [[A:%.*]], i20 [[TMP0]], i20 [[TMP1]], i20 [[TMP2]], i20 [[TMP3]], i20 [[TMP5]], i20 [[TMP6]], i20 [[TMP8]])
// CHECK-NEXT:    [[TMP10:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 1
// CHECK-NEXT:    [[TMP11:%.*]] = zext i20 [[TMP10]] to i32
// CHECK-NEXT:    [[TMP12:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 2
// CHECK-NEXT:    [[TMP13:%.*]] = zext i20 [[TMP12]] to i32
// CHECK-NEXT:    store i32 [[TMP11]], ptr [[COUNT1]], align 4
// CHECK-NEXT:    store i32 [[TMP13]], ptr [[COUNT2]], align 4
// CHECK-NEXT:    [[TMP14:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 0
// CHECK-NEXT:    ret ptr [[TMP14]]
//
v16int32* test_add_3d_byte(v16int32* a, int off, int size1, addr_t& count1, int inc1, int size2, addr_t& count2, int inc2){
    return add_3d_byte(a,off,size1,count1,inc1,size2,count2,inc2);
}

// CHECK-LABEL: @_Z16test_add_3d_bytePKDv16_iiiRiiiS2_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = trunc i32 [[OFF:%.*]] to i20
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i32 [[INC1:%.*]] to i20
// CHECK-NEXT:    [[TMP2:%.*]] = trunc i32 [[INC2:%.*]] to i20
// CHECK-NEXT:    [[TMP3:%.*]] = trunc i32 [[SIZE1:%.*]] to i20
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[COUNT1:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP4]] to i20
// CHECK-NEXT:    [[TMP6:%.*]] = trunc i32 [[SIZE2:%.*]] to i20
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[COUNT2:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP8:%.*]] = trunc i32 [[TMP7]] to i20
// CHECK-NEXT:    [[TMP9:%.*]] = tail call { ptr, i20, i20 } @llvm.aie2.add.3d(ptr [[A:%.*]], i20 [[TMP0]], i20 [[TMP1]], i20 [[TMP2]], i20 [[TMP3]], i20 [[TMP5]], i20 [[TMP6]], i20 [[TMP8]])
// CHECK-NEXT:    [[TMP10:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 1
// CHECK-NEXT:    [[TMP11:%.*]] = zext i20 [[TMP10]] to i32
// CHECK-NEXT:    [[TMP12:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 2
// CHECK-NEXT:    [[TMP13:%.*]] = zext i20 [[TMP12]] to i32
// CHECK-NEXT:    store i32 [[TMP11]], ptr [[COUNT1]], align 4
// CHECK-NEXT:    store i32 [[TMP13]], ptr [[COUNT2]], align 4
// CHECK-NEXT:    [[TMP14:%.*]] = extractvalue { ptr, i20, i20 } [[TMP9]], 0
// CHECK-NEXT:    ret ptr [[TMP14]]
//
const v16int32* test_add_3d_byte(const v16int32* a, int off, int size1, addr_t& count1, int inc1, int size2, addr_t& count2, int inc2){
    return add_3d_byte(a,off,size1,count1,inc1,size2,count2,inc2);
}
