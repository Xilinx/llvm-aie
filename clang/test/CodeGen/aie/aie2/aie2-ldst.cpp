// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//===- aie2-ldst.cpp --------------------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: %clang -O2 %s --target=aie2 -S -emit-llvm -o - | FileCheck %s

// CHECK-LABEL: @_Z9test_packDv32_si(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x i8> @llvm.aie2.pack(<32 x i16> [[V:%.*]], i32 [[SIGN:%.*]], i32 1)
// CHECK-NEXT:    ret <32 x i8> [[TMP0]]
//
v32int8 test_pack(v32int16 v, int sign) {
  return pack(v, sign);
}

// CHECK-LABEL: @_Z9test_packDv32_ti(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x i8> @llvm.aie2.pack(<32 x i16> [[V:%.*]], i32 [[SIGN:%.*]], i32 1)
// CHECK-NEXT:    ret <32 x i8> [[TMP0]]
//
v32uint8 test_pack(v32uint16 v, int sign) {
  return pack(v, sign);
}

//
// CHECK-LABEL: @_Z9test_packDv64_ai(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[V:%.*]] to <32 x i16>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call noundef <32 x i8> @llvm.aie2.pack(<32 x i16> [[TMP0]], i32 [[SIGN:%.*]], i32 0)
// CHECK-NEXT:    ret <32 x i8> [[TMP1]]
//
v64int4 test_pack(v64int8 v, int sign) {
  return pack(v, sign);
}

// CHECK-LABEL: @_Z9test_packDv64_hi(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[V:%.*]] to <32 x i16>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call noundef <32 x i8> @llvm.aie2.pack(<32 x i16> [[TMP0]], i32 [[SIGN:%.*]], i32 0)
// CHECK-NEXT:    ret <32 x i8> [[TMP1]]
//
v64uint4 test_pack(v64uint8 v, int sign) {
  return pack(v, sign);
}

// CHECK-LABEL: @_Z9test_packDv32_s(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x i8> @llvm.aie2.pack(<32 x i16> [[V:%.*]], i32 1, i32 1)
// CHECK-NEXT:    ret <32 x i8> [[TMP0]]
//
v32int8 test_pack(v32int16 v) {
  return pack(v);
}

// CHECK-LABEL: @_Z9test_packDv32_t(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x i8> @llvm.aie2.pack(<32 x i16> [[V:%.*]], i32 0, i32 1)
// CHECK-NEXT:    ret <32 x i8> [[TMP0]]
//
v32uint8 test_pack(v32uint16 v) {
  return pack(v);
}

// CHECK-LABEL: @_Z9test_packDv64_a(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[V:%.*]] to <32 x i16>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call noundef <32 x i8> @llvm.aie2.pack(<32 x i16> [[TMP0]], i32 1, i32 0)
// CHECK-NEXT:    ret <32 x i8> [[TMP1]]
//
v64int4 test_pack(v64int8 v) {
  return pack(v);
}

// CHECK-LABEL: @_Z9test_packDv64_h(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[V:%.*]] to <32 x i16>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call noundef <32 x i8> @llvm.aie2.pack(<32 x i16> [[TMP0]], i32 0, i32 0)
// CHECK-NEXT:    ret <32 x i8> [[TMP1]]
//
v64uint4 test_pack(v64uint8 v) {
  return pack(v);
}

// CHECK-LABEL: @_Z11test_unpackDv32_ab(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CONV_I:%.*]] = zext i1 [[SIGN:%.*]] to i32
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x i16> @llvm.aie2.unpack(<32 x i8> [[V:%.*]], i32 [[CONV_I]], i32 1)
// CHECK-NEXT:    ret <32 x i16> [[TMP0]]
//
v32int16 test_unpack(v32int8 v, bool sign) {
  return unpack(v, sign);
}

// CHECK-LABEL: @_Z11test_unpackDv32_hb(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CONV_I:%.*]] = zext i1 [[SIGN:%.*]] to i32
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x i16> @llvm.aie2.unpack(<32 x i8> [[V:%.*]], i32 [[CONV_I]], i32 1)
// CHECK-NEXT:    ret <32 x i16> [[TMP0]]
//
v32uint16 test_unpack(v32uint8 v, bool sign) {
  return unpack(v, sign);
}

// CHECK-LABEL: @_Z11test_unpackDv32_DB8_b(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CONV_I:%.*]] = zext i1 [[SIGN:%.*]] to i32
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <32 x i16> @llvm.aie2.unpack(<32 x i8> [[V:%.*]], i32 [[CONV_I]], i32 0)
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x i16> [[TMP0]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[TMP1]]
//
v64int8 test_unpack(v64int4 v, bool sign) {
  return unpack(v, sign);
}

// CHECK-LABEL: @_Z11test_unpackDv32_DU8_b(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CONV_I:%.*]] = zext i1 [[SIGN:%.*]] to i32
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <32 x i16> @llvm.aie2.unpack(<32 x i8> [[V:%.*]], i32 [[CONV_I]], i32 0)
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x i16> [[TMP0]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[TMP1]]
//
v64uint8 test_unpack(v64uint4 v, bool sign) {
  return unpack(v, sign);
}

// CHECK-LABEL: @_Z11test_unpackDv32_a(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x i16> @llvm.aie2.unpack(<32 x i8> [[V:%.*]], i32 1, i32 1)
// CHECK-NEXT:    ret <32 x i16> [[TMP0]]
//
v32int16 test_unpack(v32int8 v) {
  return unpack(v);
}

// CHECK-LABEL: @_Z11test_unpackDv32_h(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x i16> @llvm.aie2.unpack(<32 x i8> [[V:%.*]], i32 0, i32 1)
// CHECK-NEXT:    ret <32 x i16> [[TMP0]]
//
v32uint16 test_unpack(v32uint8 v) {
  return unpack(v);
}

// CHECK-LABEL: @_Z11test_unpackDv32_DB8_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <32 x i16> @llvm.aie2.unpack(<32 x i8> [[V:%.*]], i32 1, i32 0)
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x i16> [[TMP0]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[TMP1]]
//
v64int8 test_unpack(v64int4 v) {
  return unpack(v);
}

// CHECK-LABEL: @_Z11test_unpackDv32_DU8_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <32 x i16> @llvm.aie2.unpack(<32 x i8> [[V:%.*]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x i16> [[TMP0]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[TMP1]]
//
v64uint8 test_unpack(v64uint4 v) {
  return unpack(v);
}
