// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang -O2 %s --target=aie2 -S -emit-llvm -o - | FileCheck %s


/*v64int16_sparse*/
// CHECK-LABEL: @_Z15test_sparse_popRP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.pop.16.set.lo(<32 x i16> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.pop.16.insert.hi(<32 x i16> undef, i128 undef, <32 x i16> [[TMP3]], i128 [[TMP4]], ptr [[TMP2]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP5]], 0
// CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP5]], 2
// CHECK-NEXT:    store ptr [[TMP6]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE:%.*]] poison, <32 x i16> [[TMP7]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP8]], 1
// CHECK-NEXT:    ret [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64int16_sparse test_sparse_pop(v64int16_sparse_compress *& p){
    return sparse_pop(p);
}
// CHECK-LABEL: @_Z22test_sparse_pop_set_loRP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.pop.16.set.lo(<32 x i16> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE:%.*]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64int16_sparse test_sparse_pop_set_lo(v64int16_sparse_compress *& p){
    return sparse_pop_set_lo(p);
}
// CHECK-LABEL: @_Z25test_sparse_pop_insert_hi15v64int16_sparseS_RP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64INT16_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64INT16_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.pop.16.insert.hi(<32 x i16> undef, i128 undef, <32 x i16> [[VEC_COERCE_FCA_0_EXTRACT_I]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64int16_sparse test_sparse_pop_insert_hi(v64int16_sparse qx0, v64int16_sparse qx, v64int16_sparse_compress *& p){
    return sparse_pop_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z31test_sparse_pop_and_get_pointerRP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.pop.16.and.get.pointer(<32 x i16> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE:%.*]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64int16_sparse test_sparse_pop_and_get_pointer(v64int16_sparse_compress *& p){
    return sparse_pop_and_get_pointer(p);
}

// CHECK-LABEL: @_Z23test_sparse_peek_set_loRP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.peek.16.set.lo(<32 x i16> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE:%.*]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64int16_sparse test_sparse_peek_set_lo(v64int16_sparse_compress *& p){
    return sparse_peek_set_lo(p);
}
// CHECK-LABEL: @_Z26test_sparse_peek_insert_hi15v64int16_sparseS_RP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64INT16_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64INT16_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.peek.16.insert.hi(<32 x i16> undef, i128 undef, <32 x i16> [[VEC_COERCE_FCA_0_EXTRACT_I]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64int16_sparse test_sparse_peek_insert_hi(v64int16_sparse qx0, v64int16_sparse qx, v64int16_sparse_compress *& p){
    return sparse_peek_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z32test_sparse_peek_and_get_pointerRP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.peek.16.and.get.pointer(<32 x i16> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE:%.*]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64INT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64int16_sparse test_sparse_peek_and_get_pointer(v64int16_sparse_compress *& p){
    return sparse_peek_and_get_pointer(p);
}

// CHECK-LABEL: @_Z17test_sparse_resetRP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.16(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset(v64int16_sparse_compress *& p){
    sparse_reset(p);
}
// CHECK-LABEL: @_Z33test_sparse_reset_and_get_pointerRP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.16.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset_and_get_pointer(v64int16_sparse_compress *& p){
    sparse_reset_and_get_pointer(p);
}

// CHECK-LABEL: @_Z16test_sparse_fillRP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.16(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill(v64int16_sparse_compress *& p){
    return sparse_fill(p);
}
// CHECK-LABEL: @_Z32test_sparse_fill_and_get_pointerRP24v64int16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.16.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill_and_get_pointer(v64int16_sparse_compress *& p){
    return sparse_fill_and_get_pointer(p);
}

/*v64uint16_sparse*/
// CHECK-LABEL: @_Z15test_sparse_popRP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.pop.16.set.lo(<32 x i16> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.pop.16.insert.hi(<32 x i16> undef, i128 undef, <32 x i16> [[TMP3]], i128 [[TMP4]], ptr [[TMP2]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP5]], 0
// CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP5]], 2
// CHECK-NEXT:    store ptr [[TMP6]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE:%.*]] poison, <32 x i16> [[TMP7]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP8]], 1
// CHECK-NEXT:    ret [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64uint16_sparse test_sparse_pop(v64uint16_sparse_compress *& p){
    return sparse_pop(p);
}
// CHECK-LABEL: @_Z22test_sparse_pop_set_loRP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.pop.16.set.lo(<32 x i16> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE:%.*]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64uint16_sparse test_sparse_pop_set_lo(v64uint16_sparse_compress *& p){
    return sparse_pop_set_lo(p);
}
// CHECK-LABEL: @_Z25test_sparse_pop_insert_hi16v64uint16_sparseS_RP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64UINT16_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64UINT16_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.pop.16.insert.hi(<32 x i16> undef, i128 undef, <32 x i16> [[VEC_COERCE_FCA_0_EXTRACT_I]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64uint16_sparse test_sparse_pop_insert_hi(v64uint16_sparse qx0, v64uint16_sparse qx, v64uint16_sparse_compress *& p){
    return sparse_pop_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z31test_sparse_pop_and_get_pointerRP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.pop.16.and.get.pointer(<32 x i16> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE:%.*]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64uint16_sparse test_sparse_pop_and_get_pointer(v64uint16_sparse_compress *& p){
    return sparse_pop_and_get_pointer(p);
}

// CHECK-LABEL: @_Z23test_sparse_peek_set_loRP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.peek.16.set.lo(<32 x i16> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE:%.*]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64uint16_sparse test_sparse_peek_set_lo(v64uint16_sparse_compress *& p){
    return sparse_peek_set_lo(p);
}
// CHECK-LABEL: @_Z26test_sparse_peek_insert_hi16v64uint16_sparseS_RP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64UINT16_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64UINT16_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.peek.16.insert.hi(<32 x i16> undef, i128 undef, <32 x i16> [[VEC_COERCE_FCA_0_EXTRACT_I]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64uint16_sparse test_sparse_peek_insert_hi(v64uint16_sparse qx0, v64uint16_sparse qx, v64uint16_sparse_compress *& p){
    return sparse_peek_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z32test_sparse_peek_and_get_pointerRP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x i16>, i128 } @llvm.aie2.sparse.peek.16.and.get.pointer(<32 x i16> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x i16>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE:%.*]] poison, <32 x i16> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64UINT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64uint16_sparse test_sparse_peek_and_get_pointer(v64uint16_sparse_compress *& p){
    return sparse_peek_and_get_pointer(p);
}

// CHECK-LABEL: @_Z17test_sparse_resetRP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.16(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset(v64uint16_sparse_compress *& p){
    sparse_reset(p);
}
// CHECK-LABEL: @_Z33test_sparse_reset_and_get_pointerRP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.16.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset_and_get_pointer(v64uint16_sparse_compress *& p){
    sparse_reset_and_get_pointer(p);
}

// CHECK-LABEL: @_Z16test_sparse_fillRP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.16(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill(v64uint16_sparse_compress *& p){
    return sparse_fill(p);
}
// CHECK-LABEL: @_Z32test_sparse_fill_and_get_pointerRP25v64uint16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.16.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill_and_get_pointer(v64uint16_sparse_compress *& p){
    return sparse_fill_and_get_pointer(p);
}

/*v128int8_sparse*/
// CHECK-LABEL: @_Z15test_sparse_popRP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.pop.8.set.lo(<64 x i8> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.pop.8.insert.hi(<64 x i8> undef, i128 undef, <64 x i8> [[TMP3]], i128 [[TMP4]], ptr [[TMP2]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP5]], 0
// CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP5]], 2
// CHECK-NEXT:    store ptr [[TMP6]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE:%.*]] poison, <64 x i8> [[TMP7]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP8]], 1
// CHECK-NEXT:    ret [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128int8_sparse test_sparse_pop(v128int8_sparse_compress *& p){
    return sparse_pop(p);
}
// CHECK-LABEL: @_Z22test_sparse_pop_set_loRP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.pop.8.set.lo(<64 x i8> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE:%.*]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128int8_sparse test_sparse_pop_set_lo(v128int8_sparse_compress *& p){
    return sparse_pop_set_lo(p);
}
// CHECK-LABEL: @_Z25test_sparse_pop_insert_hi15v128int8_sparseS_RP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V128INT8_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V128INT8_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.pop.8.insert.hi(<64 x i8> undef, i128 undef, <64 x i8> [[VEC_COERCE_FCA_0_EXTRACT_I]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128int8_sparse test_sparse_pop_insert_hi(v128int8_sparse qx0, v128int8_sparse qx, v128int8_sparse_compress *& p){
    return sparse_pop_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z31test_sparse_pop_and_get_pointerRP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.pop.8.and.get.pointer(<64 x i8> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE:%.*]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128int8_sparse test_sparse_pop_and_get_pointer(v128int8_sparse_compress *& p){
    return sparse_pop_and_get_pointer(p);
}

// CHECK-LABEL: @_Z23test_sparse_peek_set_loRP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.peek.8.set.lo(<64 x i8> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE:%.*]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128int8_sparse test_sparse_peek_set_lo(v128int8_sparse_compress *& p){
    return sparse_peek_set_lo(p);
}
// CHECK-LABEL: @_Z26test_sparse_peek_insert_hi15v128int8_sparseS_RP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V128INT8_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V128INT8_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.peek.8.insert.hi(<64 x i8> undef, i128 undef, <64 x i8> [[VEC_COERCE_FCA_0_EXTRACT_I]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128int8_sparse test_sparse_peek_insert_hi(v128int8_sparse qx0, v128int8_sparse qx, v128int8_sparse_compress *& p){
    return sparse_peek_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z32test_sparse_peek_and_get_pointerRP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.peek.8.and.get.pointer(<64 x i8> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE:%.*]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128INT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128int8_sparse test_sparse_peek_and_get_pointer(v128int8_sparse_compress *& p){
    return sparse_peek_and_get_pointer(p);
}
// CHECK-LABEL: @_Z17test_sparse_resetRP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.8(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset(v128int8_sparse_compress *& p){
    sparse_reset(p);
}
// CHECK-LABEL: @_Z33test_sparse_reset_and_get_pointerRP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.8.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset_and_get_pointer(v128int8_sparse_compress *& p){
    sparse_reset_and_get_pointer(p);
}

// CHECK-LABEL: @_Z16test_sparse_fillRP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.8(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill(v128int8_sparse_compress *& p){
    return sparse_fill(p);
}
// CHECK-LABEL: @_Z32test_sparse_fill_and_get_pointerRP24v128int8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.8.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill_and_get_pointer(v128int8_sparse_compress *& p){
    return sparse_fill_and_get_pointer(p);
}

/*v128uint8_sparse*/
// CHECK-LABEL: @_Z15test_sparse_popRP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.pop.8.set.lo(<64 x i8> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.pop.8.insert.hi(<64 x i8> undef, i128 undef, <64 x i8> [[TMP3]], i128 [[TMP4]], ptr [[TMP2]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP5]], 0
// CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP5]], 2
// CHECK-NEXT:    store ptr [[TMP6]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE:%.*]] poison, <64 x i8> [[TMP7]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP8]], 1
// CHECK-NEXT:    ret [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128uint8_sparse test_sparse_pop(v128uint8_sparse_compress *& p){
    return sparse_pop(p);
}
// CHECK-LABEL: @_Z22test_sparse_pop_set_loRP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.pop.8.set.lo(<64 x i8> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE:%.*]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128uint8_sparse test_sparse_pop_set_lo(v128uint8_sparse_compress *& p){
    return sparse_pop_set_lo(p);
}
// CHECK-LABEL: @_Z25test_sparse_pop_insert_hi16v128uint8_sparseS_RP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V128UINT8_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V128UINT8_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.pop.8.insert.hi(<64 x i8> undef, i128 undef, <64 x i8> [[VEC_COERCE_FCA_0_EXTRACT_I]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128uint8_sparse test_sparse_pop_insert_hi(v128uint8_sparse qx0, v128uint8_sparse qx, v128uint8_sparse_compress *& p){
    return sparse_pop_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z31test_sparse_pop_and_get_pointerRP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.pop.8.and.get.pointer(<64 x i8> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE:%.*]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128uint8_sparse test_sparse_pop_and_get_pointer(v128uint8_sparse_compress *& p){
    return sparse_pop_and_get_pointer(p);
}

// CHECK-LABEL: @_Z23test_sparse_peek_set_loRP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.peek.8.set.lo(<64 x i8> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE:%.*]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128uint8_sparse test_sparse_peek_set_lo(v128uint8_sparse_compress *& p){
    return sparse_peek_set_lo(p);
}
// CHECK-LABEL: @_Z26test_sparse_peek_insert_hi16v128uint8_sparseS_RP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V128UINT8_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V128UINT8_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.peek.8.insert.hi(<64 x i8> undef, i128 undef, <64 x i8> [[VEC_COERCE_FCA_0_EXTRACT_I]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128uint8_sparse test_sparse_peek_insert_hi(v128uint8_sparse qx0, v128uint8_sparse qx, v128uint8_sparse_compress *& p){
    return sparse_peek_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z32test_sparse_peek_and_get_pointerRP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <64 x i8>, i128 } @llvm.aie2.sparse.peek.8.and.get.pointer(<64 x i8> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <64 x i8>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE:%.*]] poison, <64 x i8> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V128UINT8_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v128uint8_sparse test_sparse_peek_and_get_pointer(v128uint8_sparse_compress *& p){
    return sparse_peek_and_get_pointer(p);
}
// CHECK-LABEL: @_Z17test_sparse_resetRP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.8(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset(v128uint8_sparse_compress *& p){
    sparse_reset(p);
}
// CHECK-LABEL: @_Z33test_sparse_reset_and_get_pointerRP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.8.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset_and_get_pointer(v128uint8_sparse_compress *& p){
    sparse_reset_and_get_pointer(p);
}

// CHECK-LABEL: @_Z16test_sparse_fillRP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.8(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill(v128uint8_sparse_compress *& p){
    return sparse_fill(p);
}
// CHECK-LABEL: @_Z32test_sparse_fill_and_get_pointerRP25v128uint8_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.8.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill_and_get_pointer(v128uint8_sparse_compress *& p){
    return sparse_fill_and_get_pointer(p);
}

/*v256int4_sparse*/
// CHECK-LABEL: @_Z15test_sparse_popRP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.pop.4.set.lo(<16 x i32> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.pop.4.insert.hi(<16 x i32> undef, i128 undef, <16 x i32> [[TMP3]], i128 [[TMP4]], ptr [[TMP2]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP5]], 0
// CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP5]], 2
// CHECK-NEXT:    store ptr [[TMP6]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP9:%.*]] = bitcast <16 x i32> [[TMP7]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE:%.*]] poison, <64 x i8> [[TMP9]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP8]], 1
// CHECK-NEXT:    ret [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256int4_sparse test_sparse_pop(v256int4_sparse_compress *& p){
    return sparse_pop(p);
}
// CHECK-LABEL: @_Z22test_sparse_pop_set_loRP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.pop.4.set.lo(<16 x i32> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <16 x i32> [[TMP3]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE:%.*]] poison, <64 x i8> [[TMP5]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256int4_sparse test_sparse_pop_set_lo(v256int4_sparse_compress *& p){
    return sparse_pop_set_lo(p);
}
//
// CHECK-LABEL: @_Z25test_sparse_pop_insert_hi15v256int4_sparseS_RP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V256INT4_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[VEC_COERCE_FCA_0_EXTRACT_I]] to <16 x i32>
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V256INT4_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP2:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.pop.4.insert.hi(<16 x i32> undef, i128 undef, <16 x i32> [[TMP0]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP1]])
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 0
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 1
// CHECK-NEXT:    [[TMP5:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 2
// CHECK-NEXT:    store ptr [[TMP3]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = bitcast <16 x i32> [[TMP4]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE]] poison, <64 x i8> [[TMP6]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP5]], 1
// CHECK-NEXT:    ret [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256int4_sparse test_sparse_pop_insert_hi(v256int4_sparse qx0, v256int4_sparse qx, v256int4_sparse_compress *& p){
    return sparse_pop_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z31test_sparse_pop_and_get_pointerRP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.pop.4.and.get.pointer(<16 x i32> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <16 x i32> [[TMP3]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE:%.*]] poison, <64 x i8> [[TMP5]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256int4_sparse test_sparse_pop_and_get_pointer(v256int4_sparse_compress *& p){
    return sparse_pop_and_get_pointer(p);
}

// CHECK-LABEL: @_Z23test_sparse_peek_set_loRP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.peek.4.set.lo(<16 x i32> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <16 x i32> [[TMP3]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE:%.*]] poison, <64 x i8> [[TMP5]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256int4_sparse test_sparse_peek_set_lo(v256int4_sparse_compress *& p){
    return sparse_peek_set_lo(p);
}
// CHECK-LABEL: @_Z26test_sparse_peek_insert_hi15v256int4_sparseS_RP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V256INT4_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[VEC_COERCE_FCA_0_EXTRACT_I]] to <16 x i32>
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V256INT4_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP2:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.peek.4.insert.hi(<16 x i32> undef, i128 undef, <16 x i32> [[TMP0]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP1]])
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 0
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 1
// CHECK-NEXT:    [[TMP5:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 2
// CHECK-NEXT:    store ptr [[TMP3]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = bitcast <16 x i32> [[TMP4]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE]] poison, <64 x i8> [[TMP6]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP5]], 1
// CHECK-NEXT:    ret [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256int4_sparse test_sparse_peek_insert_hi(v256int4_sparse qx0, v256int4_sparse qx, v256int4_sparse_compress *& p){
    return sparse_peek_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z32test_sparse_peek_and_get_pointerRP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.peek.4.and.get.pointer(<16 x i32> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <16 x i32> [[TMP3]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE:%.*]] poison, <64 x i8> [[TMP5]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V256INT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256int4_sparse test_sparse_peek_and_get_pointer(v256int4_sparse_compress *& p){
    return sparse_peek_and_get_pointer(p);
}
// CHECK-LABEL: @_Z17test_sparse_resetRP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.4(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset(v256int4_sparse_compress *& p){
    sparse_reset(p);
}
// CHECK-LABEL: @_Z33test_sparse_reset_and_get_pointerRP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.4.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset_and_get_pointer(v256int4_sparse_compress *& p){
    sparse_reset_and_get_pointer(p);
}

// CHECK-LABEL: @_Z16test_sparse_fillRP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.4(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill(v256int4_sparse_compress *& p){
    return sparse_fill(p);
}
// CHECK-LABEL: @_Z32test_sparse_fill_and_get_pointerRP24v256int4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.4.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill_and_get_pointer(v256int4_sparse_compress *& p){
    return sparse_fill_and_get_pointer(p);
}

/*v256uint4_sparse*/
// CHECK-LABEL: @_Z15test_sparse_popRP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.pop.4.set.lo(<16 x i32> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.pop.4.insert.hi(<16 x i32> undef, i128 undef, <16 x i32> [[TMP3]], i128 [[TMP4]], ptr [[TMP2]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP5]], 0
// CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP5]], 2
// CHECK-NEXT:    store ptr [[TMP6]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP9:%.*]] = bitcast <16 x i32> [[TMP7]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE:%.*]] poison, <64 x i8> [[TMP9]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP8]], 1
// CHECK-NEXT:    ret [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256uint4_sparse test_sparse_pop(v256uint4_sparse_compress *& p){
    return sparse_pop(p);
}
// CHECK-LABEL: @_Z22test_sparse_pop_set_loRP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.pop.4.set.lo(<16 x i32> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <16 x i32> [[TMP3]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE:%.*]] poison, <64 x i8> [[TMP5]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256uint4_sparse test_sparse_pop_set_lo(v256uint4_sparse_compress *& p){
    return sparse_pop_set_lo(p);
}
// CHECK-LABEL: @_Z25test_sparse_pop_insert_hi16v256uint4_sparseS_RP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V256UINT4_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[VEC_COERCE_FCA_0_EXTRACT_I]] to <16 x i32>
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V256UINT4_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP2:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.pop.4.insert.hi(<16 x i32> undef, i128 undef, <16 x i32> [[TMP0]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP1]])
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 0
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 1
// CHECK-NEXT:    [[TMP5:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 2
// CHECK-NEXT:    store ptr [[TMP3]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = bitcast <16 x i32> [[TMP4]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE]] poison, <64 x i8> [[TMP6]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP5]], 1
// CHECK-NEXT:    ret [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256uint4_sparse test_sparse_pop_insert_hi(v256uint4_sparse qx0, v256uint4_sparse qx, v256uint4_sparse_compress *& p){
    return sparse_pop_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z31test_sparse_pop_and_get_pointerRP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.pop.4.and.get.pointer(<16 x i32> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <16 x i32> [[TMP3]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE:%.*]] poison, <64 x i8> [[TMP5]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256uint4_sparse test_sparse_pop_and_get_pointer(v256uint4_sparse_compress *& p){
    return sparse_pop_and_get_pointer(p);
}

// CHECK-LABEL: @_Z23test_sparse_peek_set_loRP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.peek.4.set.lo(<16 x i32> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <16 x i32> [[TMP3]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE:%.*]] poison, <64 x i8> [[TMP5]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256uint4_sparse test_sparse_peek_set_lo(v256uint4_sparse_compress *& p){
    return sparse_peek_set_lo(p);
}
// CHECK-LABEL: @_Z26test_sparse_peek_insert_hi16v256uint4_sparseS_RP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V256UINT4_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[VEC_COERCE_FCA_0_EXTRACT_I]] to <16 x i32>
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V256UINT4_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP2:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.peek.4.insert.hi(<16 x i32> undef, i128 undef, <16 x i32> [[TMP0]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP1]])
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 0
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 1
// CHECK-NEXT:    [[TMP5:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP2]], 2
// CHECK-NEXT:    store ptr [[TMP3]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = bitcast <16 x i32> [[TMP4]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE]] poison, <64 x i8> [[TMP6]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP5]], 1
// CHECK-NEXT:    ret [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256uint4_sparse test_sparse_peek_insert_hi(v256uint4_sparse qx0, v256uint4_sparse qx, v256uint4_sparse_compress *& p){
    return sparse_peek_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z32test_sparse_peek_and_get_pointerRP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <16 x i32>, i128 } @llvm.aie2.sparse.peek.4.and.get.pointer(<16 x i32> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <16 x i32>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <16 x i32> [[TMP3]] to <64 x i8>
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE:%.*]] poison, <64 x i8> [[TMP5]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V256UINT4_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v256uint4_sparse test_sparse_peek_and_get_pointer(v256uint4_sparse_compress *& p){
    return sparse_peek_and_get_pointer(p);
}
// CHECK-LABEL: @_Z17test_sparse_resetRP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.4(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset(v256uint4_sparse_compress *& p){
    sparse_reset(p);
}
// CHECK-LABEL: @_Z33test_sparse_reset_and_get_pointerRP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.4.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset_and_get_pointer(v256uint4_sparse_compress *& p){
    sparse_reset_and_get_pointer(p);
}

// CHECK-LABEL: @_Z16test_sparse_fillRP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.4(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill(v256uint4_sparse_compress *& p){
    return sparse_fill(p);
}
// CHECK-LABEL: @_Z32test_sparse_fill_and_get_pointerRP25v256uint4_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.4.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill_and_get_pointer(v256uint4_sparse_compress *& p){
    return sparse_fill_and_get_pointer(p);
}

/*v64bfloat16_sparse*/
// CHECK-LABEL: @_Z15test_sparse_popRP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x bfloat>, i128 } @llvm.aie2.sparse.pop.16.bfloat.set.lo(<32 x bfloat> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = tail call { ptr, <32 x bfloat>, i128 } @llvm.aie2.sparse.pop.16.bfloat.insert.hi(<32 x bfloat> undef, i128 undef, <32 x bfloat> [[TMP3]], i128 [[TMP4]], ptr [[TMP2]])
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP5]], 0
// CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP5]], 1
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP5]], 2
// CHECK-NEXT:    store ptr [[TMP6]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE:%.*]] poison, <32 x bfloat> [[TMP7]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP8]], 1
// CHECK-NEXT:    ret [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64bfloat16_sparse test_sparse_pop(v64bfloat16_sparse_compress *& p){
    return sparse_pop(p);
}
// CHECK-LABEL: @_Z22test_sparse_pop_set_loRP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x bfloat>, i128 } @llvm.aie2.sparse.pop.16.bfloat.set.lo(<32 x bfloat> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE:%.*]] poison, <32 x bfloat> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64bfloat16_sparse test_sparse_pop_set_lo(v64bfloat16_sparse_compress *& p){
    return sparse_pop_set_lo(p);
}
// CHECK-LABEL: @_Z25test_sparse_pop_insert_hi18v64bfloat16_sparseS_RP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64BFLOAT16_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64BFLOAT16_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x bfloat>, i128 } @llvm.aie2.sparse.pop.16.bfloat.insert.hi(<32 x bfloat> undef, i128 undef, <32 x bfloat> [[VEC_COERCE_FCA_0_EXTRACT_I]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE]] poison, <32 x bfloat> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64bfloat16_sparse test_sparse_pop_insert_hi(v64bfloat16_sparse qx0, v64bfloat16_sparse qx, v64bfloat16_sparse_compress *& p){
    return sparse_pop_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z31test_sparse_pop_and_get_pointerRP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x bfloat>, i128 } @llvm.aie2.sparse.pop.16.bfloat.and.get.pointer(<32 x bfloat> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE:%.*]] poison, <32 x bfloat> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64bfloat16_sparse test_sparse_pop_and_get_pointer(v64bfloat16_sparse_compress *& p){
    return sparse_pop_and_get_pointer(p);
}

// CHECK-LABEL: @_Z23test_sparse_peek_set_loRP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x bfloat>, i128 } @llvm.aie2.sparse.peek.16.bfloat.set.lo(<32 x bfloat> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE:%.*]] poison, <32 x bfloat> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64bfloat16_sparse test_sparse_peek_set_lo(v64bfloat16_sparse_compress *& p){
    return sparse_peek_set_lo(p);
}
// CHECK-LABEL: @_Z26test_sparse_peek_insert_hi18v64bfloat16_sparseS_RP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VEC_COERCE_FCA_0_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64BFLOAT16_SPARSE:%.*]] [[QX_COERCE:%.*]], 0
// CHECK-NEXT:    [[VEC_COERCE_FCA_1_EXTRACT_I:%.*]] = extractvalue [[STRUCT_V64BFLOAT16_SPARSE]] [[QX_COERCE]], 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x bfloat>, i128 } @llvm.aie2.sparse.peek.16.bfloat.insert.hi(<32 x bfloat> undef, i128 undef, <32 x bfloat> [[VEC_COERCE_FCA_0_EXTRACT_I]], i128 [[VEC_COERCE_FCA_1_EXTRACT_I]], ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE]] poison, <32 x bfloat> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64bfloat16_sparse test_sparse_peek_insert_hi(v64bfloat16_sparse qx0, v64bfloat16_sparse qx, v64bfloat16_sparse_compress *& p){
    return sparse_peek_insert_hi(qx, p);
}
// CHECK-LABEL: @_Z32test_sparse_peek_and_get_pointerRP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { ptr, <32 x bfloat>, i128 } @llvm.aie2.sparse.peek.16.bfloat.and.get.pointer(<32 x bfloat> undef, i128 undef, ptr [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 1
// CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, <32 x bfloat>, i128 } [[TMP1]], 2
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[P]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE:%.*]] poison, <32 x bfloat> [[TMP3]], 0
// CHECK-NEXT:    [[DOTFCA_1_INSERT_I:%.*]] = insertvalue [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_0_INSERT_I]], i128 [[TMP4]], 1
// CHECK-NEXT:    ret [[STRUCT_V64BFLOAT16_SPARSE]] [[DOTFCA_1_INSERT_I]]
//
v64bfloat16_sparse test_sparse_peek_and_get_pointer(v64bfloat16_sparse_compress *& p){
    return sparse_peek_and_get_pointer(p);
}

// CHECK-LABEL: @_Z17test_sparse_resetRP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.16(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset(v64bfloat16_sparse_compress *& p){
    sparse_reset(p);
}
// CHECK-LABEL: @_Z33test_sparse_reset_and_get_pointerRP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.reset.16.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_reset_and_get_pointer(v64bfloat16_sparse_compress *& p){
    sparse_reset_and_get_pointer(p);
}

// CHECK-LABEL: @_Z16test_sparse_fillRP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.16(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill(v64bfloat16_sparse_compress *& p){
    return sparse_fill(p);
}
// CHECK-LABEL: @_Z32test_sparse_fill_and_get_pointerRP27v64bfloat16_sparse_compress(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P:%.*]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.aie2.sparse.fill.16.and.get.pointer(ptr [[TMP0]])
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[P]], align 4
// CHECK-NEXT:    ret void
//
void test_sparse_fill_and_get_pointer(v64bfloat16_sparse_compress *& p){
    return sparse_fill_and_get_pointer(p);
}


