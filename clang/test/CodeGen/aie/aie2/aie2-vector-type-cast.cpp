// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --return-type
//===- aie2-vector-type-cast.cpp --------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: %clang -O1 --target=aie2 -nostdlibinc -S -emit-llvm %s -o - | FileCheck %s

#include <stdint.h>

extern "C" {

// CHECK-LABEL: define {{[^@]*}}<4 x i64> @v8accfloat_to_v8acc32_explicit
// CHECK-SAME: (<4 x i64> noundef returned [[A:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret <4 x i64> [[A]]
//
v8acc32 v8accfloat_to_v8acc32_explicit(v8accfloat a) {
  return (v8acc32) a;
}

// CHECK-LABEL: define {{[^@]*}}<4 x i64> @v8accfloat_to_v8acc32_implicit
// CHECK-SAME: (<4 x i64> noundef returned [[A:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret <4 x i64> [[A]]
//
v8acc32 v8accfloat_to_v8acc32_implicit(v8accfloat a) {
  return a;
}

// CHECK-LABEL: define {{[^@]*}}void @v8accfloat_assign_to_v8acc32
// CHECK-SAME: (ptr nocapture writeonly [[A:%.*]], ptr nocapture readonly [[B:%.*]]) local_unnamed_addr #[[ATTR1:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i64>, ptr [[B]], align 32, !tbaa [[TBAA2:![0-9]+]]
// CHECK-NEXT:    store <4 x i64> [[TMP0]], ptr [[A]], align 32, !tbaa [[TBAA2]]
// CHECK-NEXT:    ret void
//
void v8accfloat_assign_to_v8acc32(v8accfloat *a, v8acc32 *b) {
   *a = *b;
}

// CHECK-LABEL: define {{[^@]*}}<8 x i32> @v8accfloat_to_v8int32_explicit
// CHECK-SAME: (<4 x i64> noundef [[A:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x i64> [[A]] to <8 x i32>
// CHECK-NEXT:    ret <8 x i32> [[TMP0]]
//
v8int32 v8accfloat_to_v8int32_explicit(v8accfloat a) {
  return (v8int32) a;
}

// CHECK-LABEL: define {{[^@]*}}<8 x i32> @v8accfloat_to_v8int32_implicit
// CHECK-SAME: (<4 x i64> noundef [[A:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x i64> [[A]] to <8 x i32>
// CHECK-NEXT:    ret <8 x i32> [[TMP0]]
//
v8int32 v8accfloat_to_v8int32_implicit(v8accfloat a) {
  return a;
}

// CHECK-LABEL: define {{[^@]*}}void @v8accfloat_assign_to_v8int32
// CHECK-SAME: (ptr nocapture writeonly [[A:%.*]], ptr nocapture readonly [[B:%.*]]) local_unnamed_addr #[[ATTR1]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i64>, ptr [[B]], align 32, !tbaa [[TBAA2]]
// CHECK-NEXT:    store <4 x i64> [[TMP0]], ptr [[A]], align 32, !tbaa [[TBAA2]]
// CHECK-NEXT:    ret void
//
void v8accfloat_assign_to_v8int32(v8accfloat *a, v8int32 *b) {
   *a = *b;
}

}
