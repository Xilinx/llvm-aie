// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//===- aie2-bf16-intrinsics.cpp ---------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: %clang -O2 %s --target=aie2 -S -emit-llvm -o - | FileCheck %s

// CHECK-LABEL: @_Z12band_v32bf16Dv32_u6__bf16S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x bfloat> [[A:%.*]] to <32 x i16>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x bfloat> [[B:%.*]] to <32 x i16>
// CHECK-NEXT:    [[AND_I:%.*]] = and <32 x i16> [[TMP1]], [[TMP0]]
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <32 x i16> [[AND_I]] to <32 x bfloat>
// CHECK-NEXT:    ret <32 x bfloat> [[TMP2]]
//
v32bfloat16 band_v32bf16(v32bfloat16 a, v32bfloat16 b) {
  return band(a, b);
}
// CHECK-LABEL: @_Z11bor_v32bf16Dv32_u6__bf16S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x bfloat> [[A:%.*]] to <32 x i16>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x bfloat> [[B:%.*]] to <32 x i16>
// CHECK-NEXT:    [[OR_I:%.*]] = or <32 x i16> [[TMP1]], [[TMP0]]
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <32 x i16> [[OR_I]] to <32 x bfloat>
// CHECK-NEXT:    ret <32 x bfloat> [[TMP2]]
//
v32bfloat16 bor_v32bf16(v32bfloat16 a, v32bfloat16 b) {
  return bor(a, b);
}
// CHECK-LABEL: @_Z12bxor_v32bf16Dv32_u6__bf16S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x bfloat> [[A:%.*]] to <32 x i16>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x bfloat> [[B:%.*]] to <32 x i16>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call { <32 x i16>, i32 } @llvm.aie2.vbneg.ltz16(<32 x i16> [[TMP1]])
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { <32 x i16>, i32 } [[TMP2]], 0
// CHECK-NEXT:    [[AND_I7_I:%.*]] = and <32 x i16> [[TMP3]], [[TMP0]]
// CHECK-NEXT:    [[TMP4:%.*]] = tail call { <32 x i16>, i32 } @llvm.aie2.vbneg.ltz16(<32 x i16> [[TMP0]])
// CHECK-NEXT:    [[TMP5:%.*]] = extractvalue { <32 x i16>, i32 } [[TMP4]], 0
// CHECK-NEXT:    [[AND_I_I:%.*]] = and <32 x i16> [[TMP5]], [[TMP1]]
// CHECK-NEXT:    [[OR_I_I:%.*]] = or <32 x i16> [[AND_I_I]], [[AND_I7_I]]
// CHECK-NEXT:    [[TMP6:%.*]] = bitcast <32 x i16> [[OR_I_I]] to <32 x bfloat>
// CHECK-NEXT:    ret <32 x bfloat> [[TMP6]]
//
v32bfloat16 bxor_v32bf16(v32bfloat16 a, v32bfloat16 b) {
  return bxor(a, b);
}
// CHECK-LABEL: @_Z12bneg_v32bf16Dv32_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x bfloat> [[A:%.*]] to <32 x i16>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call { <32 x i16>, i32 } @llvm.aie2.vbneg.ltz16(<32 x i16> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { <32 x i16>, i32 } [[TMP1]], 0
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <32 x i16> [[TMP2]] to <32 x bfloat>
// CHECK-NEXT:    ret <32 x bfloat> [[TMP3]]
//
v32bfloat16 bneg_v32bf16(v32bfloat16 a) {
  return bneg(a);
}
// CHECK-LABEL: @_Z11abs_v32bf16Dv32_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x i16> @llvm.aie2.vbroadcast16.I512(i32 32767)
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x bfloat> [[A:%.*]] to <32 x i16>
// CHECK-NEXT:    [[AND_I:%.*]] = and <32 x i16> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <32 x i16> [[AND_I]] to <32 x bfloat>
// CHECK-NEXT:    ret <32 x bfloat> [[TMP2]]
//
v32bfloat16 abs_v32bf16(v32bfloat16 a) {
  return abs(a);
}
//
// CHECK-LABEL: @_Z14max_lt_v32bf16Dv32_u6__bf16S_Rj(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call { <32 x bfloat>, i32 } @llvm.aie2.vmax.ltbf16(<32 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]])
// CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { <32 x bfloat>, i32 } [[TMP0]], 1
// CHECK-NEXT:    store i32 [[TMP1]], ptr [[CMP:%.*]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { <32 x bfloat>, i32 } [[TMP0]], 0
// CHECK-NEXT:    ret <32 x bfloat> [[TMP2]]
//
v32bfloat16 max_lt_v32bf16(v32bfloat16 a, v32bfloat16 b, unsigned int &cmp) {
  return max_lt(a, b, cmp);
}
// CHECK-LABEL: @_Z11max_v32bf16Dv32_u6__bf16S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call { <32 x bfloat>, i32 } @llvm.aie2.vmax.ltbf16(<32 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]])
// CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { <32 x bfloat>, i32 } [[TMP0]], 0
// CHECK-NEXT:    ret <32 x bfloat> [[TMP1]]
//
v32bfloat16 max_v32bf16(v32bfloat16 a, v32bfloat16 b) {
  return max(a, b);
}
// CHECK-LABEL: @_Z14min_ge_v32bf16Dv32_u6__bf16S_Rj(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call { <32 x bfloat>, i32 } @llvm.aie2.vmin.gebf16(<32 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]])
// CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { <32 x bfloat>, i32 } [[TMP0]], 1
// CHECK-NEXT:    store i32 [[TMP1]], ptr [[CMP:%.*]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { <32 x bfloat>, i32 } [[TMP0]], 0
// CHECK-NEXT:    ret <32 x bfloat> [[TMP2]]
//
v32bfloat16 min_ge_v32bf16(v32bfloat16 a, v32bfloat16 b, unsigned int &cmp) {
  return min_ge(a, b, cmp);
}
// CHECK-LABEL: @_Z11min_v32bf16Dv32_u6__bf16S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call { <32 x bfloat>, i32 } @llvm.aie2.vmin.gebf16(<32 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]])
// CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { <32 x bfloat>, i32 } [[TMP0]], 0
// CHECK-NEXT:    ret <32 x bfloat> [[TMP1]]
//
v32bfloat16 min_v32bf16(v32bfloat16 a, v32bfloat16 b) {
  return min(a, b);
}
// CHECK-LABEL: @_Z20test_bfloat16_to_intDv16_u6__bf16i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i32> @llvm.aie2.v16bf16.to.v16i32(<16 x bfloat> [[A:%.*]], i32 [[SHFT:%.*]])
// CHECK-NEXT:    ret <16 x i32> [[TMP0]]
//
v16int32 test_bfloat16_to_int(v16bfloat16 a, int shft) {
  return bfloat16_to_int(a, shft);
}
