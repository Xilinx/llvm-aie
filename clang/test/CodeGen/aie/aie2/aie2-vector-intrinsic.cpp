// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//===- aie2-vector-intrinsic.cpp --------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: %clang -O2 %s --target=aie2 -S -emit-llvm -o - | FileCheck %s
// CHECK-LABEL: @_Z21test_mac_4x2_2x4_confiiiiii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP1:%.*]] = tail call noundef <32 x i16> @llvm.aie2.v32int16()
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <16 x i64> @llvm.aie2.v16acc64()
// CHECK-NEXT:    [[SHL1_I:%.*]] = shl i32 [[SHIFT16:%.*]], 10
// CHECK-NEXT:    [[SHL2_I:%.*]] = shl i32 [[SUB_MUL:%.*]], 11
// CHECK-NEXT:    [[SHL4_I:%.*]] = shl i32 [[SUB_ACC1:%.*]], 12
// CHECK-NEXT:    [[SHL14_I:%.*]] = shl i32 [[SGN_X:%.*]], 9
// CHECK-NEXT:    [[SHL15_I:%.*]] = shl i32 [[SGN_Y:%.*]], 8
// CHECK-NEXT:    [[OR3_I:%.*]] = or i32 [[SHL14_I]], [[SHL15_I]]
// CHECK-NEXT:    [[OR5_I:%.*]] = or i32 [[OR3_I]], [[ZERO_ACC1:%.*]]
// CHECK-NEXT:    [[OR11_I:%.*]] = or i32 [[OR5_I]], [[SHL1_I]]
// CHECK-NEXT:    [[OR13_I:%.*]] = or i32 [[OR11_I]], [[SHL2_I]]
// CHECK-NEXT:    [[OR16_I:%.*]] = or i32 [[OR13_I]], [[SHL4_I]]
// CHECK-NEXT:    [[OR17_I:%.*]] = or i32 [[OR16_I]], 2
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <16 x i32> [[TMP0]] to <64 x i8>
// CHECK-NEXT:    [[TMP4:%.*]] = bitcast <32 x i16> [[TMP1]] to <16 x i32>
// CHECK-NEXT:    [[TMP5:%.*]] = tail call noundef <16 x i64> @llvm.aie2.I512.I512.ACC1024.acc64.mac.conf(<64 x i8> [[TMP3]], <16 x i32> [[TMP4]], <16 x i64> [[TMP2]], i32 [[OR17_I]])
// CHECK-NEXT:    ret <16 x i64> [[TMP5]]
//
v16acc64 test_mac_4x2_2x4_conf(int sgn_x, int sgn_y, int zero_acc1, int shift16, int sub_mul, int sub_acc1)
{
  v16int32 a = undef_v16int32();
  v32int16 b = undef_v32int16();
  v16acc64 acc1 = undef_v16acc64();
  return mac_4x2_2x4_conf(a, sgn_x, b, sgn_y, acc1,zero_acc1, shift16, sub_mul, sub_acc1);
}
// CHECK-LABEL: @_Z18test_mul_4x16_16x8v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <64 x i8> @llvm.aie2.v64int8()
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <16 x i64> @llvm.aie2.I512.I512.acc32.mul.conf(<64 x i8> [[TMP0]], <16 x i32> [[TMP1]], i32 0)
// CHECK-NEXT:    ret <16 x i64> [[TMP2]]
//
v32acc32 test_mul_4x16_16x8()
{
  v64uint8 a = undef_v64uint8();
  v128uint4 b = undef_v128uint4();
  return mul_4x16_16x8(a, b);
}
// CHECK-LABEL: @_Z17test_msc_conv_4x4iiiiii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <64 x i8> @llvm.aie2.v64int8()
// CHECK-NEXT:    [[TMP1:%.*]] = tail call noundef <16 x i64> @llvm.aie2.v32acc32()
// CHECK-NEXT:    [[SHL1_I:%.*]] = shl i32 [[SHIFT16:%.*]], 10
// CHECK-NEXT:    [[SHL2_I:%.*]] = shl i32 [[SUB_MUL:%.*]], 11
// CHECK-NEXT:    [[SHL4_I:%.*]] = shl i32 [[SUB_ACC1:%.*]], 12
// CHECK-NEXT:    [[SHL14_I:%.*]] = shl i32 [[SGN_X:%.*]], 9
// CHECK-NEXT:    [[SHL15_I:%.*]] = shl i32 [[SGN_Y:%.*]], 8
// CHECK-NEXT:    [[OR3_I:%.*]] = or i32 [[SHL14_I]], [[SHL15_I]]
// CHECK-NEXT:    [[OR9_I:%.*]] = or i32 [[OR3_I]], [[ZERO_ACC1:%.*]]
// CHECK-NEXT:    [[OR11_I:%.*]] = or i32 [[OR9_I]], [[SHL1_I]]
// CHECK-NEXT:    [[OR13_I:%.*]] = or i32 [[OR11_I]], [[SHL2_I]]
// CHECK-NEXT:    [[OR16_I:%.*]] = or i32 [[OR13_I]], [[SHL4_I]]
// CHECK-NEXT:    [[OR17_I:%.*]] = or i32 [[OR16_I]], 72
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <64 x i8> [[TMP0]] to <16 x i32>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call noundef <16 x i64> @llvm.aie2.I512.I512.ACC1024.acc32.msc.conf(<64 x i8> [[TMP0]], <16 x i32> [[TMP2]], <16 x i64> [[TMP1]], i32 [[OR17_I]])
// CHECK-NEXT:    ret <16 x i64> [[TMP3]]
//
v32acc32 test_msc_conv_4x4(int sgn_x, int sgn_y, int zero_acc1,
  int shift16, int sub_mul, int sub_acc1)
{
  v64uint8 a = undef_v64uint8();
  v64int8 b = undef_v64int8();
  v32acc32 acc1 = undef_v32acc32();
  return msc_conv_4x4_8ch_conf(a, sgn_x, b, sgn_y, acc1, zero_acc1, shift16, sub_mul, sub_acc1);
}
// CHECK-LABEL: @_Z21test_addmac_4x16_16x8iiiiii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <64 x i8> @llvm.aie2.v64int8()
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <16 x i64> @llvm.aie2.v32acc32()
// CHECK-NEXT:    [[SHL14_I:%.*]] = shl i32 [[SGN_X:%.*]], 9
// CHECK-NEXT:    [[SHL15_I:%.*]] = shl i32 [[SGN_Y:%.*]], 8
// CHECK-NEXT:    [[OR3_I:%.*]] = or i32 [[SHL15_I]], [[SHL14_I]]
// CHECK-NEXT:    [[TMP3:%.*]] = tail call noundef <16 x i64> @llvm.aie2.I512.I512.ACC1024.ACC1024.acc32.addmac.conf(<64 x i8> [[TMP0]], <16 x i32> [[TMP1]], <16 x i64> [[TMP2]], <16 x i64> [[TMP2]], i32 [[OR3_I]])
// CHECK-NEXT:    ret <16 x i64> [[TMP3]]
//
v32acc32 test_addmac_4x16_16x8(int sgn_x, int sgn_y, int zero_acc1, int shift16, int sub_mul, int sub_acc1)
{
  v64uint8 a = undef_v64uint8();
  v128uint4 b = undef_v128uint4();
  v32acc32 acc1 = undef_v32acc32();
  v32acc32 acc2 = undef_v32acc32();
  return addmac_4x16_16x8(a, sgn_x, b, sgn_y, acc1, acc2);
}
// CHECK-LABEL: @_Z19test_negmac_4x2_2x4iiiiii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP1:%.*]] = tail call noundef <32 x i16> @llvm.aie2.v32int16()
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <16 x i64> @llvm.aie2.v16acc64()
// CHECK-NEXT:    [[SHL14_I:%.*]] = shl i32 [[SGN_X:%.*]], 9
// CHECK-NEXT:    [[SHL15_I:%.*]] = shl i32 [[SGN_Y:%.*]], 8
// CHECK-NEXT:    [[OR3_I:%.*]] = or i32 [[SHL14_I]], [[SHL15_I]]
// CHECK-NEXT:    [[OR5_I:%.*]] = or disjoint i32 [[OR3_I]], 2
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <16 x i32> [[TMP0]] to <64 x i8>
// CHECK-NEXT:    [[TMP4:%.*]] = bitcast <32 x i16> [[TMP1]] to <16 x i32>
// CHECK-NEXT:    [[TMP5:%.*]] = tail call noundef <16 x i64> @llvm.aie2.I512.I512.ACC1024.acc64.negmac.conf(<64 x i8> [[TMP3]], <16 x i32> [[TMP4]], <16 x i64> [[TMP2]], i32 [[OR5_I]])
// CHECK-NEXT:    ret <16 x i64> [[TMP5]]
//
v16acc64 test_negmac_4x2_2x4(int sgn_x, int sgn_y, int zero_acc1, int shift16, int sub_mul, int sub_acc1)
{
  v16int32 a = undef_v16int32();
  v32int16 b = undef_v32int16();
  v16acc64 acc1 = undef_v16acc64();
  return negmac_4x2_2x4(a, sgn_x, b, sgn_y, acc1);
}
// CHECK-LABEL: @_Z19test_negmul_4x8_8x8ii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <64 x i8> @llvm.aie2.v64int8()
// CHECK-NEXT:    [[SHL14_I:%.*]] = shl i32 [[SGN_X:%.*]], 9
// CHECK-NEXT:    [[SHL15_I:%.*]] = shl i32 [[SGN_Y:%.*]], 8
// CHECK-NEXT:    [[OR3_I:%.*]] = or i32 [[SHL14_I]], [[SHL15_I]]
// CHECK-NEXT:    [[OR7_I:%.*]] = or disjoint i32 [[OR3_I]], 8
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <64 x i8> [[TMP0]] to <16 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <16 x i64> @llvm.aie2.I512.I512.acc32.negmul.conf(<64 x i8> [[TMP0]], <16 x i32> [[TMP1]], i32 [[OR7_I]])
// CHECK-NEXT:    ret <16 x i64> [[TMP2]]
//
v32acc32 test_negmul_4x8_8x8(int sgn_x, int sgn_y)
{
  v64int8 a = undef_v64int8();
  v64uint8 b = undef_v64uint8();
  return negmul_4x8_8x8(a, sgn_x, b, sgn_y);
}
// CHECK-LABEL: @_Z26test_negmul_elem_32_2_confDv64_aDv64_hi(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SHL2_I:%.*]] = shl i32 [[SUB_MUL:%.*]], 11
// CHECK-NEXT:    [[OR16_I:%.*]] = or disjoint i32 [[SHL2_I]], 552
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[B:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call noundef <16 x i64> @llvm.aie2.I512.I512.acc32.negmul.conf(<64 x i8> [[A:%.*]], <16 x i32> [[TMP0]], i32 [[OR16_I]])
// CHECK-NEXT:    ret <16 x i64> [[TMP1]]
//
v32acc32 test_negmul_elem_32_2_conf(v64int8 a, v64uint8 b, int sub_mul)
{
  return negmul_elem_32_2_conf(a, b, sub_mul);
}

// CHECK-LABEL: @_Z8test_addDv32_u7__acc32S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.add.acc(<16 x i64> [[ACC1:%.*]], <16 x i64> [[ACC2:%.*]], i32 0)
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v32acc32 test_add(v32acc32 acc1, v32acc32 acc2){
    return add(acc1, acc2);
}

// CHECK-LABEL: @_Z8test_addDv16_u7__acc64S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.add.acc(<16 x i64> [[ACC1:%.*]], <16 x i64> [[ACC2:%.*]], i32 2)
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v16acc64 test_add(v16acc64 acc1, v16acc64 acc2){
    return add(acc1, acc2);
}

// CHECK-LABEL: @_Z13test_add_confDv32_u7__acc32S_iiii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SHL1_I:%.*]] = shl i32 [[SHIFT16:%.*]], 10
// CHECK-NEXT:    [[SHL4_I:%.*]] = shl i32 [[SUB_ACC1:%.*]], 12
// CHECK-NEXT:    [[SHL6_I:%.*]] = shl i32 [[SUB_ACC2:%.*]], 13
// CHECK-NEXT:    [[OR13_I:%.*]] = or i32 [[SHL1_I]], [[ZERO_ACC1:%.*]]
// CHECK-NEXT:    [[OR17_I:%.*]] = or i32 [[OR13_I]], [[SHL4_I]]
// CHECK-NEXT:    [[OR19_I:%.*]] = or i32 [[OR17_I]], [[SHL6_I]]
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.add.acc(<16 x i64> [[ACC1:%.*]], <16 x i64> [[ACC2:%.*]], i32 [[OR19_I]])
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v32acc32 test_add_conf(v32acc32 acc1, v32acc32 acc2, int zero_acc1,
                         int shift16, int sub_acc1, int sub_acc2) {
  return add_conf(acc1, acc2, zero_acc1, shift16, sub_acc1, sub_acc2);
}

// CHECK-LABEL: @_Z13test_add_confDv16_u7__acc64S_iiii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SHL1_I:%.*]] = shl i32 [[SHIFT16:%.*]], 10
// CHECK-NEXT:    [[SHL4_I:%.*]] = shl i32 [[SUB_ACC1:%.*]], 12
// CHECK-NEXT:    [[SHL6_I:%.*]] = shl i32 [[SUB_ACC2:%.*]], 13
// CHECK-NEXT:    [[OR11_I:%.*]] = or i32 [[SHL1_I]], [[ZERO_ACC1:%.*]]
// CHECK-NEXT:    [[OR13_I:%.*]] = or i32 [[OR11_I]], [[SHL4_I]]
// CHECK-NEXT:    [[OR17_I:%.*]] = or i32 [[OR13_I]], [[SHL6_I]]
// CHECK-NEXT:    [[OR19_I:%.*]] = or i32 [[OR17_I]], 2
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.add.acc(<16 x i64> [[ACC1:%.*]], <16 x i64> [[ACC2:%.*]], i32 [[OR19_I]])
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v16acc64 test_add_conf(v16acc64 acc1, v16acc64 acc2, int zero_acc1,
                         int shift16, int sub_acc1, int sub_acc2) {
  return add_conf(acc1, acc2, zero_acc1, shift16, sub_acc1, sub_acc2);
}

// CHECK-LABEL: @_Z8test_subDv32_u7__acc32S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.sub.acc(<16 x i64> [[ACC1:%.*]], <16 x i64> [[ACC2:%.*]], i32 0)
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v32acc32 test_sub(v32acc32 acc1, v32acc32 acc2){
    return sub(acc1, acc2);
}

// CHECK-LABEL: @_Z8test_subDv16_u7__acc64S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.sub.acc(<16 x i64> [[ACC1:%.*]], <16 x i64> [[ACC2:%.*]], i32 2)
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v16acc64 test_sub(v16acc64 acc1, v16acc64 acc2){
    return sub(acc1, acc2);
}

// CHECK-LABEL: @_Z13test_sub_confDv32_u7__acc32S_iiii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SHL1_I:%.*]] = shl i32 [[SHIFT16:%.*]], 10
// CHECK-NEXT:    [[SHL4_I:%.*]] = shl i32 [[SUB_ACC1:%.*]], 12
// CHECK-NEXT:    [[SHL6_I:%.*]] = shl i32 [[SUB_ACC2:%.*]], 13
// CHECK-NEXT:    [[OR13_I:%.*]] = or i32 [[SHL1_I]], [[ZERO_ACC1:%.*]]
// CHECK-NEXT:    [[OR17_I:%.*]] = or i32 [[OR13_I]], [[SHL4_I]]
// CHECK-NEXT:    [[OR19_I:%.*]] = or i32 [[OR17_I]], [[SHL6_I]]
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.sub.acc(<16 x i64> [[ACC1:%.*]], <16 x i64> [[ACC2:%.*]], i32 [[OR19_I]])
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v32acc32 test_sub_conf(v32acc32 acc1, v32acc32 acc2, int zero_acc1,
                         int shift16, int sub_acc1, int sub_acc2) {
  return sub_conf(acc1, acc2, zero_acc1, shift16, sub_acc1, sub_acc2);
}

// CHECK-LABEL: @_Z13test_sub_confDv16_u7__acc64S_iiii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SHL1_I:%.*]] = shl i32 [[SHIFT16:%.*]], 10
// CHECK-NEXT:    [[SHL4_I:%.*]] = shl i32 [[SUB_ACC1:%.*]], 12
// CHECK-NEXT:    [[SHL6_I:%.*]] = shl i32 [[SUB_ACC2:%.*]], 13
// CHECK-NEXT:    [[OR11_I:%.*]] = or i32 [[SHL1_I]], [[ZERO_ACC1:%.*]]
// CHECK-NEXT:    [[OR13_I:%.*]] = or i32 [[OR11_I]], [[SHL4_I]]
// CHECK-NEXT:    [[OR17_I:%.*]] = or i32 [[OR13_I]], [[SHL6_I]]
// CHECK-NEXT:    [[OR19_I:%.*]] = or i32 [[OR17_I]], 2
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.sub.acc(<16 x i64> [[ACC1:%.*]], <16 x i64> [[ACC2:%.*]], i32 [[OR19_I]])
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v16acc64 test_sub_conf(v16acc64 acc1, v16acc64 acc2, int zero_acc1,
                         int shift16, int sub_acc1, int sub_acc2) {
  return sub_conf(acc1, acc2, zero_acc1, shift16, sub_acc1, sub_acc2);
}

// CHECK-LABEL: @_Z16test_mul_4x8_8x4Dv32_u6__bf16S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <8 x i64> @llvm.aie2.bf.mul16.conf(<32 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]], i32 28)
// CHECK-NEXT:    ret <8 x i64> [[TMP0]]
//
v16accfloat test_mul_4x8_8x4(v32bfloat16 a, v32bfloat16 b) {
  return mul_4x8_8x4(a, b);
}

// CHECK-LABEL: @_Z19test_negmul_4x8_8x4Dv32_u6__bf16S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <8 x i64> @llvm.aie2.bf.negmul16.conf(<32 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]], i32 28)
// CHECK-NEXT:    ret <8 x i64> [[TMP0]]
//
v16accfloat test_negmul_4x8_8x4(v32bfloat16 a, v32bfloat16 b) {
  return negmul_4x8_8x4(a, b);
}

// CHECK-LABEL: @_Z16test_mac_4x8_8x4Dv32_u6__bf16S_Dv16_u10__accfloat(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <8 x i64> @llvm.aie2.bf.mac16.conf(<32 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]], <8 x i64> [[ACC1:%.*]], i32 28)
// CHECK-NEXT:    ret <8 x i64> [[TMP0]]
//
v16accfloat test_mac_4x8_8x4(v32bfloat16 a, v32bfloat16 b, v16accfloat acc1) {
  return mac_4x8_8x4(a, b, acc1);
}

// CHECK-LABEL: @_Z16test_msc_4x8_8x4Dv32_u6__bf16S_Dv16_u10__accfloat(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <8 x i64> @llvm.aie2.bf.msc16.conf(<32 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]], <8 x i64> [[ACC1:%.*]], i32 28)
// CHECK-NEXT:    ret <8 x i64> [[TMP0]]
//
v16accfloat test_msc_4x8_8x4(v32bfloat16 a, v32bfloat16 b, v16accfloat acc1) {
  return msc_4x8_8x4(a, b, acc1);
}

// CHECK-LABEL: @_Z26test_addmac_elem_16_2_confDv32_u6__bf16S_Dv16_u10__accfloatS0_iiii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SHL2_I:%.*]] = shl i32 [[SUB_MUL:%.*]], 11
// CHECK-NEXT:    [[SHL4_I:%.*]] = shl i32 [[SUB_ACC1:%.*]], 12
// CHECK-NEXT:    [[SHL6_I:%.*]] = shl i32 [[SUB_ACC2:%.*]], 13
// CHECK-NEXT:    [[OR11_I:%.*]] = or i32 [[SHL2_I]], [[ZERO_ACC1:%.*]]
// CHECK-NEXT:    [[OR16_I:%.*]] = or i32 [[OR11_I]], [[SHL4_I]]
// CHECK-NEXT:    [[OR17_I:%.*]] = or i32 [[OR16_I]], [[SHL6_I]]
// CHECK-NEXT:    [[OR19_I:%.*]] = or i32 [[OR17_I]], 60
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <8 x i64> @llvm.aie2.bf.addmac16.conf(<32 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]], <8 x i64> [[ACC1:%.*]], <8 x i64> [[ACC2:%.*]], i32 [[OR19_I]])
// CHECK-NEXT:    ret <8 x i64> [[TMP0]]
//
v16accfloat test_addmac_elem_16_2_conf(v32bfloat16 a, v32bfloat16 b,
                                         v16accfloat acc1, v16accfloat acc2,
                                         int zero_acc1, int sub_mul,
                                         int sub_acc1, int sub_acc2) {
  return addmac_elem_16_2_conf(a, b, acc1, acc2, zero_acc1, sub_mul, sub_acc1, sub_acc2);
}

// CHECK-LABEL: @_Z26test_addmsc_elem_16_2_confDv32_u6__bf16S_Dv16_u10__accfloatS0_iiii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SHL2_I:%.*]] = shl i32 [[SUB_MUL:%.*]], 11
// CHECK-NEXT:    [[SHL4_I:%.*]] = shl i32 [[SUB_ACC1:%.*]], 12
// CHECK-NEXT:    [[SHL6_I:%.*]] = shl i32 [[SUB_ACC2:%.*]], 13
// CHECK-NEXT:    [[OR11_I:%.*]] = or i32 [[SHL2_I]], [[ZERO_ACC1:%.*]]
// CHECK-NEXT:    [[OR16_I:%.*]] = or i32 [[OR11_I]], [[SHL4_I]]
// CHECK-NEXT:    [[OR17_I:%.*]] = or i32 [[OR16_I]], [[SHL6_I]]
// CHECK-NEXT:    [[OR19_I:%.*]] = or i32 [[OR17_I]], 60
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <8 x i64> @llvm.aie2.bf.addmsc16.conf(<32 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]], <8 x i64> [[ACC1:%.*]], <8 x i64> [[ACC2:%.*]], i32 [[OR19_I]])
// CHECK-NEXT:    ret <8 x i64> [[TMP0]]
//
v16accfloat test_addmsc_elem_16_2_conf(v32bfloat16 a, v32bfloat16 b,
                                         v16accfloat acc1, v16accfloat acc2,
                                         int zero_acc1, int sub_mul,
                                         int sub_acc1, int sub_acc2) {
  return addmsc_elem_16_2_conf(a, b, acc1, acc2, zero_acc1, sub_mul, sub_acc1, sub_acc2);
}
