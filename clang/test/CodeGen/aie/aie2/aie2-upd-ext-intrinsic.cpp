// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//===- aie2-upd-ext-intrinsic.cpp -------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: %clang -O2 %s --target=aie2 -S -emit-llvm -o - | FileCheck %s

// CHECK-LABEL: @_Z12test_ext_w64Dv2_jijij(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <2 x i32> [[A_:%.*]] to i64
// CHECK-NEXT:    [[SUB_I_I:%.*]] = add i32 [[ELEMS:%.*]], -1
// CHECK-NEXT:    [[AND_I_I:%.*]] = and i32 [[SUB_I_I]], [[IDX:%.*]]
// CHECK-NEXT:    [[MUL_I:%.*]] = mul nsw i32 [[AND_I_I]], [[STEP:%.*]]
// CHECK-NEXT:    [[SH_PROM_I:%.*]] = zext nneg i32 [[MUL_I]] to i64
// CHECK-NEXT:    [[SHR_I:%.*]] = ashr i64 [[TMP0]], [[SH_PROM_I]]
// CHECK-NEXT:    [[TMP1:%.*]] = trunc i64 [[SHR_I]] to i32
// CHECK-NEXT:    [[VECEXT_I:%.*]] = and i32 [[TMP1]], [[ELEM_MASK:%.*]]
// CHECK-NEXT:    ret i32 [[VECEXT_I]]
//
int test_ext_w64(mask64 a_, int idx, unsigned int elems, int step, unsigned int elem_mask){
    return ext_w64(a_,idx,elems,step,elem_mask);
}

// CHECK-LABEL: @_Z15test_insert_ullyij(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i64 [[A:%.*]] to <2 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <2 x i32> @llvm.aie2.upd.I64.I32(<2 x i32> [[TMP0]], i32 [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTYIJ_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <2 x i32> @llvm.aie2.upd.I64.I32(<2 x i32> [[TMP0]], i32 [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTYIJ_EXIT]]
// CHECK:       _ZL6insertyij.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <2 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <2 x i32> [[RETVAL_0_IN_I]] to i64
// CHECK-NEXT:    ret i64 [[RETVAL_0_I]]
//
unsigned long long test_insert_ull(unsigned long long a, int idx, unsigned int b) {
    return insert(a,idx,b);
}

// CHECK-LABEL: @_Z19test_extract_uint32yi(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i64 [[A:%.*]] to <2 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i32 @llvm.aie2.ext.I32.I64(<2 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL14EXTRACT_UINT32YI_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call i32 @llvm.aie2.ext.I32.I64(<2 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL14EXTRACT_UINT32YI_EXIT]]
// CHECK:       _ZL14extract_uint32yi.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi i32 [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret i32 [[RETVAL_0_I]]
//
unsigned int test_extract_uint32(unsigned long long a, int idx) {
    return extract_uint32(a,idx);
}

// CHECK-LABEL: @_Z15test_concat_ulljj(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[A:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x i32> @llvm.aie2.set.I64.I32(i32 0, i32 0)
// CHECK-NEXT:    br label [[_ZL7SET_U64IJ_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <2 x i32> @llvm.aie2.set.I64.I32(i32 0, i32 1)
// CHECK-NEXT:    br label [[_ZL7SET_U64IJ_EXIT]]
// CHECK:       _ZL7set_u64ij.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <2 x i32> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <2 x i32> @llvm.aie2.upd.I64.I32(<2 x i32> [[RETVAL_0_IN_I]], i32 [[B:%.*]], i32 1)
// CHECK-NEXT:    [[RETVAL_0_I_I:%.*]] = bitcast <2 x i32> [[TMP2]] to i64
// CHECK-NEXT:    ret i64 [[RETVAL_0_I_I]]
//
unsigned long long test_concat_ull(unsigned int a, unsigned int b) {
  return concat(a,b);
}

// CHECK-LABEL: @_Z14test_upd_v16w4Dv2_jij(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <2 x i32> [[A:%.*]] to i64
// CHECK-NEXT:    [[AND_I_I_I:%.*]] = shl i32 [[IDX:%.*]], 2
// CHECK-NEXT:    [[MUL_I_I:%.*]] = and i32 [[AND_I_I_I]], 60
// CHECK-NEXT:    [[SH_PROM_I_I:%.*]] = zext nneg i32 [[MUL_I_I]] to i64
// CHECK-NEXT:    [[SHL_I_I:%.*]] = shl nuw i64 15, [[SH_PROM_I_I]]
// CHECK-NEXT:    [[NOT_I_I:%.*]] = xor i64 [[SHL_I_I]], -1
// CHECK-NEXT:    [[AND_I_I:%.*]] = and i64 [[NOT_I_I]], [[TMP0]]
// CHECK-NEXT:    [[AND1_I_I:%.*]] = and i32 [[VAL:%.*]], 15
// CHECK-NEXT:    [[CONV2_I_I:%.*]] = zext nneg i32 [[AND1_I_I]] to i64
// CHECK-NEXT:    [[SHL5_I_I:%.*]] = shl nuw i64 [[CONV2_I_I]], [[SH_PROM_I_I]]
// CHECK-NEXT:    [[OR_I_I:%.*]] = or i64 [[AND_I_I]], [[SHL5_I_I]]
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast i64 [[OR_I_I]] to <2 x i32>
// CHECK-NEXT:    ret <2 x i32> [[TMP1]]
//
mask64 test_upd_v16w4(mask64 a, int idx, unsigned int val){
   return upd_v16w4(a,idx,val);
}


// CHECK-LABEL: @_Z21test_extract_v32uint4Dv64_DU8_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[A:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[MUL_I:%.*]] = shl nsw i32 [[IDX:%.*]], 4
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP0]], <16 x i32> [[TMP1]], i32 0, i32 [[MUL_I]])
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x i32> @llvm.aie2.extract.I128.I512(<16 x i32> [[TMP2]])
// CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i32> [[TMP3]] to <16 x i8>
// CHECK-NEXT:    ret <16 x i8> [[TMP4]]
//
v32uint4 test_extract_v32uint4( v128uint4 a, int idx ){
    return extract_v32uint4(a,idx);
}


// CHECK-LABEL: @_Z25test_set_v128uint4_force0iDv16_DU8_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i8> [[A:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <16 x i32> [[TMP1]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[RETVAL_0_I]]
//
v128uint4 test_set_v128uint4_force0( int idx, v32uint4 a ){
   return set_v128uint4(0,a);
}


// CHECK-LABEL: @_Z22test_set_v128uint4_idxiDv16_DU8_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i8> [[A:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP3:%.*]] = shl i32 [[IDX:%.*]], 4
// CHECK-NEXT:    [[MUL_I:%.*]] = sub i32 64, [[TMP3]]
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP2]], <16 x i32> [[TMP1]], i32 0, i32 [[MUL_I]])
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <16 x i32> [[TMP4]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[RETVAL_0_I]]
//
v128uint4 test_set_v128uint4_idx( int idx, v32uint4 a ){
   return set_v128uint4(idx,a);
}

// CHECK-LABEL: @_Z11test_insertyij(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i64 [[A:%.*]] to <2 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <2 x i32> @llvm.aie2.upd.I64.I32(<2 x i32> [[TMP0]], i32 [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTYIJ_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <2 x i32> @llvm.aie2.upd.I64.I32(<2 x i32> [[TMP0]], i32 [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTYIJ_EXIT]]
// CHECK:       _ZL6insertyij.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <2 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <2 x i32> [[RETVAL_0_IN_I]] to i64
// CHECK-NEXT:    ret i64 [[RETVAL_0_I]]
//
unsigned long long test_insert(unsigned long long a, int idx, unsigned int b){
   return insert(a,idx,b);
}


// CHECK-LABEL: @_Z12test_set_u64ij(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x i32> @llvm.aie2.set.I64.I32(i32 [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL7SET_U64IJ_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <2 x i32> @llvm.aie2.set.I64.I32(i32 [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL7SET_U64IJ_EXIT]]
// CHECK:       _ZL7set_u64ij.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <2 x i32> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <2 x i32> [[RETVAL_0_IN_I]] to i64
// CHECK-NEXT:    ret i64 [[RETVAL_0_I]]
//
unsigned long long test_set_u64(int idx, unsigned int b){
   return set_u64(idx,b);
}


// CHECK-LABEL: @_Z21test_extract_v64uint4Dv64_DU8_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[A:%.*]] to <16 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL16EXTRACT_V64UINT4DV64_DU8_I_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL16EXTRACT_V64UINT4DV64_DU8_I_EXIT]]
// CHECK:       _ZL16extract_v64uint4Dv64_DU8_i.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <8 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <8 x i32> [[RETVAL_0_IN_I]] to <32 x i8>
// CHECK-NEXT:    ret <32 x i8> [[RETVAL_0_I]]
//
v64uint4 test_extract_v64uint4 (v128uint4 a, int idx){
   return extract_v64uint4(a,idx);
}


//
// CHECK-LABEL: @_Z23test_insert_upd_512_256Dv64_DU8_iDv32_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[A:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x i8> [[B:%.*]] to <8 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.upd.I512.I256(<16 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV64_DU8_IDV32_S__EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i32> @llvm.aie2.upd.I512.I256(<16 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV64_DU8_IDV32_S__EXIT]]
// CHECK:       _ZL6insertDv64_DU8_iDv32_S_.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <16 x i32> [ [[TMP2]], [[IF_THEN_I]] ], [ [[TMP3]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <16 x i32> [[RETVAL_0_IN_I]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[RETVAL_0_I]]
//
v128uint4 test_insert_upd_512_256 (v128uint4 a, int idx, v64uint4 b){
   return insert(a,idx,b);
}


// CHECK-LABEL: @_Z29test_set_v128uint_set_512_256iDv32_DU8_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x i8> [[B:%.*]] to <8 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL13SET_V128UINT4IDV32_DU8__EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL13SET_V128UINT4IDV32_DU8__EXIT]]
// CHECK:       _ZL13set_v128uint4iDv32_DU8_.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <16 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <16 x i32> [[RETVAL_0_IN_I]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[RETVAL_0_I]]
//
v128uint4 test_set_v128uint_set_512_256 (int idx, v64uint4 b){
   return set_v128uint4(idx,b);
}


// CHECK-LABEL: @_Z19test_concat_512_256Dv32_DU8_S0_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x i8> [[A0:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x i8> [[A1:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.concat.I512.I256(<8 x i32> [[TMP0]], <8 x i32> [[TMP1]])
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <16 x i32> [[TMP2]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[TMP3]]
//
v128uint4 test_concat_512_256 (v64uint4 a0, v64uint4 a1)
{
  return concat(a0,a1);
}


// CHECK-LABEL: @_Z30test_extract_v64uint4_256_1024Dv128_DU8_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <128 x i8> [[A:%.*]] to <32 x i32>
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL16EXTRACT_V64UINT4DV128_DU8_I_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL16EXTRACT_V64UINT4DV128_DU8_I_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> [[TMP0]], i32 2)
// CHECK-NEXT:    br label [[_ZL16EXTRACT_V64UINT4DV128_DU8_I_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> [[TMP0]], i32 3)
// CHECK-NEXT:    br label [[_ZL16EXTRACT_V64UINT4DV128_DU8_I_EXIT]]
// CHECK:       _ZL16extract_v64uint4Dv128_DU8_i.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <8 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_THEN2_I]] ], [ [[TMP3]], [[IF_THEN5_I]] ], [ [[TMP4]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <8 x i32> [[RETVAL_0_IN_I]] to <32 x i8>
// CHECK-NEXT:    ret <32 x i8> [[RETVAL_0_I]]
//
v64uint4 test_extract_v64uint4_256_1024 (v256uint4 a, int idx){
  return    extract_v64uint4(a,idx);
}


// CHECK-LABEL: @_Z20test_insert_1024_256Dv128_DU8_iDv32_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <128 x i8> [[A:%.*]] to <32 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x i8> [[B:%.*]] to <8 x i32>
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I256(<32 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV128_DU8_IDV32_S__EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I256(<32 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV128_DU8_IDV32_S__EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I256(<32 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 2)
// CHECK-NEXT:    br label [[_ZL6INSERTDV128_DU8_IDV32_S__EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I256(<32 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 3)
// CHECK-NEXT:    br label [[_ZL6INSERTDV128_DU8_IDV32_S__EXIT]]
// CHECK:       _ZL6insertDv128_DU8_iDv32_S_.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <32 x i32> [ [[TMP2]], [[IF_THEN_I]] ], [ [[TMP3]], [[IF_THEN2_I]] ], [ [[TMP4]], [[IF_THEN5_I]] ], [ [[TMP5]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <32 x i32> [[RETVAL_0_IN_I]] to <128 x i8>
// CHECK-NEXT:    ret <128 x i8> [[RETVAL_0_I]]
//
v256uint4 test_insert_1024_256(v256uint4 a, int idx, v64uint4 b){
  return    insert(a,idx,b);
}


// CHECK-LABEL: @_Z27test_set_v256uint4_1024_256iDv32_DU8_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x i8> [[B:%.*]] to <8 x i32>
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL13SET_V256UINT4IDV32_DU8__EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL13SET_V256UINT4IDV32_DU8__EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> [[TMP0]], i32 2)
// CHECK-NEXT:    br label [[_ZL13SET_V256UINT4IDV32_DU8__EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> [[TMP0]], i32 3)
// CHECK-NEXT:    br label [[_ZL13SET_V256UINT4IDV32_DU8__EXIT]]
// CHECK:       _ZL13set_v256uint4iDv32_DU8_.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <32 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_THEN2_I]] ], [ [[TMP3]], [[IF_THEN5_I]] ], [ [[TMP4]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <32 x i32> [[RETVAL_0_IN_I]] to <128 x i8>
// CHECK-NEXT:    ret <128 x i8> [[RETVAL_0_I]]
//
v256uint4 test_set_v256uint4_1024_256(int idx, v64uint4 b){
  return    set_v256uint4(idx,b);
}


// CHECK-LABEL: @_Z17test_concat_4x256Dv32_DU8_S0_S0_S0_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x i8> [[A0:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x i8> [[A1:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <32 x i8> [[A2:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <32 x i8> [[A3:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <32 x i32> @llvm.aie2.concat.I1024.I256(<8 x i32> [[TMP0]], <8 x i32> [[TMP1]], <8 x i32> [[TMP2]], <8 x i32> [[TMP3]])
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <32 x i32> [[TMP4]] to <128 x i8>
// CHECK-NEXT:    ret <128 x i8> [[TMP5]]
//
v256uint4 test_concat_4x256 (v64uint4 a0, v64uint4 a1, v64uint4 a2, v64uint4 a3){
   return concat(a0,a1,a2,a3);
}


// CHECK-LABEL: @_Z31test_extract_v128uint4_512_1024Dv128_DU8_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <128 x i8> [[A:%.*]] to <32 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.ext.I512.I1024(<32 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL17EXTRACT_V128UINT4DV128_DU8_I_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.ext.I512.I1024(<32 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL17EXTRACT_V128UINT4DV128_DU8_I_EXIT]]
// CHECK:       _ZL17extract_v128uint4Dv128_DU8_i.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <16 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <16 x i32> [[RETVAL_0_IN_I]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[RETVAL_0_I]]
//
v128uint4 test_extract_v128uint4_512_1024(v256uint4 a, int idx){
   return extract_v128uint4(a,idx);
}


// CHECK-LABEL: @_Z20test_insert_1024_512Dv128_DU8_iDv64_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <128 x i8> [[A:%.*]] to <32 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <64 x i8> [[B:%.*]] to <16 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I512(<32 x i32> [[TMP0]], <16 x i32> [[TMP1]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV128_DU8_IDV64_S__EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I512(<32 x i32> [[TMP0]], <16 x i32> [[TMP1]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV128_DU8_IDV64_S__EXIT]]
// CHECK:       _ZL6insertDv128_DU8_iDv64_S_.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <32 x i32> [ [[TMP2]], [[IF_THEN_I]] ], [ [[TMP3]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <32 x i32> [[RETVAL_0_IN_I]] to <128 x i8>
// CHECK-NEXT:    ret <128 x i8> [[RETVAL_0_I]]
//
v256uint4 test_insert_1024_512(v256uint4 a, int idx, v128uint4 b){
   return insert(a,idx,b);
}


// CHECK-LABEL: @_Z27test_set_v256uint4_1024_512iDv64_DU8_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[B:%.*]] to <16 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I512(<16 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL13SET_V256UINT4IDV64_DU8__EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I512(<16 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL13SET_V256UINT4IDV64_DU8__EXIT]]
// CHECK:       _ZL13set_v256uint4iDv64_DU8_.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <32 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <32 x i32> [[RETVAL_0_IN_I]] to <128 x i8>
// CHECK-NEXT:    ret <128 x i8> [[RETVAL_0_I]]
//
v256uint4 test_set_v256uint4_1024_512(int idx, v128uint4 b){
   return set_v256uint4(idx,b);
}


//
// CHECK-LABEL: @_Z17test_concat_2x512Dv64_DU8_S0_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[A0:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <64 x i8> [[A1:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <32 x i32> @llvm.aie2.concat.I1024.I512(<16 x i32> [[TMP0]], <16 x i32> [[TMP1]])
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <32 x i32> [[TMP2]] to <128 x i8>
// CHECK-NEXT:    ret <128 x i8> [[TMP3]]
//
v256uint4 test_concat_2x512 (v128uint4 a0, v128uint4 a1){
   return concat(a0,a1);
}


// CHECK-LABEL: @_Z12insert_v64i4Dv32_DU8_iDv16_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x i8> [[A:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <16 x i8> [[B:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP2]])
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP5:%.*]] = shl i32 [[IDX:%.*]], 4
// CHECK-NEXT:    [[MUL_I_I:%.*]] = sub i32 64, [[TMP5]]
// CHECK-NEXT:    [[TMP6:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP4]], <16 x i32> [[TMP3]], i32 0, i32 [[MUL_I_I]])
// CHECK-NEXT:    [[MUL_I:%.*]] = shl i32 [[IDX]], 2
// CHECK-NEXT:    [[SHL_I:%.*]] = shl i32 15, [[MUL_I]]
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP1]], <16 x i32> [[TMP6]], i32 [[SHL_I]])
// CHECK-NEXT:    [[TMP8:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP7]], i32 0)
// CHECK-NEXT:    [[RETVAL_0_I_I:%.*]] = bitcast <8 x i32> [[TMP8]] to <32 x i8>
// CHECK-NEXT:    ret <32 x i8> [[RETVAL_0_I_I]]
//
v64uint4 insert_v64i4  (v64uint4 a, int idx, v32uint4 b){
   return insert(a,idx,b);
}


// CHECK-LABEL: @_Z17insert_v64i4_idx0Dv32_DU8_iDv16_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x i8> [[A:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <16 x i8> [[B:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP2]])
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP1]], <16 x i32> [[TMP3]], i32 15)
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP4]], i32 0)
// CHECK-NEXT:    [[RETVAL_0_I_I:%.*]] = bitcast <8 x i32> [[TMP5]] to <32 x i8>
// CHECK-NEXT:    ret <32 x i8> [[RETVAL_0_I_I]]
//
v64uint4 insert_v64i4_idx0 (v64uint4 a, int idx, v32uint4 b){
   return insert(a,0,b);
}


// CHECK-LABEL: @_Z17insert_128_in_512Dv64_DU8_iDv16_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i8> [[B:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP3:%.*]] = shl i32 [[IDX:%.*]], 4
// CHECK-NEXT:    [[MUL_I_I:%.*]] = sub i32 64, [[TMP3]]
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP2]], <16 x i32> [[TMP1]], i32 0, i32 [[MUL_I_I]])
// CHECK-NEXT:    [[MUL_I:%.*]] = shl i32 [[IDX]], 2
// CHECK-NEXT:    [[SHL_I:%.*]] = shl i32 15, [[MUL_I]]
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <64 x i8> [[V:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP6:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP5]], <16 x i32> [[TMP4]], i32 [[SHL_I]])
// CHECK-NEXT:    [[TMP7:%.*]] = bitcast <16 x i32> [[TMP6]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[TMP7]]
//
v128uint4 insert_128_in_512(v128uint4 v, int idx, v32uint4 b ) {
   return insert(v,idx,b);
}


// CHECK-LABEL: @_Z17insert_128_in_256Dv32_DU8_iDv16_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x i8> [[V:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <16 x i8> [[B:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP2]])
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP5:%.*]] = shl i32 [[IDX:%.*]], 4
// CHECK-NEXT:    [[MUL_I_I:%.*]] = sub i32 64, [[TMP5]]
// CHECK-NEXT:    [[TMP6:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP4]], <16 x i32> [[TMP3]], i32 0, i32 [[MUL_I_I]])
// CHECK-NEXT:    [[MUL_I:%.*]] = shl i32 [[IDX]], 2
// CHECK-NEXT:    [[SHL_I:%.*]] = shl i32 15, [[MUL_I]]
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP1]], <16 x i32> [[TMP6]], i32 [[SHL_I]])
// CHECK-NEXT:    [[TMP8:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP7]], i32 0)
// CHECK-NEXT:    [[RETVAL_0_I_I:%.*]] = bitcast <8 x i32> [[TMP8]] to <32 x i8>
// CHECK-NEXT:    ret <32 x i8> [[RETVAL_0_I_I]]
//
v64uint4 insert_128_in_256(v64uint4 v, int idx, v32uint4 b ) {
   return insert(v,idx,b);
}


// CHECK-LABEL: @_Z20test_concat_v32uint4Dv16_DU8_S0_S0_S0_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i8> [[V1:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP2]], <16 x i32> [[TMP1]], i32 0, i32 48)
// CHECK-NEXT:    [[TMP4:%.*]] = bitcast <16 x i8> [[V2:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP4]])
// CHECK-NEXT:    [[TMP6:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP2]], <16 x i32> [[TMP5]], i32 0, i32 32)
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP3]], <16 x i32> [[TMP6]], i32 3840)
// CHECK-NEXT:    [[TMP8:%.*]] = bitcast <16 x i8> [[V3:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP9:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP8]])
// CHECK-NEXT:    [[TMP10:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP2]], <16 x i32> [[TMP9]], i32 0, i32 16)
// CHECK-NEXT:    [[TMP11:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP7]], <16 x i32> [[TMP10]], i32 61440)
// CHECK-NEXT:    [[TMP12:%.*]] = bitcast <16 x i8> [[V0:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP13:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP12]])
// CHECK-NEXT:    [[TMP14:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP11]], <16 x i32> [[TMP13]], i32 15)
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i32> [[TMP14]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[TMP15]]
//
v128uint4 test_concat_v32uint4  (v32uint4 v0, v32uint4 v1, v32uint4 v2, v32uint4 v3) {
   return concat(v0,v1,v2,v3);
}


// CHECK-LABEL: @_Z20test_concat_v32uint4Dv16_DU8_S0_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i8> [[V1:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP2]], <16 x i32> [[TMP1]], i32 0, i32 48)
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP3]], i32 0)
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP4]], i32 0)
// CHECK-NEXT:    [[TMP6:%.*]] = bitcast <16 x i8> [[V0:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP6]])
// CHECK-NEXT:    [[TMP8:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP5]], <16 x i32> [[TMP7]], i32 15)
// CHECK-NEXT:    [[TMP9:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP8]], i32 0)
// CHECK-NEXT:    [[RETVAL_0_I_I_I:%.*]] = bitcast <8 x i32> [[TMP9]] to <32 x i8>
// CHECK-NEXT:    ret <32 x i8> [[RETVAL_0_I_I_I]]
//
v64uint4 test_concat_v32uint4  (v32uint4 v0, v32uint4 v1 ) {
   return concat(v0,v1);
}


// CHECK-LABEL: @_Z19test_concat_v32int4Dv16_DB8_S0_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i8> [[V1:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.v16int32()
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP2]], <16 x i32> [[TMP1]], i32 0, i32 48)
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP3]], i32 0)
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP4]], i32 0)
// CHECK-NEXT:    [[TMP6:%.*]] = bitcast <16 x i8> [[V0:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP6]])
// CHECK-NEXT:    [[TMP8:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP5]], <16 x i32> [[TMP7]], i32 15)
// CHECK-NEXT:    [[TMP9:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP8]], i32 0)
// CHECK-NEXT:    [[TMP10:%.*]] = bitcast <8 x i32> [[TMP9]] to <32 x i8>
// CHECK-NEXT:    ret <32 x i8> [[TMP10]]
//
v64int4 test_concat_v32int4  (v32int4 v0, v32int4 v1 ) {
   return concat(v0,v1);
}


// CHECK-LABEL: @_Z20test_concat_v16uint8Dv16_hS_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i8> [[V1:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <64 x i8> @llvm.aie2.v64int8()
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <64 x i8> [[TMP2]] to <16 x i32>
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP3]], <16 x i32> [[TMP1]], i32 0, i32 48)
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP4]], i32 0)
// CHECK-NEXT:    [[TMP6:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP5]], i32 0)
// CHECK-NEXT:    [[TMP7:%.*]] = bitcast <16 x i8> [[V0:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP8:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP7]])
// CHECK-NEXT:    [[TMP9:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP6]], <16 x i32> [[TMP8]], i32 15)
// CHECK-NEXT:    [[TMP10:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP9]], i32 0)
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i32> [[TMP10]] to <32 x i8>
// CHECK-NEXT:    ret <32 x i8> [[TMP11]]
//
v32uint8 test_concat_v16uint8  (v16uint8 v0, v16uint8 v1 ) {
   return concat(v0,v1);
}


// CHECK-LABEL: @_Z19test_concat_v16int8Dv16_aS_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i8> [[V1:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <64 x i8> @llvm.aie2.v64int8()
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <64 x i8> [[TMP2]] to <16 x i32>
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP3]], <16 x i32> [[TMP1]], i32 0, i32 48)
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP4]], i32 0)
// CHECK-NEXT:    [[TMP6:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP5]], i32 0)
// CHECK-NEXT:    [[TMP7:%.*]] = bitcast <16 x i8> [[V0:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP8:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP7]])
// CHECK-NEXT:    [[TMP9:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP6]], <16 x i32> [[TMP8]], i32 15)
// CHECK-NEXT:    [[TMP10:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP9]], i32 0)
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i32> [[TMP10]] to <32 x i8>
// CHECK-NEXT:    ret <32 x i8> [[TMP11]]
//
v32int8 test_concat_v16int8  (v16int8 v0, v16int8 v1 ) {
   return concat(v0,v1);
}


// CHECK-LABEL: @_Z20test_concat_v8uint16Dv8_tS_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x i16> [[V1:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <32 x i16> @llvm.aie2.v32int16()
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <32 x i16> [[TMP2]] to <16 x i32>
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP3]], <16 x i32> [[TMP1]], i32 0, i32 48)
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP4]], i32 0)
// CHECK-NEXT:    [[TMP6:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP5]], i32 0)
// CHECK-NEXT:    [[TMP7:%.*]] = bitcast <8 x i16> [[V0:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP8:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP7]])
// CHECK-NEXT:    [[TMP9:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP6]], <16 x i32> [[TMP8]], i32 15)
// CHECK-NEXT:    [[TMP10:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP9]], i32 0)
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i32> [[TMP10]] to <16 x i16>
// CHECK-NEXT:    ret <16 x i16> [[TMP11]]
//
v16uint16 test_concat_v8uint16  (v8uint16 v0, v8uint16 v1 ) {
   return concat(v0,v1);
}


// CHECK-LABEL: @_Z19test_concat_v8int16Dv8_sS_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x i16> [[V1:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <32 x i16> @llvm.aie2.v32int16()
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <32 x i16> [[TMP2]] to <16 x i32>
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP3]], <16 x i32> [[TMP1]], i32 0, i32 48)
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP4]], i32 0)
// CHECK-NEXT:    [[TMP6:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP5]], i32 0)
// CHECK-NEXT:    [[TMP7:%.*]] = bitcast <8 x i16> [[V0:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP8:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP7]])
// CHECK-NEXT:    [[TMP9:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP6]], <16 x i32> [[TMP8]], i32 15)
// CHECK-NEXT:    [[TMP10:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP9]], i32 0)
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i32> [[TMP10]] to <16 x i16>
// CHECK-NEXT:    ret <16 x i16> [[TMP11]]
//
v16int16 test_concat_v8int16  (v8int16 v0, v8int16 v1 ) {
   return concat(v0,v1);
}


/* Test Intrinsic using ACC type */


// Extract 256-bit portion from 512-bit register
// CHECK-LABEL: @_Z20test_extract_v8acc32Dv16_u7__acc32i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.512.acc32(<8 x i64> [[A:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8ACC32DV16_U7__ACC32I_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.512.acc32(<8 x i64> [[A]], i32 1)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8ACC32DV16_U7__ACC32I_EXIT]]
// CHECK:       _ZL15extract_v8acc32Dv16_u7__acc32i.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <4 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <4 x i64> [[RETVAL_0_I]]
//
v8acc32 test_extract_v8acc32 (v16acc32 a, int idx){
  return extract_v8acc32(a,idx);
}

//Insert 256-bit in 512-bit register
// CHECK-LABEL: @_Z11test_insertDv16_u7__acc32iDv8_u7__acc32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <8 x i64> @llvm.aie2.upd.512.256.acc32(<8 x i64> [[A:%.*]], <4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_U7__ACC32IDV8_U7__ACC32_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i64> @llvm.aie2.upd.512.256.acc32(<8 x i64> [[A]], <4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_U7__ACC32IDV8_U7__ACC32_EXIT]]
// CHECK:       _ZL6insertDv16_u7__acc32iDv8_u7__acc32.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <8 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <8 x i64> [[RETVAL_0_I]]
//
v16acc32 test_insert (v16acc32 a, int idx, v8acc32 b){
  return insert(a,idx,b);
}

// CHECK-LABEL: @_Z17test_set_v16acc32iDv8_u7__acc32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <8 x i64> @llvm.aie2.set.512.256.acc32(<4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL12SET_V16ACC32IDV8_U7__ACC32_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i64> @llvm.aie2.set.512.256.acc32(<4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL12SET_V16ACC32IDV8_U7__ACC32_EXIT]]
// CHECK:       _ZL12set_v16acc32iDv8_u7__acc32.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <8 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <8 x i64> [[RETVAL_0_I]]
//
v16acc32 test_set_v16acc32 (int idx, v8acc32 b){
  return set_v16acc32 (idx,b);
}

// CHECK-LABEL: @_Z11test_concatDv8_u7__acc32S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <8 x i64> @llvm.aie2.concat.512.256.acc32(<4 x i64> [[A0:%.*]], <4 x i64> [[A1:%.*]])
// CHECK-NEXT:    ret <8 x i64> [[TMP0]]
//
v16acc32 test_concat (v8acc32 a0, v8acc32 a1){
  return concat(a0,a1);
}

// CHECK-LABEL: @_Z20test_extract_v4acc64Dv8_u7__acc64i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.512.acc64(<8 x i64> [[A:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V4ACC64DV8_U7__ACC64I_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.512.acc64(<8 x i64> [[A]], i32 1)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V4ACC64DV8_U7__ACC64I_EXIT]]
// CHECK:       _ZL15extract_v4acc64Dv8_u7__acc64i.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <4 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <4 x i64> [[RETVAL_0_I]]
//
v4acc64 test_extract_v4acc64 (v8acc64 a, int idx){
  return extract_v4acc64(a,idx);
}

//Insert 256-bit in 512-bit register
// CHECK-LABEL: @_Z11test_insertDv8_u7__acc64iDv4_u7__acc64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <8 x i64> @llvm.aie2.upd.512.256.acc64(<8 x i64> [[A:%.*]], <4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV8_U7__ACC64IDV4_U7__ACC64_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i64> @llvm.aie2.upd.512.256.acc64(<8 x i64> [[A]], <4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV8_U7__ACC64IDV4_U7__ACC64_EXIT]]
// CHECK:       _ZL6insertDv8_u7__acc64iDv4_u7__acc64.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <8 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <8 x i64> [[RETVAL_0_I]]
//
v8acc64 test_insert(v8acc64 a, int idx, v4acc64 b){
  return insert(a,idx,b);
}

//Set 256-bit portion of 512-bit register
// CHECK-LABEL: @_Z16test_set_v8acc64iDv4_u7__acc64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <8 x i64> @llvm.aie2.set.512.256.acc64(<4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL11SET_V8ACC64IDV4_U7__ACC64_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i64> @llvm.aie2.set.512.256.acc64(<4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL11SET_V8ACC64IDV4_U7__ACC64_EXIT]]
// CHECK:       _ZL11set_v8acc64iDv4_u7__acc64.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <8 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <8 x i64> [[RETVAL_0_I]]
//
v8acc64 test_set_v8acc64 (int idx, v4acc64 b){
  return set_v8acc64(idx,b);
}

//
// CHECK-LABEL: @_Z11test_concatDv4_u7__acc64S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <8 x i64> @llvm.aie2.concat.512.256.acc64(<4 x i64> [[A0:%.*]], <4 x i64> [[A1:%.*]])
// CHECK-NEXT:    ret <8 x i64> [[TMP0]]
//
v8acc64 test_concat (v4acc64 a0, v4acc64 a1){
  return concat(a0,a1);
}


// CHECK-LABEL: @_Z20test_extract_v8acc32Dv32_u7__acc32i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc32(<16 x i64> [[A:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8ACC32DV32_U7__ACC32I_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc32(<16 x i64> [[A]], i32 1)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8ACC32DV32_U7__ACC32I_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc32(<16 x i64> [[A]], i32 2)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8ACC32DV32_U7__ACC32I_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc32(<16 x i64> [[A]], i32 3)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8ACC32DV32_U7__ACC32I_EXIT]]
// CHECK:       _ZL15extract_v8acc32Dv32_u7__acc32i.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <4 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_THEN2_I]] ], [ [[TMP2]], [[IF_THEN5_I]] ], [ [[TMP3]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    ret <4 x i64> [[RETVAL_0_I]]
//
v8acc32 test_extract_v8acc32 (v32acc32 a, int idx)
{
   return extract_v8acc32 (a,idx);
}

//Insert 256-bit in 1024-bit register
// CHECK-LABEL: @_Z11test_insertDv32_u7__acc32iDv8_u7__acc32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc32(<16 x i64> [[A:%.*]], <4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U7__ACC32IDV8_U7__ACC32_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc32(<16 x i64> [[A]], <4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U7__ACC32IDV8_U7__ACC32_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc32(<16 x i64> [[A]], <4 x i64> [[B]], i32 2)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U7__ACC32IDV8_U7__ACC32_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc32(<16 x i64> [[A]], <4 x i64> [[B]], i32 3)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U7__ACC32IDV8_U7__ACC32_EXIT]]
// CHECK:       _ZL6insertDv32_u7__acc32iDv8_u7__acc32.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_THEN2_I]] ], [ [[TMP2]], [[IF_THEN5_I]] ], [ [[TMP3]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v32acc32 test_insert (v32acc32 a, int idx, v8acc32 b){
   return insert(a,idx,b);
}

//Set 256-bit portion of 1024-bit register
// CHECK-LABEL: @_Z17test_set_v32acc32iDv8_u7__acc32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc32(<4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL12SET_V32ACC32IDV8_U7__ACC32_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc32(<4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL12SET_V32ACC32IDV8_U7__ACC32_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc32(<4 x i64> [[B]], i32 2)
// CHECK-NEXT:    br label [[_ZL12SET_V32ACC32IDV8_U7__ACC32_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc32(<4 x i64> [[B]], i32 3)
// CHECK-NEXT:    br label [[_ZL12SET_V32ACC32IDV8_U7__ACC32_EXIT]]
// CHECK:       _ZL12set_v32acc32iDv8_u7__acc32.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_THEN2_I]] ], [ [[TMP2]], [[IF_THEN5_I]] ], [ [[TMP3]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v32acc32 test_set_v32acc32 (int idx, v8acc32 b){
   return set_v32acc32(idx,b);
}

// CHECK-LABEL: @_Z11test_concatDv8_u7__acc32S_S_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.concat.1024.256.acc32(<4 x i64> [[A0:%.*]], <4 x i64> [[A1:%.*]], <4 x i64> [[A2:%.*]], <4 x i64> [[A3:%.*]])
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v32acc32 test_concat (v8acc32 a0, v8acc32 a1, v8acc32 a2, v8acc32 a3)
{
  return concat(a0,a1,a2,a3);
}

// v32acc32
// Extract 512-bit portion from 1024-bit register
// CHECK-LABEL: @_Z21test_extract_v16acc32Dv32_u7__acc32i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc32(<16 x i64> [[A:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL16EXTRACT_V16ACC32DV32_U7__ACC32I_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc32(<16 x i64> [[A]], i32 1)
// CHECK-NEXT:    br label [[_ZL16EXTRACT_V16ACC32DV32_U7__ACC32I_EXIT]]
// CHECK:       _ZL16extract_v16acc32Dv32_u7__acc32i.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <8 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <8 x i64> [[RETVAL_0_I]]
//
v16acc32 test_extract_v16acc32 (v32acc32 a, int idx){
  return extract_v16acc32(a,idx);
}

//Insert 512-bit in 1024-bit register
// CHECK-LABEL: @_Z11test_insertDv32_u7__acc32iDv16_u7__acc32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.512.acc32(<16 x i64> [[A:%.*]], <8 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U7__ACC32IDV16_U7__ACC32_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.512.acc32(<16 x i64> [[A]], <8 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U7__ACC32IDV16_U7__ACC32_EXIT]]
// CHECK:       _ZL6insertDv32_u7__acc32iDv16_u7__acc32.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v32acc32 test_insert (v32acc32 a, int idx, v16acc32 b){
  return insert(a,idx,b);
}

//Set 512-bit portion of 1024-bit register
// CHECK-LABEL: @_Z17test_set_v32acc32iDv16_u7__acc32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.512.acc32(<8 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL12SET_V32ACC32IDV16_U7__ACC32_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.512.acc32(<8 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL12SET_V32ACC32IDV16_U7__ACC32_EXIT]]
// CHECK:       _ZL12set_v32acc32iDv16_u7__acc32.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v32acc32 test_set_v32acc32 (int idx, v16acc32 b){
   return set_v32acc32(idx,b);
}

// CHECK-LABEL: @_Z11test_concatDv16_u7__acc32S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.concat.1024.512.acc32(<8 x i64> [[A0:%.*]], <8 x i64> [[A1:%.*]])
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v32acc32 test_concat (v16acc32 a0, v16acc32 a1){
  return concat(a0,a1);
}


// v16acc64
// Extract 256-bit portion from 1024-bit register
// CHECK-LABEL: @_Z20test_extract_v4acc64Dv16_u7__acc64i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc64(<16 x i64> [[A:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V4ACC64DV16_U7__ACC64I_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc64(<16 x i64> [[A]], i32 1)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V4ACC64DV16_U7__ACC64I_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc64(<16 x i64> [[A]], i32 2)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V4ACC64DV16_U7__ACC64I_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc64(<16 x i64> [[A]], i32 3)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V4ACC64DV16_U7__ACC64I_EXIT]]
// CHECK:       _ZL15extract_v4acc64Dv16_u7__acc64i.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <4 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_THEN2_I]] ], [ [[TMP2]], [[IF_THEN5_I]] ], [ [[TMP3]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    ret <4 x i64> [[RETVAL_0_I]]
//
v4acc64 test_extract_v4acc64 (v16acc64 a, int idx)
{
  return extract_v4acc64(a,idx);
}

// CHECK-LABEL: @_Z25test_extract_v4acc64_idx0Dv16_u7__acc64i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc64(<16 x i64> [[A:%.*]], i32 0)
// CHECK-NEXT:    ret <4 x i64> [[TMP0]]
//
v4acc64 test_extract_v4acc64_idx0 (v16acc64 a, int idx)
{
  return extract_v4acc64(a,0);
}

//Insert 256-bit in 1024-bit register
// CHECK-LABEL: @_Z11test_insertDv16_u7__acc64iDv4_u7__acc64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc64(<16 x i64> [[A:%.*]], <4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_U7__ACC64IDV4_U7__ACC64_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc64(<16 x i64> [[A]], <4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_U7__ACC64IDV4_U7__ACC64_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc64(<16 x i64> [[A]], <4 x i64> [[B]], i32 2)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_U7__ACC64IDV4_U7__ACC64_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc64(<16 x i64> [[A]], <4 x i64> [[B]], i32 3)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_U7__ACC64IDV4_U7__ACC64_EXIT]]
// CHECK:       _ZL6insertDv16_u7__acc64iDv4_u7__acc64.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_THEN2_I]] ], [ [[TMP2]], [[IF_THEN5_I]] ], [ [[TMP3]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v16acc64 test_insert (v16acc64 a, int idx, v4acc64 b)
{
  return insert(a,idx,b);
}

//Set 256-bit portion of 1024-bit register
// CHECK-LABEL: @_Z17test_set_v16acc64iDv4_u7__acc64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc64(<4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL12SET_V16ACC64IDV4_U7__ACC64_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc64(<4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL12SET_V16ACC64IDV4_U7__ACC64_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc64(<4 x i64> [[B]], i32 2)
// CHECK-NEXT:    br label [[_ZL12SET_V16ACC64IDV4_U7__ACC64_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc64(<4 x i64> [[B]], i32 3)
// CHECK-NEXT:    br label [[_ZL12SET_V16ACC64IDV4_U7__ACC64_EXIT]]
// CHECK:       _ZL12set_v16acc64iDv4_u7__acc64.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_THEN2_I]] ], [ [[TMP2]], [[IF_THEN5_I]] ], [ [[TMP3]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v16acc64 test_set_v16acc64 (int idx, v4acc64 b)
{
  return set_v16acc64(idx,b);
}

// CHECK-LABEL: @_Z11test_concatDv4_u7__acc64S_S_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.concat.1024.256.acc64(<4 x i64> [[A0:%.*]], <4 x i64> [[A1:%.*]], <4 x i64> [[A2:%.*]], <4 x i64> [[A3:%.*]])
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v16acc64 test_concat (v4acc64 a0, v4acc64 a1, v4acc64 a2, v4acc64 a3)
{
  return concat(a0, a1, a2, a3);
}

// v16acc64
// Extract 512-bit portion from 1024-bit register
// CHECK-LABEL: @_Z20test_extract_v8acc64Dv16_u7__acc64i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc64(<16 x i64> [[A:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8ACC64DV16_U7__ACC64I_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc64(<16 x i64> [[A]], i32 1)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8ACC64DV16_U7__ACC64I_EXIT]]
// CHECK:       _ZL15extract_v8acc64Dv16_u7__acc64i.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <8 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <8 x i64> [[RETVAL_0_I]]
//
v8acc64 test_extract_v8acc64 (v16acc64 a, int idx)
{
  return extract_v8acc64(a,idx);
}

//Insert 512-bit in 1024-bit register
// CHECK-LABEL: @_Z11test_insertDv16_u7__acc64iDv8_u7__acc64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.512.acc64(<16 x i64> [[A:%.*]], <8 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_U7__ACC64IDV8_U7__ACC64_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.512.acc64(<16 x i64> [[A]], <8 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_U7__ACC64IDV8_U7__ACC64_EXIT]]
// CHECK:       _ZL6insertDv16_u7__acc64iDv8_u7__acc64.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v16acc64 test_insert (v16acc64 a, int idx, v8acc64 b)
{
   return insert(a,idx,b);
}

//Set 512-bit portion of 1024-bit register
// CHECK-LABEL: @_Z17test_set_v16acc64iDv8_u7__acc64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.512.acc64(<8 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL12SET_V16ACC64IDV8_U7__ACC64_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.512.acc64(<8 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL12SET_V16ACC64IDV8_U7__ACC64_EXIT]]
// CHECK:       _ZL12set_v16acc64iDv8_u7__acc64.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v16acc64 test_set_v16acc64 (int idx, v8acc64 b)
{
  return set_v16acc64(idx,b);
}

// CHECK-LABEL: @_Z11test_concatDv8_u7__acc64S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.concat.1024.512.acc64(<8 x i64> [[A0:%.*]], <8 x i64> [[A1:%.*]])
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v16acc64 test_concat (v8acc64 a0, v8acc64 a1)
{
  return concat(a0, a1);
}

// CHECK-LABEL: @_Z18test_set_v64int8_0Dv16_a(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i8> [[A:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <16 x i32> [[TMP1]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[RETVAL_0_I]]
//
v64int8 test_set_v64int8_0(v16int8 a) {
    return set_v64int8(0,a);
}

// CHECK-LABEL: @_Z18test_set_v64int8_1Dv16_a(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i8> [[A:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <64 x i8> @llvm.aie2.v64int8()
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <64 x i8> [[TMP2]] to <16 x i32>
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP3]], <16 x i32> [[TMP1]], i32 0, i32 48)
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <16 x i32> [[TMP4]] to <64 x i8>
// CHECK-NEXT:    ret <64 x i8> [[RETVAL_0_I]]
//
v64int8 test_set_v64int8_1(v16int8 a) {
    return set_v64int8(1,a);
}

/* Test Intrinsic using ACCFLOAT type */

// CHECK-LABEL: @_Z11test_insertDv16_u10__accfloatiDv8_u10__accfloat(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <8 x i64> @llvm.aie2.upd.512.256.acc32(<8 x i64> [[A:%.*]], <4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_U10__ACCFLOATIDV8_U10__ACCFLOAT_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i64> @llvm.aie2.upd.512.256.acc32(<8 x i64> [[A]], <4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_U10__ACCFLOATIDV8_U10__ACCFLOAT_EXIT]]
// CHECK:       _ZL6insertDv16_u10__accfloatiDv8_u10__accfloat.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <8 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <8 x i64> [[RETVAL_0_I]]
//
v16accfloat test_insert(v16accfloat a, int idx, v8accfloat b) {
   return insert(a, idx, b);
}

// CHECK-LABEL: @_Z11test_insertDv32_u10__accfloatiDv8_u10__accfloat(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc32(<16 x i64> [[A:%.*]], <4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U10__ACCFLOATIDV8_U10__ACCFLOAT_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc32(<16 x i64> [[A]], <4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U10__ACCFLOATIDV8_U10__ACCFLOAT_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc32(<16 x i64> [[A]], <4 x i64> [[B]], i32 2)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U10__ACCFLOATIDV8_U10__ACCFLOAT_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.256.acc32(<16 x i64> [[A]], <4 x i64> [[B]], i32 3)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U10__ACCFLOATIDV8_U10__ACCFLOAT_EXIT]]
// CHECK:       _ZL6insertDv32_u10__accfloatiDv8_u10__accfloat.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_THEN2_I]] ], [ [[TMP2]], [[IF_THEN5_I]] ], [ [[TMP3]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v32accfloat test_insert(v32accfloat a, int idx, v8accfloat b) {
   return insert(a, idx, b);
}

// CHECK-LABEL: @_Z11test_insertDv32_u10__accfloatiDv16_u10__accfloat(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.512.acc32(<16 x i64> [[A:%.*]], <8 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U10__ACCFLOATIDV16_U10__ACCFLOAT_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.upd.1024.512.acc32(<16 x i64> [[A]], <8 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_U10__ACCFLOATIDV16_U10__ACCFLOAT_EXIT]]
// CHECK:       _ZL6insertDv32_u10__accfloatiDv16_u10__accfloat.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v32accfloat test_insert(v32accfloat a, int idx, v16accfloat b) {
   return insert(a, idx, b);
}

// CHECK-LABEL: @_Z20test_set_v16accfloatiDv8_u10__accfloat(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <8 x i64> @llvm.aie2.set.512.256.acc32(<4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL15SET_V16ACCFLOATIDV8_U10__ACCFLOAT_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i64> @llvm.aie2.set.512.256.acc32(<4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL15SET_V16ACCFLOATIDV8_U10__ACCFLOAT_EXIT]]
// CHECK:       _ZL15set_v16accfloatiDv8_u10__accfloat.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <8 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <8 x i64> [[RETVAL_0_I]]
//
v16accfloat test_set_v16accfloat(int idx, v8accfloat b) {
   return set_v16accfloat(idx, b);
}

// CHECK-LABEL: @_Z20test_set_v32accfloatiDv8_u10__accfloat(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc32(<4 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL15SET_V32ACCFLOATIDV8_U10__ACCFLOAT_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc32(<4 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL15SET_V32ACCFLOATIDV8_U10__ACCFLOAT_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc32(<4 x i64> [[B]], i32 2)
// CHECK-NEXT:    br label [[_ZL15SET_V32ACCFLOATIDV8_U10__ACCFLOAT_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.256.acc32(<4 x i64> [[B]], i32 3)
// CHECK-NEXT:    br label [[_ZL15SET_V32ACCFLOATIDV8_U10__ACCFLOAT_EXIT]]
// CHECK:       _ZL15set_v32accfloatiDv8_u10__accfloat.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_THEN2_I]] ], [ [[TMP2]], [[IF_THEN5_I]] ], [ [[TMP3]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v32accfloat test_set_v32accfloat(int idx, v8accfloat b) {
   return set_v32accfloat(idx, b);
}

// CHECK-LABEL: @_Z20test_set_v32accfloatiDv16_u10__accfloat(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.512.acc32(<8 x i64> [[B:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL15SET_V32ACCFLOATIDV16_U10__ACCFLOAT_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i64> @llvm.aie2.set.1024.512.acc32(<8 x i64> [[B]], i32 1)
// CHECK-NEXT:    br label [[_ZL15SET_V32ACCFLOATIDV16_U10__ACCFLOAT_EXIT]]
// CHECK:       _ZL15set_v32accfloatiDv16_u10__accfloat.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <16 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <16 x i64> [[RETVAL_0_I]]
//
v32accfloat test_set_v32accfloat(int idx, v16accfloat b) {
   return set_v32accfloat(idx, b);
}

// CHECK-LABEL: @_Z11test_concatDv8_u10__accfloatS_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <8 x i64> @llvm.aie2.concat.512.256.acc32(<4 x i64> [[A0:%.*]], <4 x i64> [[A1:%.*]])
// CHECK-NEXT:    ret <8 x i64> [[TMP0]]
//
v16accfloat test_concat(v8accfloat a0, v8accfloat a1) {
   return concat(a0, a1);
}

// CHECK-LABEL: @_Z11test_concatDv16_u10__accfloatS_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.concat.1024.512.acc32(<8 x i64> [[A0:%.*]], <8 x i64> [[A1:%.*]])
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v32accfloat test_concat(v16accfloat a0, v16accfloat a1) {
   return concat(a0, a1);
}

// CHECK-LABEL: @_Z11test_concatDv8_u10__accfloatS_S_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x i64> @llvm.aie2.concat.1024.256.acc32(<4 x i64> [[A0:%.*]], <4 x i64> [[A1:%.*]], <4 x i64> [[A2:%.*]], <4 x i64> [[A3:%.*]])
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v32accfloat test_concat(v8accfloat a0, v8accfloat a1, v8accfloat a2, v8accfloat a3) {
  return concat(a0, a1, a2, a3);
}

// CHECK-LABEL: @_Z23test_extract_v8accfloatDv16_u10__accfloati(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.512.acc32(<8 x i64> [[A:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL18EXTRACT_V8ACCFLOATDV16_U10__ACCFLOATI_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.512.acc32(<8 x i64> [[A]], i32 1)
// CHECK-NEXT:    br label [[_ZL18EXTRACT_V8ACCFLOATDV16_U10__ACCFLOATI_EXIT]]
// CHECK:       _ZL18extract_v8accfloatDv16_u10__accfloati.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <4 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <4 x i64> [[RETVAL_0_I]]
//
v8accfloat test_extract_v8accfloat(v16accfloat a, int idx) {
   return extract_v8accfloat(a,idx);
}

// CHECK-LABEL: @_Z23test_extract_v8accfloatDv32_u10__accfloati(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc32(<16 x i64> [[A:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL18EXTRACT_V8ACCFLOATDV32_U10__ACCFLOATI_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc32(<16 x i64> [[A]], i32 1)
// CHECK-NEXT:    br label [[_ZL18EXTRACT_V8ACCFLOATDV32_U10__ACCFLOATI_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc32(<16 x i64> [[A]], i32 2)
// CHECK-NEXT:    br label [[_ZL18EXTRACT_V8ACCFLOATDV32_U10__ACCFLOATI_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x i64> @llvm.aie2.ext.256.1024.acc32(<16 x i64> [[A]], i32 3)
// CHECK-NEXT:    br label [[_ZL18EXTRACT_V8ACCFLOATDV32_U10__ACCFLOATI_EXIT]]
// CHECK:       _ZL18extract_v8accfloatDv32_u10__accfloati.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <4 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_THEN2_I]] ], [ [[TMP2]], [[IF_THEN5_I]] ], [ [[TMP3]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    ret <4 x i64> [[RETVAL_0_I]]
//
v8accfloat test_extract_v8accfloat(v32accfloat a, int idx) {
   return extract_v8accfloat(a,idx);
}

// CHECK-LABEL: @_Z24test_extract_v16accfloatDv32_u10__accfloati(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc32(<16 x i64> [[A:%.*]], i32 0)
// CHECK-NEXT:    br label [[_ZL19EXTRACT_V16ACCFLOATDV32_U10__ACCFLOATI_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i64> @llvm.aie2.ext.512.1024.acc32(<16 x i64> [[A]], i32 1)
// CHECK-NEXT:    br label [[_ZL19EXTRACT_V16ACCFLOATDV32_U10__ACCFLOATI_EXIT]]
// CHECK:       _ZL19extract_v16accfloatDv32_u10__accfloati.exit:
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi <8 x i64> [ [[TMP0]], [[IF_THEN_I]] ], [ [[TMP1]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    ret <8 x i64> [[RETVAL_0_I]]
//
v16accfloat test_extract_v16accfloat(v32accfloat a, int idx) {
   return extract_v16accfloat(a,idx);
}

/* Test Intrinsic using float type */

// CHECK-LABEL: @_Z11test_insertDv16_fiDv8_f(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x float> [[A:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x float> [[B:%.*]] to <8 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.upd.I512.I256(<16 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_FIDV8_F_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i32> @llvm.aie2.upd.I512.I256(<16 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV16_FIDV8_F_EXIT]]
// CHECK:       _ZL6insertDv16_fiDv8_f.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <16 x i32> [ [[TMP2]], [[IF_THEN_I]] ], [ [[TMP3]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <16 x i32> [[RETVAL_0_IN_I]] to <16 x float>
// CHECK-NEXT:    ret <16 x float> [[RETVAL_0_I]]
//
v16float test_insert(v16float a, int idx, v8float b) {
   return insert(a, idx, b);
}

// CHECK-LABEL: @_Z11test_insertDv32_fiDv8_f(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x float> [[A:%.*]] to <32 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x float> [[B:%.*]] to <8 x i32>
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I256(<32 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_FIDV8_F_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I256(<32 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_FIDV8_F_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I256(<32 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 2)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_FIDV8_F_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I256(<32 x i32> [[TMP0]], <8 x i32> [[TMP1]], i32 3)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_FIDV8_F_EXIT]]
// CHECK:       _ZL6insertDv32_fiDv8_f.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <32 x i32> [ [[TMP2]], [[IF_THEN_I]] ], [ [[TMP3]], [[IF_THEN2_I]] ], [ [[TMP4]], [[IF_THEN5_I]] ], [ [[TMP5]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <32 x i32> [[RETVAL_0_IN_I]] to <32 x float>
// CHECK-NEXT:    ret <32 x float> [[RETVAL_0_I]]
//
v32float test_insert(v32float a, int idx, v8float b) {
   return insert(a, idx, b);
}

// CHECK-LABEL: @_Z11test_insertDv32_fiDv16_f(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x float> [[A:%.*]] to <32 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x float> [[B:%.*]] to <16 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I512(<32 x i32> [[TMP0]], <16 x i32> [[TMP1]], i32 0)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_FIDV16_F_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <32 x i32> @llvm.aie2.upd.I1024.I512(<32 x i32> [[TMP0]], <16 x i32> [[TMP1]], i32 1)
// CHECK-NEXT:    br label [[_ZL6INSERTDV32_FIDV16_F_EXIT]]
// CHECK:       _ZL6insertDv32_fiDv16_f.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <32 x i32> [ [[TMP2]], [[IF_THEN_I]] ], [ [[TMP3]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <32 x i32> [[RETVAL_0_IN_I]] to <32 x float>
// CHECK-NEXT:    ret <32 x float> [[RETVAL_0_I]]
//
v32float test_insert(v32float a, int idx, v16float b) {
   return insert(a, idx, b);
}

// CHECK-LABEL: @_Z17test_set_v16floatiDv8_f(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[B:%.*]] to <8 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL12SET_V16FLOATIDV8_F_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I256(<8 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL12SET_V16FLOATIDV8_F_EXIT]]
// CHECK:       _ZL12set_v16floatiDv8_f.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <16 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <16 x i32> [[RETVAL_0_IN_I]] to <16 x float>
// CHECK-NEXT:    ret <16 x float> [[RETVAL_0_I]]
//
v16float test_set_v16float(int idx, v8float b) {
   return set_v16float(idx, b);
}

// CHECK-LABEL: @_Z17test_set_v32floatiDv8_f(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[B:%.*]] to <8 x i32>
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL12SET_V32FLOATIDV8_F_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL12SET_V32FLOATIDV8_F_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> [[TMP0]], i32 2)
// CHECK-NEXT:    br label [[_ZL12SET_V32FLOATIDV8_F_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I256(<8 x i32> [[TMP0]], i32 3)
// CHECK-NEXT:    br label [[_ZL12SET_V32FLOATIDV8_F_EXIT]]
// CHECK:       _ZL12set_v32floatiDv8_f.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <32 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_THEN2_I]] ], [ [[TMP3]], [[IF_THEN5_I]] ], [ [[TMP4]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <32 x i32> [[RETVAL_0_IN_I]] to <32 x float>
// CHECK-NEXT:    ret <32 x float> [[RETVAL_0_I]]
//
v32float test_set_v32float(int idx, v8float b) {
   return set_v32float(idx, b);
}

// CHECK-LABEL: @_Z17test_set_v32floatiDv16_f(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x float> [[B:%.*]] to <16 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I512(<16 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL12SET_V32FLOATIDV16_F_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <32 x i32> @llvm.aie2.set.I1024.I512(<16 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL12SET_V32FLOATIDV16_F_EXIT]]
// CHECK:       _ZL12set_v32floatiDv16_f.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <32 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <32 x i32> [[RETVAL_0_IN_I]] to <32 x float>
// CHECK-NEXT:    ret <32 x float> [[RETVAL_0_I]]
//
v32float test_set_v32float(int idx, v16float b) {
   return set_v32float(idx, b);
}

// CHECK-LABEL: @_Z11test_concatDv8_fS_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[A0:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x float> [[A1:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.concat.I512.I256(<8 x i32> [[TMP0]], <8 x i32> [[TMP1]])
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <16 x i32> [[TMP2]] to <16 x float>
// CHECK-NEXT:    ret <16 x float> [[TMP3]]
//
v16float test_concat(v8float a0, v8float a1) {
   return concat(a0, a1);
}

// CHECK-LABEL: @_Z11test_concatDv16_fS_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x float> [[A0:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x float> [[A1:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <32 x i32> @llvm.aie2.concat.I1024.I512(<16 x i32> [[TMP0]], <16 x i32> [[TMP1]])
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <32 x i32> [[TMP2]] to <32 x float>
// CHECK-NEXT:    ret <32 x float> [[TMP3]]
//
v32float test_concat(v16float a0, v16float a1) {
   return concat(a0, a1);
}

// CHECK-LABEL: @_Z11test_concatDv8_fS_S_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[A0:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x float> [[A1:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <8 x float> [[A2:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <8 x float> [[A3:%.*]] to <8 x i32>
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <32 x i32> @llvm.aie2.concat.I1024.I256(<8 x i32> [[TMP0]], <8 x i32> [[TMP1]], <8 x i32> [[TMP2]], <8 x i32> [[TMP3]])
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <32 x i32> [[TMP4]] to <32 x float>
// CHECK-NEXT:    ret <32 x float> [[TMP5]]
//
v32float test_concat(v8float a0, v8float a1, v8float a2, v8float a3) {
  return concat(a0, a1, a2, a3);
}

// CHECK-LABEL: @_Z20test_extract_v8floatDv16_fi(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x float> [[A:%.*]] to <16 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8FLOATDV16_FI_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8FLOATDV16_FI_EXIT]]
// CHECK:       _ZL15extract_v8floatDv16_fi.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <8 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <8 x i32> [[RETVAL_0_IN_I]] to <8 x float>
// CHECK-NEXT:    ret <8 x float> [[RETVAL_0_I]]
//
v8float test_extract_v8float(v16float a, int idx) {
   return extract_v8float(a,idx);
}

// CHECK-LABEL: @_Z20test_extract_v8floatDv32_fi(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x float> [[A:%.*]] to <32 x i32>
// CHECK-NEXT:    switch i32 [[IDX:%.*]], label [[IF_ELSE6_I:%.*]] [
// CHECK-NEXT:      i32 0, label [[IF_THEN_I:%.*]]
// CHECK-NEXT:      i32 1, label [[IF_THEN2_I:%.*]]
// CHECK-NEXT:      i32 2, label [[IF_THEN5_I:%.*]]
// CHECK-NEXT:    ]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8FLOATDV32_FI_EXIT:%.*]]
// CHECK:       if.then2.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8FLOATDV32_FI_EXIT]]
// CHECK:       if.then5.i:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> [[TMP0]], i32 2)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8FLOATDV32_FI_EXIT]]
// CHECK:       if.else6.i:
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I1024(<32 x i32> [[TMP0]], i32 3)
// CHECK-NEXT:    br label [[_ZL15EXTRACT_V8FLOATDV32_FI_EXIT]]
// CHECK:       _ZL15extract_v8floatDv32_fi.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <8 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_THEN2_I]] ], [ [[TMP3]], [[IF_THEN5_I]] ], [ [[TMP4]], [[IF_ELSE6_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <8 x i32> [[RETVAL_0_IN_I]] to <8 x float>
// CHECK-NEXT:    ret <8 x float> [[RETVAL_0_I]]
//
v8float test_extract_v8float(v32float a, int idx) {
   return extract_v8float(a,idx);
}

// CHECK-LABEL: @_Z21test_extract_v16floatDv32_fi(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[IDX:%.*]], 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x float> [[A:%.*]] to <32 x i32>
// CHECK-NEXT:    br i1 [[CMP_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
// CHECK:       if.then.i:
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.ext.I512.I1024(<32 x i32> [[TMP0]], i32 0)
// CHECK-NEXT:    br label [[_ZL16EXTRACT_V16FLOATDV32_FI_EXIT:%.*]]
// CHECK:       if.else.i:
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <16 x i32> @llvm.aie2.ext.I512.I1024(<32 x i32> [[TMP0]], i32 1)
// CHECK-NEXT:    br label [[_ZL16EXTRACT_V16FLOATDV32_FI_EXIT]]
// CHECK:       _ZL16extract_v16floatDv32_fi.exit:
// CHECK-NEXT:    [[RETVAL_0_IN_I:%.*]] = phi <16 x i32> [ [[TMP1]], [[IF_THEN_I]] ], [ [[TMP2]], [[IF_ELSE_I]] ]
// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = bitcast <16 x i32> [[RETVAL_0_IN_I]] to <16 x float>
// CHECK-NEXT:    ret <16 x float> [[RETVAL_0_I]]
//
v16float test_extract_v16float(v32float a, int idx) {
   return extract_v16float(a,idx);
}

// CHECK-LABEL: @_Z24test_extract_v16bfloat16Dv32_u6__bf16i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x bfloat> @llvm.aie2.ext.bf256.bf512(<32 x bfloat> [[A:%.*]], i32 0)
// CHECK-NEXT:    ret <16 x bfloat> [[TMP0]]
//
v16bfloat16 test_extract_v16bfloat16(v32bfloat16 a, int idx) {
    return extract_v16bfloat16(a, 0);
}

// CHECK-LABEL: @_Z11test_insertDv32_u6__bf16iDv16_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x bfloat> @llvm.aie2.upd.bf512.bf256(<32 x bfloat> [[A:%.*]], <16 x bfloat> [[B:%.*]], i32 1)
// CHECK-NEXT:    ret <32 x bfloat> [[TMP0]]
//
v32bfloat16 test_insert(v32bfloat16 a, int idx, v16bfloat16 b) {
    return insert(a,1,b);
}

// CHECK-LABEL: @_Z20test_set_v32bfloat16iDv16_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <32 x bfloat> @llvm.aie2.set.bf512.bf256(<16 x bfloat> [[B:%.*]], i32 1)
// CHECK-NEXT:    ret <32 x bfloat> [[TMP0]]
//
v32bfloat16 test_set_v32bfloat16(int idx, v16bfloat16 b) {
    return set_v32bfloat16(1, b);
}

// CHECK-LABEL: @_Z11test_concatDv16_u6__bf16S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x bfloat> @llvm.aie2.concat.bf512.bf256(<16 x bfloat> [[A0:%.*]], <16 x bfloat> [[A1:%.*]])
// CHECK-NEXT:    ret <32 x bfloat> [[TMP0]]
//
v32bfloat16 test_concat(v16bfloat16 a0, v16bfloat16 a1) {
  return concat(a0, a1);
}

// CHECK-LABEL: @_Z24test_extract_v16bfloat16Dv64_u6__bf16i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <16 x bfloat> @llvm.aie2.ext.bf256.bf1024(<64 x bfloat> [[A:%.*]], i32 3)
// CHECK-NEXT:    ret <16 x bfloat> [[TMP0]]
//
v16bfloat16 test_extract_v16bfloat16(v64bfloat16 a, int idx) {
    return extract_v16bfloat16(a, 3);
}

// CHECK-LABEL: @_Z11test_insertDv64_u6__bf16iDv16_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <64 x bfloat> @llvm.aie2.upd.bf1024.bf256(<64 x bfloat> [[A:%.*]], <16 x bfloat> [[B:%.*]], i32 2)
// CHECK-NEXT:    ret <64 x bfloat> [[TMP0]]
//
v64bfloat16 test_insert(v64bfloat16 a, int idx, v16bfloat16 b) {
    return insert(a, 2, b);
}

// CHECK-LABEL: @_Z20test_set_v64bfloat16iDv16_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <64 x bfloat> @llvm.aie2.set.bf1024.bf256(<16 x bfloat> [[B:%.*]], i32 1)
// CHECK-NEXT:    ret <64 x bfloat> [[TMP0]]
//
v64bfloat16 test_set_v64bfloat16(int idx, v16bfloat16 b) {
    return set_v64bfloat16(1, b);
}

// CHECK-LABEL: @_Z11test_concatDv16_u6__bf16S_S_S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <64 x bfloat> @llvm.aie2.concat.bf1024.bf256(<16 x bfloat> [[A0:%.*]], <16 x bfloat> [[A1:%.*]], <16 x bfloat> [[A2:%.*]], <16 x bfloat> [[A3:%.*]])
// CHECK-NEXT:    ret <64 x bfloat> [[TMP0]]
//
v64bfloat16 test_concat(v16bfloat16 a0, v16bfloat16 a1, v16bfloat16 a2, v16bfloat16 a3) {
  return concat(a0, a1, a2, a3);
}

// CHECK-LABEL: @_Z24test_extract_v32bfloat16Dv64_u6__bf16i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <32 x bfloat> @llvm.aie2.ext.bf512.bf1024(<64 x bfloat> [[A:%.*]], i32 1)
// CHECK-NEXT:    ret <32 x bfloat> [[TMP0]]
//
v32bfloat16 test_extract_v32bfloat16(v64bfloat16 a, int idx) {
    return extract_v32bfloat16(a, 1);
}

// CHECK-LABEL: @_Z11test_insertDv64_u6__bf16iDv32_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <64 x bfloat> @llvm.aie2.upd.bf1024.bf512(<64 x bfloat> [[A:%.*]], <32 x bfloat> [[B:%.*]], i32 1)
// CHECK-NEXT:    ret <64 x bfloat> [[TMP0]]
//
v64bfloat16 test_insert(v64bfloat16 a, int idx, v32bfloat16 b) {
    return insert(a, 1, b);
}

// CHECK-LABEL: @_Z20test_set_v64bfloat16iDv32_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <64 x bfloat> @llvm.aie2.set.bf1024.bf512(<32 x bfloat> [[B:%.*]], i32 1)
// CHECK-NEXT:    ret <64 x bfloat> [[TMP0]]
//
v64bfloat16 test_set_v64bfloat16(int idx, v32bfloat16 b) {
    return set_v64bfloat16(1, b);
}

// CHECK-LABEL: @_Z11test_concatDv32_u6__bf16S_(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call noundef <64 x bfloat> @llvm.aie2.concat.bf1024.bf512(<32 x bfloat> [[A0:%.*]], <32 x bfloat> [[A1:%.*]])
// CHECK-NEXT:    ret <64 x bfloat> [[TMP0]]
//
v64bfloat16 test_concat(v32bfloat16 a0, v32bfloat16 a1) {
  return concat(a0, a1);
}

// CHECK-LABEL: @_Z20test_set_v16bfloat16iDv8_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x bfloat> [[A:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <8 x i32> @llvm.aie2.get.I256.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <8 x i32> [[TMP1]] to <16 x bfloat>
// CHECK-NEXT:    ret <16 x bfloat> [[TMP2]]
//
v16bfloat16 test_set_v16bfloat16(int idx, v8bfloat16 a) {
    return set_v16bfloat16(0,a);
}

// CHECK-LABEL: @_Z24test_set_v16bfloat16_idxiDv8_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x bfloat> [[A:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <32 x i16> @llvm.aie2.v32int16()
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <32 x i16> [[TMP2]] to <16 x i32>
// CHECK-NEXT:    [[TMP4:%.*]] = shl i32 [[IDX:%.*]], 4
// CHECK-NEXT:    [[MUL_I:%.*]] = sub i32 64, [[TMP4]]
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP3]], <16 x i32> [[TMP1]], i32 0, i32 [[MUL_I]])
// CHECK-NEXT:    [[TMP6:%.*]] = tail call <8 x i32> @llvm.aie2.ext.I256.I512(<16 x i32> [[TMP5]], i32 0)
// CHECK-NEXT:    [[TMP7:%.*]] = bitcast <8 x i32> [[TMP6]] to <16 x bfloat>
// CHECK-NEXT:    ret <16 x bfloat> [[TMP7]]
//
v16bfloat16 test_set_v16bfloat16_idx(int idx, v8bfloat16 a) {
   return set_v16bfloat16(idx, a);
}

// CHECK-LABEL: @_Z11test_insertDv32_u6__bf16iDv8_u6__bf16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x bfloat> [[B:%.*]] to <4 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <16 x i32> @llvm.aie2.set.I512.I128(<4 x i32> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <32 x bfloat> @llvm.aie2.v32bfloat16()
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <32 x bfloat> [[TMP2]] to <16 x i32>
// CHECK-NEXT:    [[TMP4:%.*]] = shl i32 [[IDX:%.*]], 4
// CHECK-NEXT:    [[MUL_I3:%.*]] = sub i32 64, [[TMP4]]
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP3]], <16 x i32> [[TMP1]], i32 0, i32 [[MUL_I3]])
// CHECK-NEXT:    [[MUL_I:%.*]] = shl i32 [[IDX]], 2
// CHECK-NEXT:    [[SHL_I:%.*]] = shl i32 15, [[MUL_I]]
// CHECK-NEXT:    [[TMP6:%.*]] = bitcast <32 x bfloat> [[V:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <16 x i32> @llvm.aie2.vsel32(<16 x i32> [[TMP6]], <16 x i32> [[TMP5]], i32 [[SHL_I]])
// CHECK-NEXT:    [[TMP8:%.*]] = bitcast <16 x i32> [[TMP7]] to <32 x bfloat>
// CHECK-NEXT:    ret <32 x bfloat> [[TMP8]]
//
v32bfloat16 test_insert(v32bfloat16 v, int idx, v8bfloat16 b) {
  return insert(v, idx, b);
}

// CHECK-LABEL: @_Z27test_extract_v8bfloat16_512Dv32_u6__bf16i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x bfloat> [[A:%.*]] to <16 x i32>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call noundef <32 x bfloat> @llvm.aie2.v32bfloat16()
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast <32 x bfloat> [[TMP1]] to <16 x i32>
// CHECK-NEXT:    [[MUL_I:%.*]] = shl nsw i32 [[IDX:%.*]], 4
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP0]], <16 x i32> [[TMP2]], i32 0, i32 [[MUL_I]])
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <4 x i32> @llvm.aie2.extract.I128.I512(<16 x i32> [[TMP3]])
// CHECK-NEXT:    [[TMP5:%.*]] = bitcast <4 x i32> [[TMP4]] to <8 x bfloat>
// CHECK-NEXT:    ret <8 x bfloat> [[TMP5]]
//
v8bfloat16 test_extract_v8bfloat16_512(v32bfloat16 a, int idx) {
   return extract_v8bfloat16(a,idx);
}

// CHECK-LABEL: @_Z27test_extract_v8bfloat16_256Dv16_u6__bf16i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <32 x bfloat> @llvm.aie2.set.bf512.bf256(<16 x bfloat> [[A:%.*]], i32 0)
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x bfloat> [[TMP0]] to <16 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef <32 x bfloat> @llvm.aie2.v32bfloat16()
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast <32 x bfloat> [[TMP2]] to <16 x i32>
// CHECK-NEXT:    [[MUL_I_I:%.*]] = shl nsw i32 [[IDX:%.*]], 4
// CHECK-NEXT:    [[TMP4:%.*]] = tail call <16 x i32> @llvm.aie2.vshift.I512.I512(<16 x i32> [[TMP1]], <16 x i32> [[TMP3]], i32 0, i32 [[MUL_I_I]])
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <4 x i32> @llvm.aie2.extract.I128.I512(<16 x i32> [[TMP4]])
// CHECK-NEXT:    [[TMP6:%.*]] = bitcast <4 x i32> [[TMP5]] to <8 x bfloat>
// CHECK-NEXT:    ret <8 x bfloat> [[TMP6]]
//
v8bfloat16 test_extract_v8bfloat16_256(v16bfloat16 a, int idx) {
   return extract_v8bfloat16(a,idx);
}
