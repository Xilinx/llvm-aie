// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//===- aie2-pckt_header.cpp -------------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: %clang -O2 %s --target=aie2 -S -emit-llvm -o - | FileCheck %s

// CHECK-LABEL: @_Z25test_put_ms_packet_headerijj(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.aie2.put.ms.packet.header(i32 [[TLAST:%.*]], i32 [[DSTID:%.*]], i32 [[PCKTTYPE:%.*]])
// CHECK-NEXT:    ret void
//
void test_put_ms_packet_header(int tlast, unsigned dstID, unsigned pcktType) {
  put_ms_packet_header(tlast, dstID, pcktType);
}
// CHECK-LABEL: @_Z25test_put_ms_packet_headerjj(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.aie2.put.ms.packet.header(i32 0, i32 [[DSTID:%.*]], i32 [[PCKTTYPE:%.*]])
// CHECK-NEXT:    ret void
//
void test_put_ms_packet_header(unsigned dstID, unsigned pcktType) {
  put_ms_packet_header(dstID, pcktType);
}
// CHECK-LABEL: @_Z28test_put_ms_nb_packet_headerijjRb(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i32 @llvm.aie2.put.ms.nb.packet.header(i32 [[TLAST:%.*]], i32 [[DSTID:%.*]], i32 [[PCKTTYPE:%.*]])
// CHECK-NEXT:    [[TOBOOL_I:%.*]] = icmp ne i32 [[TMP0]], 0
// CHECK-NEXT:    [[FROMBOOL_I:%.*]] = zext i1 [[TOBOOL_I]] to i8
// CHECK-NEXT:    store i8 [[FROMBOOL_I]], ptr [[SUCCESS:%.*]], align 1, !tbaa [[TBAA2:![0-9]+]]
// CHECK-NEXT:    ret void
//
void test_put_ms_nb_packet_header(int tlast, unsigned dstID, unsigned pcktType,
                                  bool &success) {
  put_ms_nb_packet_header(tlast, dstID, pcktType, success);
}
// CHECK-LABEL: @_Z28test_put_ms_nb_packet_headerjjRb(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i32 @llvm.aie2.put.ms.nb.packet.header(i32 0, i32 [[DSTID:%.*]], i32 [[PCKTTYPE:%.*]])
// CHECK-NEXT:    [[TOBOOL_I:%.*]] = icmp ne i32 [[TMP0]], 0
// CHECK-NEXT:    [[FROMBOOL_I:%.*]] = zext i1 [[TOBOOL_I]] to i8
// CHECK-NEXT:    store i8 [[FROMBOOL_I]], ptr [[SUCCESS:%.*]], align 1, !tbaa [[TBAA2]]
// CHECK-NEXT:    ret void
//
void test_put_ms_nb_packet_header(unsigned dstID, unsigned pcktType,
                                  bool &success) {
  put_ms_nb_packet_header(dstID, pcktType, success);
}
// CHECK-LABEL: @_Z30test_put_ms_ctrl_packet_headerijjjj(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SUB_I:%.*]] = add i32 [[N_WORDS:%.*]], -1
// CHECK-NEXT:    tail call void @llvm.aie2.put.ms.ctrl.packet.header(i32 [[TLAST:%.*]], i32 [[ADDR:%.*]], i32 [[SUB_I]], i32 [[OP_TYPE:%.*]], i32 [[RSPID:%.*]])
// CHECK-NEXT:    ret void
//
void test_put_ms_ctrl_packet_header(int tlast, unsigned Addr, unsigned n_words,
                                    unsigned op_type, unsigned rspID) {
  put_ms_ctrl_packet_header(tlast, Addr, n_words, op_type, rspID);
}
// CHECK-LABEL: @_Z30test_put_ms_ctrl_packet_headerjjjj(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SUB_I:%.*]] = add i32 [[N_WORDS:%.*]], -1
// CHECK-NEXT:    tail call void @llvm.aie2.put.ms.ctrl.packet.header(i32 0, i32 [[ADDR:%.*]], i32 [[SUB_I]], i32 [[OP_TYPE:%.*]], i32 [[RSPID:%.*]])
// CHECK-NEXT:    ret void
//
void test_put_ms_ctrl_packet_header(unsigned Addr, unsigned n_words,
                                    unsigned op_type, unsigned rspID) {
  put_ms_ctrl_packet_header(Addr, n_words, op_type, rspID);
}
// CHECK-LABEL: @_Z33test_put_ms_nb_ctrl_packet_headerijjjjRb(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SUB_I:%.*]] = add i32 [[N_WORDS:%.*]], -1
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i32 @llvm.aie2.put.ms.nb.ctrl.packet.header(i32 [[TLAST:%.*]], i32 [[ADDR:%.*]], i32 [[SUB_I]], i32 [[OP_TYPE:%.*]], i32 [[RSPID:%.*]])
// CHECK-NEXT:    [[TOBOOL_I:%.*]] = icmp ne i32 [[TMP0]], 0
// CHECK-NEXT:    [[FROMBOOL_I:%.*]] = zext i1 [[TOBOOL_I]] to i8
// CHECK-NEXT:    store i8 [[FROMBOOL_I]], ptr [[SUCCESS:%.*]], align 1, !tbaa [[TBAA2]]
// CHECK-NEXT:    ret void
//
void test_put_ms_nb_ctrl_packet_header(int tlast, unsigned Addr,
                                       unsigned n_words, unsigned op_type,
                                       unsigned rspID, bool &success) {
  put_ms_nb_ctrl_packet_header(tlast, Addr, n_words, op_type, rspID, success);
}
// CHECK-LABEL: @_Z33test_put_ms_nb_ctrl_packet_headerjjjjRb(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SUB_I:%.*]] = add i32 [[N_WORDS:%.*]], -1
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i32 @llvm.aie2.put.ms.nb.ctrl.packet.header(i32 0, i32 [[ADDR:%.*]], i32 [[SUB_I]], i32 [[OP_TYPE:%.*]], i32 [[RSPID:%.*]])
// CHECK-NEXT:    [[TOBOOL_I:%.*]] = icmp ne i32 [[TMP0]], 0
// CHECK-NEXT:    [[FROMBOOL_I:%.*]] = zext i1 [[TOBOOL_I]] to i8
// CHECK-NEXT:    store i8 [[FROMBOOL_I]], ptr [[SUCCESS:%.*]], align 1, !tbaa [[TBAA2]]
// CHECK-NEXT:    ret void
//
void test_put_ms_nb_ctrl_packet_header(unsigned Addr, unsigned n_words,
                                       unsigned op_type, unsigned rspID,
                                       bool &success) {
  put_ms_nb_ctrl_packet_header(0, Addr, n_words, op_type, rspID, success);
}
