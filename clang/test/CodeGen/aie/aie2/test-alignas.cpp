// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//===- test-alignas.cpp -----------------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: %clang --target=aie2 -nostdlibinc -S -emit-llvm %s -O0 -o - | FileCheck %s

// CHECK: %struct.S1 = type { i32, [252 x i8] }
struct S1 {
  alignas(256) int n;
};
// CHECK: %struct.S7 = type { %struct.S1 }
struct S7 : S1 {
};

// CHECK: @n9 = dso_local global i32 0, align 1024
alignas(1024) int n9;

// CHECK: @lcpPing = dso_local global [256 x i32] zeroinitializer, align 4
uint32 lcpPing[256];

// CHECK-LABEL: @_Z12test_alignasv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = alloca [16 x i16], align 256
// CHECK-NEXT:    [[B:%.*]] = alloca <16 x i16>, align 1024
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 256 [[A]], ptr align 256 @__const._Z12test_alignasv.a, i32 32, i1 false)
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [16 x i16], ptr [[A]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds <16 x i16>, ptr [[ARRAYDECAY]], i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load <16 x i16>, ptr [[ARRAYIDX]], align 256
// CHECK-NEXT:    store <16 x i16> [[TMP0]], ptr [[B]], align 1024
// CHECK-NEXT:    [[TMP1:%.*]] = load <16 x i16>, ptr [[B]], align 1024
// CHECK-NEXT:    ret <16 x i16> [[TMP1]]
//
v16uint16 test_alignas() {
  alignas(256) uint16 a [16] = {0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0,0,0,0,0,0,0,0};
  alignas(1024) v16uint16 b = reinterpret_cast<v16uint16*>(a)[0];
  return b;
}

// CHECK-LABEL: @_Z13test_alignas1v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S1:%.*]] = alloca [[STRUCT_S1:%.*]], align 512
// CHECK-NEXT:    [[B:%.*]] = alloca i32, align 64
// CHECK-NEXT:    [[S7:%.*]] = alloca [[STRUCT_S7:%.*]], align 1024
// CHECK-NEXT:    [[N:%.*]] = getelementptr inbounds [[STRUCT_S1]], ptr [[S1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[N]], align 512
// CHECK-NEXT:    store i32 [[TMP0]], ptr [[B]], align 64
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @n9, align 1024
// CHECK-NEXT:    ret i32 [[TMP1]]
//
int test_alignas1() {
  S1 s1 alignas(512);
  alignas(64) int b = s1.n;
  S7 s7 alignas(1024);
  return n9;
}
