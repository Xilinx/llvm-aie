// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//===- aie2-typecast.cpp ----------------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2023-2024 Advanced Micro Devices, Inc. or its affiliates
//
//===----------------------------------------------------------------------===//
// RUN: %clang --target=aie2 -S -emit-llvm %s -o - | FileCheck %s
enum class AccumClass { Int };

template <AccumClass Class, unsigned Bits, unsigned Elems>
struct accum_storage;

template <AccumClass Class, unsigned Bits, unsigned Elems>
using accum_storage_t = typename accum_storage<Class, Bits, Elems>::type;

template <> struct accum_storage<AccumClass::Int,  32,  16> {
    using type = v8acc64;
    static type undef() { return undef_v8acc64(); }
};

template <AccumClass Class, unsigned MinBits, unsigned Elems>
class accum {
    static constexpr unsigned Bits = 32;
    using storage_type = accum_storage<Class, Bits, Elems>;
    using storage_t    = accum_storage_t<Class, Bits, Elems>;
public:
    storage_t data;
    accum() : data(storage_type::undef()) {}
    accum(storage_t data) : data(data) {}
    operator storage_t() const { return data; }
};

// CHECK-LABEL: @_Z5test05accumIL10AccumClass0ELj32ELj16EE(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ACC:%.*]] = alloca [[CLASS_ACCUM:%.*]], align 32
// CHECK-NEXT:    store [[CLASS_ACCUM]] [[ACC_COERCE:%.*]], ptr [[ACC]], align 32
// CHECK-NEXT:    [[CALL:%.*]] = call noundef <8 x i64> @_ZNK5accumIL10AccumClass0ELj32ELj16EEcvDv8_u7__acc64Ev(ptr nonnull align 32 dereferenceable(64) [[ACC]])
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x i64> [[CALL]] to <16 x i32>
// CHECK-NEXT:    ret <16 x i32> [[TMP0]]
//
v16int32 test0(accum<AccumClass::Int, 32, 16> acc) {
    return (v16int32)acc;
}
// CHECK-LABEL: @_Z5test1Dv16_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca <16 x i32>, align 32
// CHECK-NEXT:    [[ACC:%.*]] = alloca [[CLASS_ACCUM:%.*]], align 32
// CHECK-NEXT:    store <16 x i32> [[A:%.*]], ptr [[A_ADDR]], align 32
// CHECK-NEXT:    [[TMP0:%.*]] = load <16 x i32>, ptr [[A_ADDR]], align 32
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i32> [[TMP0]] to <8 x i64>
// CHECK-NEXT:    call void @_ZN5accumIL10AccumClass0ELj32ELj16EEC2EDv8_u7__acc64(ptr nonnull align 32 dereferenceable(64) [[ACC]], <8 x i64> noundef [[TMP1]])
// CHECK-NEXT:    [[CALL:%.*]] = call noundef <8 x i64> @_ZNK5accumIL10AccumClass0ELj32ELj16EEcvDv8_u7__acc64Ev(ptr nonnull align 32 dereferenceable(64) [[ACC]])
// CHECK-NEXT:    ret <8 x i64> [[CALL]]
//
v16acc32 test1 (v16int32 a) {
    accum<AccumClass::Int, 32, 16> acc = (accum<AccumClass::Int, 32, 16>)a;
    return (v16acc32)acc;
}
// CHECK-LABEL: @_Z5test2Dv16_u7__acc32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca <8 x i64>, align 32
// CHECK-NEXT:    store <8 x i64> [[A:%.*]], ptr [[A_ADDR]], align 32
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i64>, ptr [[A_ADDR]], align 32
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i64> [[TMP0]] to <16 x i32>
// CHECK-NEXT:    ret <16 x i32> [[TMP1]]
//
v16int32 test2(v16acc32 a) {
  return (v16int32)a;
}
// CHECK-LABEL: @_Z5test3Dv32_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca <32 x i32>, align 32
// CHECK-NEXT:    store <32 x i32> [[A:%.*]], ptr [[A_ADDR]], align 32
// CHECK-NEXT:    [[TMP0:%.*]] = load <32 x i32>, ptr [[A_ADDR]], align 32
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <32 x i32> [[TMP0]] to <16 x i64>
// CHECK-NEXT:    ret <16 x i64> [[TMP1]]
//
v32acc32 test3(v32int32 a) {
  return v32acc32(a);
}
// CHECK-LABEL: @_Z5test4Dv16_i(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca <16 x i32>, align 32
// CHECK-NEXT:    store <16 x i32> [[A:%.*]], ptr [[A_ADDR]], align 32
// CHECK-NEXT:    [[TMP0:%.*]] = load <16 x i32>, ptr [[A_ADDR]], align 32
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i32> [[TMP0]] to <8 x i64>
// CHECK-NEXT:    ret <8 x i64> [[TMP1]]
//
v8acc64 test4(v16int32 a) {
  return (v8acc64)a;
}
// CHECK-LABEL: @_Z5test5Dv16_u7__acc64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca <16 x i64>, align 32
// CHECK-NEXT:    store <16 x i64> [[A:%.*]], ptr [[A_ADDR]], align 32
// CHECK-NEXT:    [[TMP0:%.*]] = load <16 x i64>, ptr [[A_ADDR]], align 32
// CHECK-NEXT:    ret <16 x i64> [[TMP0]]
//
v32acc32 test5(v16acc64 a) {
  return (v32acc32)a;
}
