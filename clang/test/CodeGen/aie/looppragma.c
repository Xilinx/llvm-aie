// --- looppragma.c ---------------------------------------------------------///
// NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates
// --------------------------------------------------------------------------///
// RUN: %clang --target=aie2 -S -emit-llvm %s -o - | FileCheck %s

// CHECK: !4 = !{!"llvm.loop.itercount.range", i64 2}
// CHECK: !6 = !{!"llvm.loop.itercount.range", i64 3, i64 6}
// CHECK: !8 = !{!"llvm.loop.itercount.range", i64 4, i64 7}
// CHECK: !10 = !{!"llvm.loop.itercount.range", i64 16, i64 36}
// CHECK: !11 = !{!"llvm.loop.unroll.count", i32 4}

int loop_lwb(int *p, int n) {
  int s = 0;
  #pragma clang loop min_iteration_count(2)
  for (int i = 0; i < n; i++) {
    s += *p++;
  }

  return s;
}

int loop_range_one_pragma(int *p, int n) {
  int s = 0;
  #pragma clang loop min_iteration_count(3) max_iteration_count(6)
  for (int i = 0; i < n; i++) {
    s += *p++;
  }

  return s;
}

int loop_range_two_pragmas(int *p, int n) {
  int s = 0;
  #pragma clang loop min_iteration_count(4)
  #pragma clang loop max_iteration_count(7)
  for (int i = 0; i < n; i++) {
    s += *p++;
  }

  return s;
}

int loop_range_with_unroll(int *p, int n) {
  int s = 0;

  #pragma clang loop unroll_count(4)
  #pragma clang loop min_iteration_count(16) max_iteration_count(36)
  for (int i = 0; i < n; i++) {
    s += *p++;
  }

  return s;
}

