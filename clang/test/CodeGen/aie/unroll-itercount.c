// --- unroll-itercount.c ---------------------------------------------------///
// NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates
// --------------------------------------------------------------------------///

// RUN: %clang --target=aie2 -O2 -S -emit-llvm %s -o - | FileCheck %s

// CHECK-LABEL: @before
// CHECK: !llvm.loop !6
// CHECK: !llvm.loop !8
// CHECK-LABEL: @after
// CHECK: !llvm.loop !10
// CHECK: !llvm.loop !11
// CHECK-LABEL: @single_before
// CHECK: !llvm.loop !12
// CHECK: !llvm.loop !13
// CHECK-LABEL: @single_after
// CHECK: !llvm.loop !15
// CHECK: !llvm.loop !16

// CHECK: !6 = distinct !{!6, !7}
// CHECK: !7 = !{!"llvm.loop.unroll.disable"}
// CHECK: !8 = distinct !{!8, !9, !7}
// CHECK: !9 = !{!"llvm.loop.itercount.range", i32 7, i32 9}
// CHECK: !10 = distinct !{!10, !7}
// CHECK: !11 = distinct !{!11, !9, !7}
// CHECK: !12 = distinct !{!12, !7}
// CHECK: !13 = distinct !{!13, !14, !7}
// CHECK: !14 = !{!"llvm.loop.itercount.range", i32 7}
// CHECK: !15 = distinct !{!15, !7}
// CHECK: !16 = distinct !{!16, !17, !7}
// CHECK: !17 = !{!"llvm.loop.itercount.range", i32 5}


int before(int n, int *p) {
  int s = 0;
#pragma clang loop unroll_count(4)
#pragma clang loop min_iteration_count(28)
#pragma clang loop max_iteration_count(37)
  for (int i = 0; i < n; i++) {
    s += p[i];
  }

  return s;
}

int after(int n, int *p) {
  int s = 0;
#pragma clang loop min_iteration_count(29)
#pragma clang loop max_iteration_count(36)
#pragma clang loop unroll_count(4)
  for (int i = 0; i < n; i++) {
    s += p[i];
  }

  return s;
}

int single_before(int n, int *p) {
  int s = 0;
#pragma clang loop unroll_count(4)
#pragma clang loop min_iteration_count(29)
  for (int i = 0; i < n; i++) {
    s += p[i];
  }

  return s;
}
int single_after(int n, int *p) {
  int s = 0;
#pragma clang loop min_iteration_count(29)
#pragma clang loop unroll_count(5)
  for (int i = 0; i < n; i++) {
    s += p[i];
  }

  return s;
}

